..
      Licensed under the Apache License, Version 2.0 (the "License"); you may
      not use this file except in compliance with the License. You may obtain
      a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
      WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
      License for the specific language governing permissions and limitations
      under the License.

      Convention for heading levels in Open vSwitch documentation:

      =======  Heading 0 (reserved for the title in a document)
      -------  Heading 1
      ~~~~~~~  Heading 2
      +++++++  Heading 3
      '''''''  Heading 4

      Avoid deeper levels because they do not render well.

==========================================================
Usage of Open vSwitch generated executables for P4 support
==========================================================

This document describes how to use executables generated by Open vSwitch
for supporting P4 programs.

- For code clone and build instructions refer to ``p4proto/p4rt/README``.

Prerequisites
-------------

Before using executables generated by OvS for P4 programming, user should
be having a valid P4 file and generated dependent files using P4 compiler
for the specific target.

Dependent generated files for a sample.p4 file::

    $ sample.conf, p4info.txt, bf-rt.json, pipe/context.json, pipe/sample.spec


P4 DPDK backend supports both PSA and PNA architectures.
Based on the architecture used in the P4 program, P4 compiler emits the pipeline name differently.
If P4 program is defined for

     - PNA architecture, P4 compiler emits the PIPELINE name as "pipe" irrespective of the
       name defined in the P4 program.
     - PSA architecture, P4 compiler uses and emits the PIPELINE name defined by the user in the program.
       Currently it supports only ingress pipelines.

This pipeline name is referred in below three places and consumed by P4-OVS to program the target.
    a) 'p4_pipeline_name' in /usr/share/stratum/target_skip_p4_no_bsp.conf file.
    b) 'p4_pipeline_name' in sample.conf file.
    c) 'pipeline-name' parameter in gnmi-cli, while configuring the PORT
        Ex: gnmi-cli set "device:virtual-device,name:TAP1,pipeline-name:pipe,mtu:1500,port-type:TAP"

P4-OVS assumes pipeline name is defaulted to "pipe".
If the P4 program is defined for PSA architecture and uses a pipeline name other than "pipe", we need
to manually change the 'pipeline name'
at all the above three places to the ingress pipeline name mentioned in the p4 file.

Hence to avoid this handcrafting, we recommend using the ingress pipeline name as "pipe" for all the
PSA programs.

ovs_pipeline_builder executable
-------------------------------

ovs_pipeline_builder is an executable generated when OvS is built and this
executable is used to generate a protobuf based bin file.
This pb.bin contains information of bfrt-config, context and config which are
extracted from sample.conf which is genrated via p4c compiler as mentioned
above.

Generate ``pb.bin``::

    $ ovs_pipeline_builder --p4c_conf_file=<path-to-input-sample-file.conf> \
        --bf_pipeline_config_binary_file=<path-to-output-file.pb.bin>
    $ Example: \
        ovs_pipeline_builder --p4c_conf_file=/home/mydir/sample.conf \
            --bf_pipeline_config_binary_file=/home/mydir/sample.pb.bin

.. important::

    Here we need to execute this command from the parent directory of
    relative paths mentioned in bfrt-config/context/config parameters
    of sample.conf


ovs-p4ctl executable
--------------------

ovs-p4ctl is an executable generated when OvS is built and this executable
is an gRPC client which connects to gRPC server running in OvS for enabling
p4runtime capabilities.

Each CLI command connects to gRPC ports opened by server, send a protobuf based
message. Refer to p4runtime.proto for more details on type of messages and
services that are available for a p4runtime client.

1. Set a forwarding pipeline::

    $ ovs-p4ctl set-pipe SWITCH PROGRAM P4INFO
    $ Example: ovs-p4ctl set-pipe br0 <path>/sample.pb.bin <path>/p4info.txt

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``PROGRAM``: Refers to protobuf binary file generated by
    ovs_pipeline_builder executable and P4 program's configuration file.
    ``P4INFO``: Refers to P4Info.txt file generated by p4c compiler
    for a P4 program.

2. Get a forwarding pipeline::

    $ ovs-p4ctl get-pipe SWITCH
    $ Example: ovs-p4ctl set-pipe br0

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.

3. Add a rule for a table into the forwarding pipeline::

    $ ovs-p4ctl add-entry SWITCH TABLE FLOW
    $ Example:: ovs-p4ctl add-entry br0 ipv4_host "dst_ip=1.1.1.1,action=send(10)"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``FLOW``: Refers to parameters for a the above mentioned TABLE
    match_filed_key=value action=action_name(value)

4. Delete a rule for a table from the forwarding pipeline::

    $ ovs-p4ctl del-entry SWITCH TABLE KEY
    $ Example: ovs-p4ctl del-entry br0 ipv4_host "dst_ip=1.1.1.1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``KEY``: Refers to match_filed_key parameter of the above mentioned
    TABLE match_filed_key=value

5. Get programmed rule from the forwarding pipeline [Future Implementation]::

    $ ovs-p4ctl dump-entries SWITCH [TABLE]
    $ Example: ovs-p4ctl dump-entries br0 ipv4_host

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    This is an optional field for get/dump command.

6. Set a default entry for a table into the forwarding pipeline ::

    $ ovs-p4ctl set-default-entry SWITCH TABLE ACTION
    $ Example: ovs-p4ctl set-default-entry br0 ipv4_host "send(10)"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``ACTION``: Refers to action parameter of the above mentioned TABLE
    action_name(value)

7. Get a default entry for a table from the forwarding pipeline [Future Implementation]::

    $ ovs-p4ctl get-default-entry SWITCH TABLE
    $ Example: ovs-p4ctl get-default-entry br0 ipv4_host

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.

8. Add action profile member entry for an action selector table ::

    $ ovs-p4ctl add-action-profile-member SWITCH ACTION_PROFILE FLOW
    $ Example: ovs-p4ctl add-action-profile-member br0 ingress.as_sl3
               "action=ingress.send(0),member_id=1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``ACTION_PROFILE``: Refers to action profile name from the p4 file.
    ``FLOW``: Refers to action of the table for which the mentioned
    ACTION_PROFILE is referring to.
    Format "action=action_name(value),member_id=<number>"

9. Delete action profile member entry from an action selector table ::

    $ ovs-p4ctl delete-action-profile-member SWITCH ACTION_PROFILE FLOW
    $ Example: ovs-p4ctl delete-action-profile-member br0 ingress.as_sl3
               "member_id=1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``ACTION_PROFILE``: Refers to action profile name from the p4 file.
    ``FLOW``: Refers to the member ID which was earlier configured via add
    action profile member. Format "member_id=<number>"

10. Get action profile member details for an action selector table ::

    $ ovs-p4ctl get-action-profile-member SWITCH ACTION_PROFILE FLOW
    $ Example: ovs-p4ctl get-action-profile-member br0 ingress.as_sl3 "member_id=1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``ACTION_PROFILE``: Refers to action profile name from the p4 file.
    ``FLOW``: Refers to the member ID which was earlier configured via add
    action profile member. Format "member_id=<number>"

11. Add action profile group entry for an action selector table ::

    $ ovs-p4ctl add-action-profile-group SWITCH ACTION_PROFILE FLOW
    $ Example: ovs-p4ctl add-action-profile-group br0 ingress.as_sl3 "group_id=1,reference_members=(1),max_size=128"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``ACTION_PROFILE``: Refers to action profile name from the p4 file.
    ``FLOW``: Maps group with list of members.
    Format "group_id=<group number>,reference_members=<member1,member2,..>,max_size=<maxsize of members this group can have>"

12. Delete action profile group entry from an action selector table ::

    $ ovs-p4ctl delete-action-profile-group SWITCH ACTION_PROFILE FLOW
    $ Example: ovs-p4ctl delete-action-profile-group br0 ingress.as_sl3 "group_id=1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``ACTION_PROFILE``: Refers to action profile name from the p4 file.
    ``FLOW``: Refers to the group ID which was earlier configured via add
    action profile group. Format ""group_id=<number>"

13. Get action profile group details for an action selector table ::

    $ ovs-p4ctl get-action-profile-group SWITCH ACTION_PROFILE FLOW
    $ Example: ovs-p4ctl get-action-profile-group br0 ingress.as_sl3 "group_id=1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``ACTION_PROFILE``: Refers to action profile name from the p4 file.
    ``FLOW``: Refers to the group ID which was earlier configured via add
    action profile group. Format "group_id=<number>"

14. Rule to program ternary match_type ::

    $ ovs-p4ctl add-entry SWITCH TABLE FLOW
    $ Example: ovs-p4ctl add-entry br0 filter "src_ip=192.168.15.0/255.255.255.0,priority=100,action=drop"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``FLOW``: Refers to parameters for a the above mentioned TABLE. Since we
    are programming a match_type ternary we expect user to provide priority
    as well. 'priority' is a case sensitivity field expected from user.
    Mask for ternary or WCM match field is expected in x.x.x.x format for IPv4
    or an integer value or a hexa-decimal values.
    match_filed_key=value,priority=value,action=action_name(value)

15. Rule to delete ternary match_type ::

    $ ovs-p4ctl del-entry SWITCH TABLE KEY
    $ Example: ovs-p4ctl del-entry br0 ingress.ipv4_wcm "hdr.ipv4.dst_addr=192.168.1.0/255.255.255.0,priority=10"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``KEY``: Refers to match_filed_key parameters which are programmed for
    the above mentioned TABLE. Since match_type is ternary, we expect user to
    provide previously configured priority as well. 'priority' is a case
    sensitivity field expected from user. Mask for ternary or WCM match field
    is expected in x.x.x.x format for IPv4 or an integer value or a
    hexa-decimal value. Format "match_filed_key=value,priority=value"

16. Get indirect counter entry value ::

    $ ovs-p4ctl get-counter SWITCH COUNTER_TABLE COUNTER_FLOW
    $ Example: ovs-p4ctl get-counter br0 ingress.ipv4_host_counter "counter_id=308545543,index=1"
    $ Example: ovs-p4ctl get-counter br0 ingress.ipv4_host_counter "counter_id=0,index=1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``COUNTER_TABLE``: Refers to counter table entry from the p4 file.
    ``COUNTER_FLOW``: Refers to the counter ID (generated ID by p4c, refer to bfrt.json file)
    and the counter table index. Format "counter_id=<number>,index=<number>". A counter_id=0
    will display value for all counters added up. For index=UNSET, all cells for specified
    counter_id will be displayed.

16. Reset indirect counter entry value ::

    $ ovs-p4ctl reset-counter SWITCH COUNTER_TABLE COUNTER_FLOW
    $ Example: ovs-p4ctl reset-counter br0 ingress.ipv4_host_counter "counter_id=308545543,index=1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``COUNTER_TABLE``: Refers to counter table entry from the p4 file.
    ``COUNTER_FLOW``: Refers to the counter ID (generated ID by p4c, refer to bfrt.json file)
    and the counter table index. Format "counter_id=<number>,index=<number>"

gnmi_cli executable
-------------------

gnmi_cli is an executable generated when OvS is built and this executable
is an gRPC client which connects to gRPC server running in OvS for enabling
gNMI/openconfig capabilities.

Each CLI command connects to gRPC ports opened by server, send a protobuf based
message. Refer to gnmi.proto and gnmi_ext.proto for more details on type of
messages and services that are available for a gNMI client.

Each CLI format should be inline with the YANG parser available in server which
is a tree based hierarchy. In P4 based OvS, we are having Interfaces as
root-node and followed by device type. Each device can hold muiltiple
ports, where port-name is acting as a KEY.
For Each port, we can have config parameters and state parameters.
We can execute SET command for config params and GET command for the
previously configured CONFIG params.

1) Set atrributes for a vhost port::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:virtual-device,name:net_vhost0,device-type:VIRTIO_NET"
    gnmi-cli set "device:virtual-device,name:net_vhost0,port-type:LINK"
    gnmi-cli set "device:virtual-device,name:net_vhost0,host:host1,
                  device-type:VIRTIO_NET,queues:1,
                  socket-path:/tmp/vhost-user-0,port-type:LINK"
    gnmi-cli set "device:virtual-device,name:net_vhost0,host:host1,
                  device-type:VIRTIO_NET,queues:1,
                  pipeline-name:pipe,mempool-name:MEMPOOL0,mtu:2000,
                  socket-path:/tmp/vhost-user-0,packet-dir:host,port-type:LINK"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    host: can be any string.
    queues: number of queues required by backend.
    socket-path: socket path required by backend.
    port-type: can take values defined in common.proto. Supported value is LINK.
    device-type: can take values defined in common.proto. Supported values is
    VIRTIO_NET.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`
    mtu: this is a non-mandatory parameter, if not specifically configured
    by the user it is considered as value `1500`

2) Set atrributes for a vhost port and a control port::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:virtual-device,name:net_vhost0,host:host1,
                  device-type:VIRTIO_NET,queues:1,
                  pipeline-name:pipe,mempool-name:MEMPOOL0,control-port:TAP2,
                  socket-path:/tmp/vhost-user-0,packet-dir:host,port-type:LINK"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    host: can be any string.
    queues: number of queues required by backend.
    socket-path: socket path required by backend.
    port-type: can take values defined in common.proto. Supported value is LINK.
    device-type: can take values defined in common.proto. Supported values is
    VIRTIO_NET.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`
    mtu: this is a non-mandatory parameter, if not specifically configured
    by the user it is considered as value `1500`
    control-port: TAP port that need to be created for control packets.
    packet-dir: this is a non-mandatory parameter. It accepts 2 values
    `host` or `network`(case insensitive). The value 'host' indicates that
    traffic via this port will be within the host. The value 'network' indicates
    this port will be able to send/receive traffic to/from network. If not
    specifically configured by the user, default value is `host`

3) Get atrributes for a port::

    $ gnmi-cli get PARAMS
    $ Example:
    gnmi-cli get "device:virtual-device,name:net_vhost0,device-type"
    gnmi-cli get "device:virtual-device,name:net_vhost0,port-type"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... Pass
    the key name for whose value need to be fetched. Each get can take ONLY
    one key, and fetches value for that previously configured KEY.

.. important::
  If grpc connection to server fails, export GRPC_TRACE=all and check if any
  proxy errors are encountered. If Yes, then configure localhost as an entry in
  NO_PROXY environmental variable (append localhost if NO_PROXY is already
  configured).

  Example: export NO_PROXY=localhost,127.0.0.1

4) VIRTIO-NET Device Hot plug for DPDK Target::

    This feature will allow the user to hotplug the vhost-user ports to the running VM.
    To hotplug the vhost-user port to qemu based VM, add monitor option when instantiating
    qemu based VM and specify the telnet port and ip for qemu monitor socket.
    Example of qemu command:
      qemu-system-x86_64 -enable-kvm -smp 4 -m 1024M \
      -boot c -cpu host -enable-kvm -nographic \
      -L /root/pc-bios -name VM1_TAP_DEV \
      -hda /root/VM/vm1.qcow2 \
      -object memory-backend-file,id=mem,size=1024M,mem-path=/dev/hugepages,share=on \
      -mem-prealloc \
      -numa node,memdev=mem \
      -monitor telnet::6555,server,nowait \
      -serial telnet::6551,server &

    Boot up the VM and login to console using telnet port (in the above example port 6551).
    This VM will have 1 default port. To hotplug the vhost-user port, issue the following
    gnmi-cli command:

      $ gnmi-cli set PARAMS
      $ Command to hotplug add the port. Example:
      $ gnmi-cli set "device:virtual-device,name:net_vhost0,hotplug:add,
                      qemu-socket-ip:127.0.0.1,qemu-socket-port:6555,
                      qemu-vm-mac:00:e8:ca:11:aa:01,qemu-vm-netdev-id:netdev0,
                      qemu-vm-chardev-id:char1,native-socket-path:/tmp/intf/vhost-user-0,
                      qemu-vm-device-id:dev0"
      $ Command to hotplug delete the port. Example:
      $ gnmi-cli set "device:virtual-device,name:net_vhost0,hotplug:del"

.. note::

   ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    hotplug: Specify if the device needs to be hotplugged (add/ADD for hotplug
    add, del/DEL for hotplug delete)
    qemu-socket-ip: Specify IP of the host where qemu monitor socket resides.
    qemu-socket-port: Specify qemu monitor socket port
    qemu-vm_mac: Specify MAC address for port hotplugged to qemu VM
    qemu-vm_netdev-id: Specify netdev ID for port hotplugged to qemu VM
    qemu-vm_chardev-id: Specify chardev ID for port hotplugged to qemu VM
    native-socket-path: Specify the native path for vhost-user socket on host
    qemu-vm-device-id: Specify device ID for port hotplugged to qemu VM

   Port can be hotplug added once and hotplug deleted once. Re-adding or 
   deleting the port is not supported in older qemu versions due to qemu bug
   reporting false duplicate IDs. This bug is fixed in qemu version 6.1.0 and
   re-adding and re-deleting the hotplug port is supported from qemu version
   6.1.0

5) Set atrributes for link ports::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:physical-device,name:PORT1,pci-bdf:0000:00:05.0,
                  port-type:link"
    gnmi-cli set "device:physical-device,name:PORT0,pipeline-name:pipe,
                  mempool-name:MEMPOOL0,mtu:1000,pci-bdf:0000:00:04.0,
                  packet-dir:network,port-type:link"

.. note::

    ``PARAMS``: These params are key:value pairs. Here physical-device is a
    sub-node which holds multiple ports like PORT0, PORT1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    pci-bdf: Should specify PCI BDF value
    port-type: can take values defined in common.proto. Supported value is LINK.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`
    mtu: this is a non-mandatory parameter, if not specifically configured
    by the user it is considered as value `1500`
    packet-dir: this is a non-mandatory parameter. It accepts 2 values
    `host` or `network`(case insensitive). The value 'host' indicates that
    traffic via this port will be within the host. The value 'network' indicates
    this port will be able to send/receive traffic to/from network. If not
    specifically configured by the user, default value is `host`


6) Set atrributes for link ports and a control port::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:physical-device,name:PORT2,pipeline-name:pipe,
                  mempool-name:MEMPOOL0,control-port:TAP1,mtu:1000,
                  pci-bdf:0000:00:06.0,packet-dir:network,port-type:link"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here physical-device is a
    sub-node which holds multiple ports like PORT0, PORT1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    pci-bdf: Should specify PCI BDF value
    port-type: can take values defined in common.proto. Supported value is LINK.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`
    mtu: this is a non-mandatory parameter, if not specifically configured
    by the user it is considered as value `1500`
    control-port: TAP port that need to be created for control packets.
    packet-dir: this is a non-mandatory parameter. It accepts 2 values
    `host` or `network`(case insensitive). The value 'host' indicates that
    traffic via this port will be within the host. The value 'network' indicates
    this port will be able to send/receive traffic to/from network. If not
    specifically configured by the user, default value is `host`

7) Set atrributes for TAP ports::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:virtual-device,name:TAP1,mtu:1500,port-type:TAP"
    gnmi-cli set "device:virtual-device,name:TAP0,pipeline-name:pipe,
                  packet-dir:host,mempool-name:MEMPOOL0,mtu:1500,port-type:TAP"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like TAP0, TAP1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    port-type: can take values defined in common.proto. Supported value is
    TAP.
    mtu: this is a mandatory parameter, to be specified by user.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`
    packet-dir: this is a non-mandatory parameter. It accepts 2 values
    `host` or `network`(case insensitive). The value 'host' indicates that
    traffic via this port will be within the host. The value 'network' indicates
    this port will be able to send/receive traffic to/from network. If not
    specifically configured by the user, default value is `host`

8) Set atrributes for TAP ports and a control port::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:virtual-device,name:TAP2,mtu:1000,
                  pipeline-name:pipe,mempool-name:MEMPOOL0,control-port:TAP31,
                  packet-dir:host,port-type:TAP"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like TAP0, TAP1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    port-type: can take values defined in common.proto. Supported value is LINK.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`
    mtu: this is a non-mandatory parameter, if not specifically configured
    by the user it is considered as value `1500`
    control-port: TAP port that need to be created for control packets.
    packet-dir: this is a non-mandatory parameter. It accepts 2 values
    `host` or `network`(case insensitive). The value 'host' indicates that
    traffic via this port will be within the host. The value 'network' indicates
    this port will be able to send/receive traffic to/from network. If not
    specifically configured by the user, default value is `host`

9) Get attributes for Pipelines Configuration::

    $ gnmi-cli get PARAMS
    $ Example:
    gnmi-cli get "device:virtual-device,name:net_vhost0,tdi-portin-id"
    gnmi-cli get "device:virtual-device,name:net_vhost0,tdi-portout-id"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... Pass
    the key name for whose value need to be fetched. Each get can take ONLY
    one key, and fetches value for that previously configured KEY.
    tdi-portin-id: Port ID for Pipeline in Input Direction
    tdi-portin-id: Port ID for Pipeline in Output Direction

Limitations/Note
----------------

    a) All the optional parameters(like mempool name , pipeline name, etc)
    should be provided before the mandatory parameters (eg. port-type). The CLI
    considers the parameters only till the last mandatory parameter; After the
    last Mandatory parameter, rest all the optional parameters are ignored.

    b) DPDK target doesn't support packet categorization for the purpose of
    statistics. Hence all packets are reported under the same category as 
    'unicast packets/bytes', and the rest of the other fields are displayed as zero.

    c) When tunnel is enabled, it is expected to have total size of the tunnel
    packet less than or equal to 1514 Bytes. To match this size, user need to
    adjust overlay network interface MTU size not more than 1450 Bytes.

    d) For any udp/tcp packets from overlay network, if checksum issues are
    noticed on interfaces which are of type VIRTIO-NET, it is recommended to
    disable checksum using below command.
    $ ethtool --offload <netdev-name> rx off tx off

    d) pna_tcp_connection_tracking demonstrates the PNA add_on_miss feature and
    flow aging for auto learn flows. It supports basic TCP CT state machine.


Logs and Analysis
------------------

    a) If the user sees any ERROR logs while running 'ovs-p4ctl' or 'gnmi-cli' commands,
    more details can be found in either 'ovs-vswitchd.log' or 'p4_driver.log' files.

    b) ovs-vswitchd.log maintains the running logs and errors from the OVS submodules.
    This file path is given as a '--log-file' parameter, while the 'ovs-vswitchd' process is run.
    Ex:- ovs-vswitchd unix:$RUN_OVS/var/run/openvswitch/db.sock --log-file=/tmp/ovs-vswitchd.log

    c) p4_driver.log maintains the running logs and errors from the P4-SDE and target submodule.
    This file is usually created in the working directory, from where run_ovs.sh script is run.
