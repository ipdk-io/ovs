diff --git a/stratum/glue/status/status_macros.h b/stratum/glue/status/status_macros.h
index cf8723d2..695a0365 100644
--- a/stratum/glue/status/status_macros.h
+++ b/stratum/glue/status/status_macros.h
@@ -416,6 +416,14 @@ class UtilStatusConvertibleToBool {
     }                                                                        \
   } while (0)
 
+#define RETURN_IF_NULL(expr)                                                 \
+  do {                                                                       \
+    if (expr == NULL) {                                                      \
+      return MAKE_ERROR()                                                    \
+             << "'" << #expr << "' Must be non NULL ";                       \
+    }                                                                        \
+  } while (0)
+
 // This is like RETURN_IF_ERROR, but instead of propagating the existing error
 // Status, it constructs a new Status and can append additional messages.
 //
diff --git a/stratum/hal/bin/barefoot/bf_pipeline_builder.cc b/stratum/hal/bin/barefoot/bf_pipeline_builder.cc
index cf601ba3..983a331a 100644
--- a/stratum/hal/bin/barefoot/bf_pipeline_builder.cc
+++ b/stratum/hal/bin/barefoot/bf_pipeline_builder.cc
@@ -111,9 +111,9 @@ p4_device_config field of the P4Runtime SetForwardingPipelineConfig message.
     const auto& program = device["p4_programs"][0];
     bf_config.set_p4_name(program["program-name"]);
     LOG(INFO) << "Found P4 program: " << bf_config.p4_name();
-    std::string bfrt_content;
-    RETURN_IF_ERROR(ReadFileToString(program["bfrt-config"], &bfrt_content));
-    bf_config.set_bfruntime_info(bfrt_content);
+    std::string tdirt_content;
+    RETURN_IF_ERROR(ReadFileToString(program["bfrt-config"], &tdirt_content));
+    bf_config.set_bfruntime_info(tdirt_content);
     for (const auto& pipeline : program["p4_pipelines"]) {
       auto profile = bf_config.add_profiles();
       profile->set_profile_name(pipeline["p4_pipeline_name"]);
diff --git a/stratum/hal/bin/barefoot/main.cc b/stratum/hal/bin/barefoot/main.cc
index 2b292a36..65ec5216 100644
--- a/stratum/hal/bin/barefoot/main.cc
+++ b/stratum/hal/bin/barefoot/main.cc
@@ -100,20 +100,20 @@ void registerDeviceMgrLogger() {
   std::map<int, pi::PINode*> device_id_to_pi_node = {
       {device_id, pi_node.get()},
   };
-  auto bf_sde_wrapper = BfSdeWrapper::CreateSingleton();
-  RETURN_IF_ERROR(bf_sde_wrapper->InitializeSde(
+  auto tdi_sde_wrapper = TdiSdeWrapper::CreateSingleton();
+  RETURN_IF_ERROR(tdi_sde_wrapper->InitializeSde(
       FLAGS_bf_sde_install, FLAGS_bf_switchd_cfg, FLAGS_bf_switchd_background));
   ASSIGN_OR_RETURN(bool is_sw_model,
-                   bf_sde_wrapper->IsSoftwareModel(device_id));
+                   tdi_sde_wrapper->IsSoftwareModel(device_id));
   const OperationMode mode =
       is_sw_model ? OPERATION_MODE_SIM : OPERATION_MODE_STANDALONE;
   VLOG(1) << "Detected is_sw_model: " << is_sw_model;
-  VLOG(1) << "SDE version: " << bf_sde_wrapper->GetSdeVersion();
-  auto bf_chassis_manager =
-      BfChassisManager::CreateInstance(mode, phal_impl, bf_sde_wrapper);
+  VLOG(1) << "SDE version: " << tdi_sde_wrapper->GetSdeVersion();
+  auto tdi_chassis_manager =
+      TdiChassisManager::CreateInstance(mode, phal_impl, tdi_sde_wrapper);
   auto bf_switch =
-      BfSwitch::CreateInstance(phal_impl, bf_chassis_manager.get(),
-                               bf_sde_wrapper, device_id_to_pi_node);
+      BfSwitch::CreateInstance(phal_impl, tdi_chassis_manager.get(),
+                               tdi_sde_wrapper, device_id_to_pi_node);
 
   // Create the 'Hal' class instance.
   auto auth_policy_checker = AuthPolicyChecker::CreateInstance();
diff --git a/stratum/hal/bin/barefoot/main_bfrt.cc b/stratum/hal/bin/barefoot/main_bfrt.cc
index b9bfad31..055b7261 100644
--- a/stratum/hal/bin/barefoot/main_bfrt.cc
+++ b/stratum/hal/bin/barefoot/main_bfrt.cc
@@ -39,31 +39,31 @@ namespace barefoot {
   // components with "device_id" instead of "node_id".
   int device_id = 0;
 
-  auto bf_sde_wrapper = BfSdeWrapper::CreateSingleton();
-  RETURN_IF_ERROR(bf_sde_wrapper->InitializeSde(
+  auto tdi_sde_wrapper = TdiSdeWrapper::CreateSingleton();
+  RETURN_IF_ERROR(tdi_sde_wrapper->InitializeSde(
       FLAGS_bf_sde_install, FLAGS_bf_switchd_cfg, FLAGS_bf_switchd_background));
   ASSIGN_OR_RETURN(bool is_sw_model,
-                   bf_sde_wrapper->IsSoftwareModel(device_id));
+                   tdi_sde_wrapper->IsSoftwareModel(device_id));
   const OperationMode mode =
       is_sw_model ? OPERATION_MODE_SIM : OPERATION_MODE_STANDALONE;
   VLOG(1) << "Detected is_sw_model: " << is_sw_model;
-  VLOG(1) << "SDE version: " << bf_sde_wrapper->GetSdeVersion();
-  VLOG(1) << "Switch SKU: " << bf_sde_wrapper->GetBfChipType(device_id);
+  VLOG(1) << "SDE version: " << tdi_sde_wrapper->GetSdeVersion();
+  VLOG(1) << "Switch SKU: " << tdi_sde_wrapper->GetBfChipType(device_id);
 
-  auto bfrt_table_manager =
-      BfrtTableManager::CreateInstance(mode, bf_sde_wrapper, device_id);
-  auto bfrt_action_profile_manager =
-      BfrtActionProfileManager::CreateInstance(bf_sde_wrapper, device_id);
-  auto bfrt_packetio_manger =
-      BfrtPacketioManager::CreateInstance(bf_sde_wrapper, device_id);
-  auto bfrt_pre_manager =
-      BfrtPreManager::CreateInstance(bf_sde_wrapper, device_id);
-  auto bfrt_counter_manager =
-      BfrtCounterManager::CreateInstance(bf_sde_wrapper, device_id);
-  auto bfrt_node = BfrtNode::CreateInstance(
-      bfrt_table_manager.get(), bfrt_action_profile_manager.get(),
-      bfrt_packetio_manger.get(), bfrt_pre_manager.get(),
-      bfrt_counter_manager.get(), bf_sde_wrapper, device_id);
+  auto tdi_table_manager =
+      TdiTableManager::CreateInstance(mode, tdi_sde_wrapper, device_id);
+  auto tdi_action_profile_manager =
+      TdiActionProfileManager::CreateInstance(tdi_sde_wrapper, device_id);
+  auto tdirt_packetio_manger =
+      TdiPacketioManager::CreateInstance(tdi_sde_wrapper, device_id);
+  auto tdi_pre_manager =
+      TdiPreManager::CreateInstance(tdi_sde_wrapper, device_id);
+  auto tdi_counter_manager =
+      TdiCounterManager::CreateInstance(tdi_sde_wrapper, device_id);
+  auto tdi_node = TdiNode::CreateInstance(
+      tdi_table_manager.get(), tdi_action_profile_manager.get(),
+      tdirt_packetio_manger.get(), tdi_pre_manager.get(),
+      tdi_counter_manager.get(), tdi_sde_wrapper, device_id);
   PhalInterface* phal_impl;
   if (FLAGS_bf_sim) {
     phal_impl = PhalSim::CreateSingleton();
@@ -71,14 +71,14 @@ namespace barefoot {
     phal_impl = phal::Phal::CreateSingleton();
   }
 
-  std::map<int, BfrtNode*> device_id_to_bfrt_node = {
-      {device_id, bfrt_node.get()},
+  std::map<int, TdiNode*> device_id_to_tdi_node = {
+      {device_id, tdi_node.get()},
   };
-  auto bf_chassis_manager =
-      BfChassisManager::CreateInstance(mode, phal_impl, bf_sde_wrapper);
+  auto tdi_chassis_manager =
+      TdiChassisManager::CreateInstance(mode, phal_impl, tdi_sde_wrapper);
   auto bf_switch =
-      BfrtSwitch::CreateInstance(phal_impl, bf_chassis_manager.get(),
-                                 bf_sde_wrapper, device_id_to_bfrt_node);
+      TdirtSwitch::CreateInstance(phal_impl, tdi_chassis_manager.get(),
+                                 tdi_sde_wrapper, device_id_to_tdi_node);
 
   // Create the 'Hal' class instance.
   auto auth_policy_checker = AuthPolicyChecker::CreateInstance();
diff --git a/stratum/hal/bin/barefoot/tofino_skip_p4_no_bsp.conf b/stratum/hal/bin/barefoot/tofino_skip_p4_no_bsp.conf
index e1f4338e..23e1d575 100644
--- a/stratum/hal/bin/barefoot/tofino_skip_p4_no_bsp.conf
+++ b/stratum/hal/bin/barefoot/tofino_skip_p4_no_bsp.conf
@@ -1,31 +1,52 @@
 {
-    "instance": 0,
     "chip_list": [
         {
-            "chip_family": "Tofino",
+            "id": "asic-0",
+            "chip_family": "dpdk",
+            "instance": 0,
             "pcie_sysfs_prefix": "/sys/devices/pci0000:00/0000:00:03.0/0000:05:00.0",
+            "pcie_domain": 0,
             "pcie_bus": 5,
+            "pcie_fn": 0,
             "pcie_dev": 0,
             "pcie_int_mode": 1,
-            "pcie_domain": 0,
-            "instance": 0,
-            "sds_fw_path": "share/tofino_sds_fw/avago/firmware",
-            "pcie_fn": 0,
-            "id": "asic-0"
+            "sds_fw_path": "share/tofino_sds_fw/avago/firmware"
         }
     ],
-    "id": "dummy.csv",
-    "p4_program_list": [
+    "instance": 0,
+    "p4_devices": [
         {
-            "pd-thrift": "",
-            "program-name": "dummy",
-            "tofino-bin": "",
-            "instance": 0,
-            "pd": "",
-            "board-port-map": "share/port_map.json",
-            "path": "dummy",
-            "id": "pgm-0",
-            "table-config": ""
+            "device-id": 0,
+            "mempools": [
+                {
+                    "name": "MEMPOOL0",
+                    "buffer_size": 2304,
+                    "pool_size": 4096,
+                    "cache_size": 256,
+                    "numa_node": 0
+                }
+            ],
+            "eal-args": "dummy -n 4 -c 3",
+            "p4_programs": [
+                {
+                    "program-name": "dummy",
+                    "cpu_numa_node": "0",
+                    "p4_pipelines": [
+                        {
+                            "p4_pipeline_name": "pipe",
+                            "core_id": 1,
+                            "numa_node": 0,
+                            "pipe_scope": [
+                                0,
+                                1,
+                                2,
+                                3
+                            ],
+                            "path": "share/tofinopd/simple_l2l3_lpm"
+                        }
+                    ]
+                }
+            ]
         }
     ]
 }
diff --git a/stratum/hal/lib/barefoot/bf.proto b/stratum/hal/lib/barefoot/bf.proto
index c0b8103c..6d319e38 100644
--- a/stratum/hal/lib/barefoot/bf.proto
+++ b/stratum/hal/lib/barefoot/bf.proto
@@ -26,7 +26,7 @@ message BfPipelineConfig {
 
 // Internal storage format that contains all the information of a P4 program
 // that can be loaded into the SDE.
-message BfrtDeviceConfig {
+message TdirtDeviceConfig {
   message P4Program {
     message P4Pipeline {
       string name = 1;           // For display purposes only.
diff --git a/stratum/hal/lib/barefoot/bf_chassis_manager.cc b/stratum/hal/lib/barefoot/bf_chassis_manager.cc
index 195356b5..c1185aab 100644
--- a/stratum/hal/lib/barefoot/bf_chassis_manager.cc
+++ b/stratum/hal/lib/barefoot/bf_chassis_manager.cc
@@ -28,19 +28,19 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-using PortStatusEvent = BfSdeInterface::PortStatusEvent;
+using PortStatusEvent = TdiSdeInterface::PortStatusEvent;
 using TransceiverEvent = PhalInterface::TransceiverEvent;
 
 ABSL_CONST_INIT absl::Mutex chassis_lock(absl::kConstInit);
 
 /* static */
-constexpr int BfChassisManager::kMaxPortStatusEventDepth;
+constexpr int TdiChassisManager::kMaxPortStatusEventDepth;
 /* static */
-constexpr int BfChassisManager::kMaxXcvrEventDepth;
+constexpr int TdiChassisManager::kMaxXcvrEventDepth;
 
-BfChassisManager::BfChassisManager(OperationMode mode,
+TdiChassisManager::TdiChassisManager(OperationMode mode,
                                    PhalInterface* phal_interface,
-                                   BfSdeInterface* bf_sde_interface)
+                                   TdiSdeInterface* tdi_sde_interface)
     : mode_(mode),
       initialized_(false),
       port_status_event_channel_(nullptr),
@@ -58,9 +58,9 @@ BfChassisManager::BfChassisManager(OperationMode mode,
       node_id_to_deflect_on_drop_config_(),
       xcvr_port_key_to_xcvr_state_(),
       phal_interface_(ABSL_DIE_IF_NULL(phal_interface)),
-      bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)) {}
+      tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)) {}
 
-BfChassisManager::BfChassisManager()
+TdiChassisManager::TdiChassisManager()
     : mode_(OPERATION_MODE_STANDALONE),
       initialized_(false),
       port_status_event_channel_(nullptr),
@@ -78,11 +78,11 @@ BfChassisManager::BfChassisManager()
       node_id_to_deflect_on_drop_config_(),
       xcvr_port_key_to_xcvr_state_(),
       phal_interface_(nullptr),
-      bf_sde_interface_(nullptr) {}
+      tdi_sde_interface_(nullptr) {}
 
-BfChassisManager::~BfChassisManager() = default;
+TdiChassisManager::~TdiChassisManager() = default;
 
-::util::Status BfChassisManager::AddPortHelper(
+::util::Status TdiChassisManager::AddPortHelper(
     uint64 node_id, int unit, uint32 sdk_port_id,
     const SingletonPort& singleton_port /* desired config */,
     /* out */ PortConfig* config /* new config */) {
@@ -104,7 +104,7 @@ BfChassisManager::~BfChassisManager() = default;
 
   LOG(INFO) << "Adding port " << port_id << " in node " << node_id
             << " (SDK Port " << sdk_port_id << ").";
-  RETURN_IF_ERROR(bf_sde_interface_->AddPort(
+  RETURN_IF_ERROR(tdi_sde_interface_->AddPort(
       unit, sdk_port_id, singleton_port.speed_bps(), config_params.fec_mode()));
   config->speed_bps = singleton_port.speed_bps();
   config->admin_state = ADMIN_STATE_DISABLED;
@@ -112,11 +112,11 @@ BfChassisManager::~BfChassisManager() = default;
 
   if (config_params.mtu() != 0) {
     RETURN_IF_ERROR(
-        bf_sde_interface_->SetPortMtu(unit, sdk_port_id, config_params.mtu()));
+        tdi_sde_interface_->SetPortMtu(unit, sdk_port_id, config_params.mtu()));
   }
   config->mtu = config_params.mtu();
   if (config_params.autoneg() != TRI_STATE_UNKNOWN) {
-    RETURN_IF_ERROR(bf_sde_interface_->SetPortAutonegPolicy(
+    RETURN_IF_ERROR(tdi_sde_interface_->SetPortAutonegPolicy(
         unit, sdk_port_id, config_params.autoneg()));
   }
   config->autoneg = config_params.autoneg();
@@ -125,7 +125,7 @@ BfChassisManager::~BfChassisManager() = default;
     LOG(INFO) << "Setting port " << port_id << " to loopback mode "
               << config_params.loopback_mode() << " (SDK Port " << sdk_port_id
               << ").";
-    RETURN_IF_ERROR(bf_sde_interface_->SetPortLoopbackMode(
+    RETURN_IF_ERROR(tdi_sde_interface_->SetPortLoopbackMode(
         unit, sdk_port_id, config_params.loopback_mode()));
   }
   config->loopback_mode = config_params.loopback_mode();
@@ -133,17 +133,17 @@ BfChassisManager::~BfChassisManager() = default;
   if (config_params.admin_state() == ADMIN_STATE_ENABLED) {
     LOG(INFO) << "Enabling port " << port_id << " in node " << node_id
               << " (SDK Port " << sdk_port_id << ").";
-    RETURN_IF_ERROR(bf_sde_interface_->EnablePort(unit, sdk_port_id));
+    RETURN_IF_ERROR(tdi_sde_interface_->EnablePort(unit, sdk_port_id));
     config->admin_state = ADMIN_STATE_ENABLED;
   }
 
   RETURN_IF_ERROR(
-      bf_sde_interface_->EnablePortShaping(unit, sdk_port_id, TRI_STATE_FALSE));
+      tdi_sde_interface_->EnablePortShaping(unit, sdk_port_id, TRI_STATE_FALSE));
 
   return ::util::OkStatus();
 }
 
-::util::Status BfChassisManager::UpdatePortHelper(
+::util::Status TdiChassisManager::UpdatePortHelper(
     uint64 node_id, int unit, uint32 sdk_port_id,
     const SingletonPort& singleton_port /* desired config */,
     const PortConfig& config_old /* current config */,
@@ -152,7 +152,7 @@ BfChassisManager::~BfChassisManager() = default;
   // SingletonPort ID is the SDN/Stratum port ID
   uint32 port_id = singleton_port.id();
 
-  if (!bf_sde_interface_->IsValidPort(unit, sdk_port_id)) {
+  if (!tdi_sde_interface_->IsValidPort(unit, sdk_port_id)) {
     config->admin_state = ADMIN_STATE_UNKNOWN;
     config->speed_bps.reset();
     config->fec_mode.reset();
@@ -163,8 +163,8 @@ BfChassisManager::~BfChassisManager() = default;
 
   const auto& config_params = singleton_port.config_params();
   if (singleton_port.speed_bps() != config_old.speed_bps) {
-    RETURN_IF_ERROR(bf_sde_interface_->DisablePort(unit, sdk_port_id));
-    RETURN_IF_ERROR(bf_sde_interface_->DeletePort(unit, sdk_port_id));
+    RETURN_IF_ERROR(tdi_sde_interface_->DisablePort(unit, sdk_port_id));
+    RETURN_IF_ERROR(tdi_sde_interface_->DeletePort(unit, sdk_port_id));
 
     ::util::Status status =
         AddPortHelper(node_id, unit, sdk_port_id, singleton_port, config);
@@ -218,7 +218,7 @@ BfChassisManager::~BfChassisManager() = default;
             << " (SDK Port " << sdk_port_id << ").";
     config->mtu.reset();
     RETURN_IF_ERROR(
-        bf_sde_interface_->SetPortMtu(unit, sdk_port_id, config_params.mtu()));
+        tdi_sde_interface_->SetPortMtu(unit, sdk_port_id, config_params.mtu()));
     config->mtu = config_params.mtu();
     config_changed = true;
   }
@@ -227,14 +227,14 @@ BfChassisManager::~BfChassisManager() = default;
             << " changed"
             << " (SDK Port " << sdk_port_id << ").";
     config->autoneg.reset();
-    RETURN_IF_ERROR(bf_sde_interface_->SetPortAutonegPolicy(
+    RETURN_IF_ERROR(tdi_sde_interface_->SetPortAutonegPolicy(
         unit, sdk_port_id, config_params.autoneg()));
     config->autoneg = config_params.autoneg();
     config_changed = true;
   }
   if (config_params.loopback_mode() != config_old.loopback_mode) {
     config->loopback_mode.reset();
-    RETURN_IF_ERROR(bf_sde_interface_->SetPortLoopbackMode(
+    RETURN_IF_ERROR(tdi_sde_interface_->SetPortLoopbackMode(
         unit, sdk_port_id, config_params.loopback_mode()));
     config->loopback_mode = config_params.loopback_mode();
     config_changed = true;
@@ -265,20 +265,20 @@ BfChassisManager::~BfChassisManager() = default;
   if (need_disable) {
     LOG(INFO) << "Disabling port " << port_id << " in node " << node_id
               << " (SDK Port " << sdk_port_id << ").";
-    RETURN_IF_ERROR(bf_sde_interface_->DisablePort(unit, sdk_port_id));
+    RETURN_IF_ERROR(tdi_sde_interface_->DisablePort(unit, sdk_port_id));
     config->admin_state = ADMIN_STATE_DISABLED;
   }
   if (need_enable) {
     LOG(INFO) << "Enabling port " << port_id << " in node " << node_id
               << " (SDK Port " << sdk_port_id << ").";
-    RETURN_IF_ERROR(bf_sde_interface_->EnablePort(unit, sdk_port_id));
+    RETURN_IF_ERROR(tdi_sde_interface_->EnablePort(unit, sdk_port_id));
     config->admin_state = ADMIN_STATE_ENABLED;
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfChassisManager::PushChassisConfig(
+::util::Status TdiChassisManager::PushChassisConfig(
     const ChassisConfig& config) {
   if (!initialized_) RETURN_IF_ERROR(RegisterEventWriters());
 
@@ -328,7 +328,7 @@ BfChassisManager::~BfChassisManager() = default;
         singleton_port_key;
 
     // Translate the logical SDN port to SDK port (BF device port ID)
-    ASSIGN_OR_RETURN(uint32 sdk_port, bf_sde_interface_->GetPortIdFromPortKey(
+    ASSIGN_OR_RETURN(uint32 sdk_port, tdi_sde_interface_->GetPortIdFromPortKey(
                                           *unit, singleton_port_key));
     node_id_to_port_id_to_sdk_port_id[node_id][port_id] = sdk_port;
     node_id_to_sdk_port_id_to_port_id[node_id][sdk_port] = port_id;
@@ -366,8 +366,8 @@ BfChassisManager::~BfChassisManager() = default;
         // something is wrong with the port, we make sure the port is deleted
         // first (and ignore the error status if there is one), then add the
         // port again.
-        if (bf_sde_interface_->IsValidPort(unit, sdk_port_id)) {
-          bf_sde_interface_->DeletePort(unit, sdk_port_id);
+        if (tdi_sde_interface_->IsValidPort(unit, sdk_port_id)) {
+          tdi_sde_interface_->DeletePort(unit, sdk_port_id);
         }
         RETURN_IF_ERROR(
             AddPortHelper(node_id, unit, sdk_port_id, singleton_port, &config));
@@ -380,7 +380,7 @@ BfChassisManager::~BfChassisManager() = default;
       // was added and the speed_bps was set.
       if (!config_old->speed_bps) {
         RETURN_ERROR(ERR_INTERNAL)
-            << "Invalid internal state in BfChassisManager, "
+            << "Invalid internal state in TdiChassisManager, "
             << "speed_bps field should contain a value";
       }
 
@@ -449,7 +449,7 @@ BfChassisManager::~BfChassisManager() = default;
                 << "Unsupported port type in DropTarget "
                 << drop_target.ShortDebugString();
         }
-        RETURN_IF_ERROR(bf_sde_interface_->SetDeflectOnDropDestination(
+        RETURN_IF_ERROR(tdi_sde_interface_->SetDeflectOnDropDestination(
             unit, sdk_port_id, drop_target.queue()));
         LOG(INFO) << "Configured deflect-on-drop to SDK port " << sdk_port_id
                   << " in node " << node_id << ".";
@@ -474,7 +474,7 @@ BfChassisManager::~BfChassisManager() = default;
       // TODO(bocon): Collect these errors and keep trying to remove old ports
       LOG(INFO) << "Deleting port " << port_id << " in node " << node_id
                 << " (SDK port " << sdk_port_id << ").";
-      RETURN_IF_ERROR(bf_sde_interface_->DeletePort(unit, sdk_port_id));
+      RETURN_IF_ERROR(tdi_sde_interface_->DeletePort(unit, sdk_port_id));
     }
   }
 
@@ -495,21 +495,21 @@ BfChassisManager::~BfChassisManager() = default;
   return ::util::OkStatus();
 }
 
-::util::Status BfChassisManager::ApplyPortShapingConfig(
+::util::Status TdiChassisManager::ApplyPortShapingConfig(
     uint64 node_id, int unit, uint32 sdk_port_id,
     const TofinoConfig::BfPortShapingConfig::BfPerPortShapingConfig&
         shaping_config) {
   switch (shaping_config.shaping_case()) {
     case TofinoConfig::BfPortShapingConfig::BfPerPortShapingConfig::
         kPacketShaping:
-      RETURN_IF_ERROR(bf_sde_interface_->SetPortShapingRate(
+      RETURN_IF_ERROR(tdi_sde_interface_->SetPortShapingRate(
           unit, sdk_port_id, true,
           shaping_config.packet_shaping().max_burst_packets(),
           shaping_config.packet_shaping().max_rate_pps()));
       break;
     case TofinoConfig::BfPortShapingConfig::BfPerPortShapingConfig::
         kByteShaping:
-      RETURN_IF_ERROR(bf_sde_interface_->SetPortShapingRate(
+      RETURN_IF_ERROR(tdi_sde_interface_->SetPortShapingRate(
           unit, sdk_port_id, false,
           shaping_config.byte_shaping().max_burst_bytes(),
           shaping_config.byte_shaping().max_rate_bps()));
@@ -520,7 +520,7 @@ BfChassisManager::~BfChassisManager() = default;
           << ".";
   }
   RETURN_IF_ERROR(
-      bf_sde_interface_->EnablePortShaping(unit, sdk_port_id, TRI_STATE_TRUE));
+      tdi_sde_interface_->EnablePortShaping(unit, sdk_port_id, TRI_STATE_TRUE));
   LOG(INFO) << "Configured port shaping on SDK port " << sdk_port_id
             << " in node " << node_id << ": "
             << shaping_config.ShortDebugString() << ".";
@@ -528,7 +528,7 @@ BfChassisManager::~BfChassisManager() = default;
   return ::util::OkStatus();
 }
 
-::util::Status BfChassisManager::VerifyChassisConfig(
+::util::Status TdiChassisManager::VerifyChassisConfig(
     const ChassisConfig& config) {
   CHECK_RETURN_IF_FALSE(config.trunk_ports_size() == 0)
       << "Trunk ports are not supported on Tofino.";
@@ -634,7 +634,7 @@ BfChassisManager::~BfChassisManager() = default;
     CHECK_RETURN_IF_FALSE(unit != nullptr)
         << "Node " << node_id << " not found for port " << port_id << ".";
     RETURN_IF_ERROR(
-        bf_sde_interface_->GetPortIdFromPortKey(*unit, singleton_port_key)
+        tdi_sde_interface_->GetPortIdFromPortKey(*unit, singleton_port_key)
             .status());
   }
 
@@ -660,21 +660,21 @@ BfChassisManager::~BfChassisManager() = default;
   return ::util::OkStatus();
 }
 
-::util::Status BfChassisManager::RegisterEventNotifyWriter(
+::util::Status TdiChassisManager::RegisterEventNotifyWriter(
     const std::shared_ptr<WriterInterface<GnmiEventPtr>>& writer) {
   absl::WriterMutexLock l(&gnmi_event_lock_);
   gnmi_event_writer_ = writer;
   return ::util::OkStatus();
 }
 
-::util::Status BfChassisManager::UnregisterEventNotifyWriter() {
+::util::Status TdiChassisManager::UnregisterEventNotifyWriter() {
   absl::WriterMutexLock l(&gnmi_event_lock_);
   gnmi_event_writer_ = nullptr;
   return ::util::OkStatus();
 }
 
-::util::StatusOr<const BfChassisManager::PortConfig*>
-BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
+::util::StatusOr<const TdiChassisManager::PortConfig*>
+TdiChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
   auto* port_id_to_config =
       gtl::FindOrNull(node_id_to_port_id_to_port_config_, node_id);
   CHECK_RETURN_IF_FALSE(port_id_to_config != nullptr)
@@ -686,7 +686,7 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
   return config;
 }
 
-::util::StatusOr<uint32> BfChassisManager::GetSdkPortId(uint64 node_id,
+::util::StatusOr<uint32> TdiChassisManager::GetSdkPortId(uint64 node_id,
                                                         uint32 port_id) const {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
@@ -705,7 +705,7 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
   return *sdk_port_id;
 }
 
-::util::StatusOr<DataResponse> BfChassisManager::GetPortData(
+::util::StatusOr<DataResponse> TdiChassisManager::GetPortData(
     const DataRequest::Request& request) {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
@@ -837,7 +837,7 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
   return resp;
 }
 
-::util::StatusOr<PortState> BfChassisManager::GetPortState(
+::util::StatusOr<PortState> TdiChassisManager::GetPortState(
     uint64 node_id, uint32 port_id) const {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
@@ -861,14 +861,14 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
             << ".";
   ASSIGN_OR_RETURN(auto sdk_port_id, GetSdkPortId(node_id, port_id));
   ASSIGN_OR_RETURN(auto port_state,
-                   bf_sde_interface_->GetPortState(unit, sdk_port_id));
+                   tdi_sde_interface_->GetPortState(unit, sdk_port_id));
   LOG(INFO) << "State of port " << port_id << " in node " << node_id
             << " (SDK port " << sdk_port_id
             << "): " << PrintPortState(port_state);
   return port_state;
 }
 
-::util::StatusOr<absl::Time> BfChassisManager::GetPortTimeLastChanged(
+::util::StatusOr<absl::Time> TdiChassisManager::GetPortTimeLastChanged(
     uint64 node_id, uint32 port_id) {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
@@ -881,17 +881,17 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
   return node_id_to_port_id_to_time_last_changed_[node_id][port_id];
 }
 
-::util::Status BfChassisManager::GetPortCounters(uint64 node_id, uint32 port_id,
+::util::Status TdiChassisManager::GetPortCounters(uint64 node_id, uint32 port_id,
                                                  PortCounters* counters) {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
   }
   ASSIGN_OR_RETURN(auto unit, GetUnitFromNodeId(node_id));
   ASSIGN_OR_RETURN(auto sdk_port_id, GetSdkPortId(node_id, port_id));
-  return bf_sde_interface_->GetPortCounters(unit, sdk_port_id, counters);
+  return tdi_sde_interface_->GetPortCounters(unit, sdk_port_id, counters);
 }
 
-::util::StatusOr<std::map<uint64, int>> BfChassisManager::GetNodeIdToUnitMap()
+::util::StatusOr<std::map<uint64, int>> TdiChassisManager::GetNodeIdToUnitMap()
     const {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
@@ -899,7 +899,7 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
   return node_id_to_unit_;
 }
 
-::util::Status BfChassisManager::ReplayPortsConfig(uint64 node_id) {
+::util::Status TdiChassisManager::ReplayPortsConfig(uint64 node_id) {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
   }
@@ -927,17 +927,17 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
 
     if (!config.speed_bps) {
       RETURN_ERROR(ERR_INTERNAL)
-          << "Invalid internal state in BfChassisManager, "
+          << "Invalid internal state in TdiChassisManager, "
           << "speed_bps field should contain a value";
     }
     if (!config.fec_mode) {
       RETURN_ERROR(ERR_INTERNAL)
-          << "Invalid internal state in BfChassisManager, "
+          << "Invalid internal state in TdiChassisManager, "
           << "fec_mode field should contain a value";
     }
 
     ASSIGN_OR_RETURN(auto sdk_port_id, GetSdkPortId(node_id, port_id));
-    RETURN_IF_ERROR(bf_sde_interface_->AddPort(
+    RETURN_IF_ERROR(tdi_sde_interface_->AddPort(
         unit, sdk_port_id, *config.speed_bps, *config.fec_mode));
     config_new->speed_bps = *config.speed_bps;
     config_new->admin_state = ADMIN_STATE_DISABLED;
@@ -945,16 +945,16 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
 
     if (config.mtu) {
       RETURN_IF_ERROR(
-          bf_sde_interface_->SetPortMtu(unit, sdk_port_id, *config.mtu));
+          tdi_sde_interface_->SetPortMtu(unit, sdk_port_id, *config.mtu));
       config_new->mtu = *config.mtu;
     }
     if (config.autoneg) {
-      RETURN_IF_ERROR(bf_sde_interface_->SetPortAutonegPolicy(unit, sdk_port_id,
+      RETURN_IF_ERROR(tdi_sde_interface_->SetPortAutonegPolicy(unit, sdk_port_id,
                                                               *config.autoneg));
       config_new->autoneg = *config.autoneg;
     }
     if (config.loopback_mode) {
-      RETURN_IF_ERROR(bf_sde_interface_->SetPortLoopbackMode(
+      RETURN_IF_ERROR(tdi_sde_interface_->SetPortLoopbackMode(
           unit, sdk_port_id, *config.loopback_mode));
       config_new->loopback_mode = *config.loopback_mode;
     }
@@ -962,7 +962,7 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
     if (config.admin_state == ADMIN_STATE_ENABLED) {
       VLOG(1) << "Enabling port " << port_id << " in node " << node_id
               << " (SDK port " << sdk_port_id << ").";
-      RETURN_IF_ERROR(bf_sde_interface_->EnablePort(unit, sdk_port_id));
+      RETURN_IF_ERROR(tdi_sde_interface_->EnablePort(unit, sdk_port_id));
       config_new->admin_state = ADMIN_STATE_ENABLED;
     }
 
@@ -1004,7 +1004,7 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
             << drop_target.ShortDebugString();
     }
 
-    RETURN_IF_ERROR(bf_sde_interface_->SetDeflectOnDropDestination(
+    RETURN_IF_ERROR(tdi_sde_interface_->SetDeflectOnDropDestination(
         unit, sdk_port_id, drop_target.queue()));
     LOG(INFO) << "Configured deflect on drop target port " << sdk_port_id
               << " in node " << node_id << ".";
@@ -1013,7 +1013,7 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
   return status;
 }
 
-::util::Status BfChassisManager::GetFrontPanelPortInfo(
+::util::Status TdiChassisManager::GetFrontPanelPortInfo(
     uint64 node_id, uint32 port_id, FrontPanelPortInfo* fp_port_info) {
   auto* port_id_to_port_key =
       gtl::FindOrNull(node_id_to_port_id_to_singleton_port_key_, node_id);
@@ -1027,14 +1027,14 @@ BfChassisManager::GetPortConfig(uint64 node_id, uint32 port_id) const {
                                                 fp_port_info);
 }
 
-std::unique_ptr<BfChassisManager> BfChassisManager::CreateInstance(
+std::unique_ptr<TdiChassisManager> TdiChassisManager::CreateInstance(
     OperationMode mode, PhalInterface* phal_interface,
-    BfSdeInterface* bf_sde_interface) {
+    TdiSdeInterface* tdi_sde_interface) {
   return absl::WrapUnique(
-      new BfChassisManager(mode, phal_interface, bf_sde_interface));
+      new TdiChassisManager(mode, phal_interface, tdi_sde_interface));
 }
 
-void BfChassisManager::SendPortOperStateGnmiEvent(
+void TdiChassisManager::SendPortOperStateGnmiEvent(
     uint64 node_id, uint32 port_id, PortState new_state,
     absl::Time time_last_changed) {
   absl::ReaderMutexLock l(&gnmi_event_lock_);
@@ -1052,7 +1052,7 @@ void BfChassisManager::SendPortOperStateGnmiEvent(
   }
 }
 
-void* BfChassisManager::PortStatusEventHandlerThreadFunc(void* arg) {
+void* TdiChassisManager::PortStatusEventHandlerThreadFunc(void* arg) {
   CHECK(arg != nullptr);
   // Retrieve arguments.
   auto* args = reinterpret_cast<ReaderArgs<PortStatusEvent>*>(arg);
@@ -1064,7 +1064,7 @@ void* BfChassisManager::PortStatusEventHandlerThreadFunc(void* arg) {
   return nullptr;
 }
 
-void BfChassisManager::ReadPortStatusEvents(
+void TdiChassisManager::ReadPortStatusEvents(
     const std::unique_ptr<ChannelReader<PortStatusEvent>>& reader) {
   PortStatusEvent event;
   do {
@@ -1089,7 +1089,7 @@ void BfChassisManager::ReadPortStatusEvents(
   } while (true);
 }
 
-void BfChassisManager::PortStatusEventHandler(int device, int port,
+void TdiChassisManager::PortStatusEventHandler(int device, int port,
                                               PortState new_state,
                                               absl::Time time_last_changed) {
   absl::WriterMutexLock l(&chassis_lock);
@@ -1131,7 +1131,7 @@ void BfChassisManager::PortStatusEventHandler(int device, int port,
             << ".";
 }
 
-void* BfChassisManager::TransceiverEventHandlerThreadFunc(void* arg) {
+void* TdiChassisManager::TransceiverEventHandlerThreadFunc(void* arg) {
   CHECK(arg != nullptr);
   // Retrieve arguments.
   auto* args = reinterpret_cast<ReaderArgs<TransceiverEvent>*>(arg);
@@ -1143,7 +1143,7 @@ void* BfChassisManager::TransceiverEventHandlerThreadFunc(void* arg) {
   return nullptr;
 }
 
-void BfChassisManager::ReadTransceiverEvents(
+void TdiChassisManager::ReadTransceiverEvents(
     const std::unique_ptr<ChannelReader<TransceiverEvent>>& reader) {
   do {
     // Check switch shutdown.
@@ -1167,7 +1167,7 @@ void BfChassisManager::ReadTransceiverEvents(
   } while (true);
 }
 
-void BfChassisManager::TransceiverEventHandler(int slot, int port,
+void TdiChassisManager::TransceiverEventHandler(int slot, int port,
                                                HwState new_state) {
   absl::WriterMutexLock l(&chassis_lock);
 
@@ -1226,7 +1226,7 @@ void BfChassisManager::TransceiverEventHandler(int slot, int port,
   }
 }
 
-::util::Status BfChassisManager::RegisterEventWriters() {
+::util::Status TdiChassisManager::RegisterEventWriters() {
   if (initialized_) {
     return MAKE_ERROR(ERR_INTERNAL)
            << "RegisterEventWriters() can be called only before the class is "
@@ -1237,11 +1237,11 @@ void BfChassisManager::TransceiverEventHandler(int slot, int port,
   if (!port_status_event_channel_) {
     port_status_event_channel_ =
         Channel<PortStatusEvent>::Create(kMaxPortStatusEventDepth);
-    // Create and hand-off Writer to the BfSdeInterface.
+    // Create and hand-off Writer to the TdiSdeInterface.
     auto writer =
         ChannelWriter<PortStatusEvent>::Create(port_status_event_channel_);
     RETURN_IF_ERROR(
-        bf_sde_interface_->RegisterPortStatusEventWriter(std::move(writer)));
+        tdi_sde_interface_->RegisterPortStatusEventWriter(std::move(writer)));
     LOG(INFO) << "Port status notification callback registered successfully";
     // Create and hand-off Reader to new reader thread.
     auto reader =
@@ -1298,12 +1298,12 @@ void BfChassisManager::TransceiverEventHandler(int slot, int port,
   return ::util::OkStatus();
 }
 
-::util::Status BfChassisManager::UnregisterEventWriters() {
+::util::Status TdiChassisManager::UnregisterEventWriters() {
   absl::WriterMutexLock l(&chassis_lock);
   ::util::Status status = ::util::OkStatus();
   // Unregister the linkscan and transceiver module event Writers.
   APPEND_STATUS_IF_ERROR(status,
-                         bf_sde_interface_->UnregisterPortStatusEventWriter());
+                         tdi_sde_interface_->UnregisterPortStatusEventWriter());
   // Close Channel.
   if (!port_status_event_channel_ || !port_status_event_channel_->Close()) {
     ::util::Status error = MAKE_ERROR(ERR_INTERNAL)
@@ -1329,7 +1329,7 @@ void BfChassisManager::TransceiverEventHandler(int slot, int port,
   return status;
 }
 
-::util::StatusOr<int> BfChassisManager::GetUnitFromNodeId(
+::util::StatusOr<int> TdiChassisManager::GetUnitFromNodeId(
     uint64 node_id) const {
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
@@ -1341,7 +1341,7 @@ void BfChassisManager::TransceiverEventHandler(int slot, int port,
   return *unit;
 }
 
-void BfChassisManager::CleanupInternalState() {
+void TdiChassisManager::CleanupInternalState() {
   unit_to_node_id_.clear();
   node_id_to_unit_.clear();
   node_id_to_port_id_to_port_state_.clear();
@@ -1354,7 +1354,7 @@ void BfChassisManager::CleanupInternalState() {
   xcvr_port_key_to_xcvr_state_.clear();
 }
 
-::util::Status BfChassisManager::Shutdown() {
+::util::Status TdiChassisManager::Shutdown() {
   ::util::Status status = ::util::OkStatus();
   {
     absl::ReaderMutexLock l(&chassis_lock);
diff --git a/stratum/hal/lib/barefoot/bf_chassis_manager.h b/stratum/hal/lib/barefoot/bf_chassis_manager.h
index 0e725890..1c03e56e 100644
--- a/stratum/hal/lib/barefoot/bf_chassis_manager.h
+++ b/stratum/hal/lib/barefoot/bf_chassis_manager.h
@@ -27,9 +27,9 @@ namespace barefoot {
 // Lock which protects chassis state across the entire switch.
 extern absl::Mutex chassis_lock;
 
-class BfChassisManager {
+class TdiChassisManager {
  public:
-  virtual ~BfChassisManager();
+  virtual ~TdiChassisManager();
 
   virtual ::util::Status PushChassisConfig(const ChassisConfig& config)
       EXCLUSIVE_LOCKS_REQUIRED(chassis_lock);
@@ -71,25 +71,25 @@ class BfChassisManager {
       SHARED_LOCKS_REQUIRED(chassis_lock);
 
   // Factory function for creating the instance of the class.
-  static std::unique_ptr<BfChassisManager> CreateInstance(
+  static std::unique_ptr<TdiChassisManager> CreateInstance(
       OperationMode mode, PhalInterface* phal_interface,
-      BfSdeInterface* bf_sde_interface);
+      TdiSdeInterface* tdi_sde_interface);
 
-  // BfChassisManager is neither copyable nor movable.
-  BfChassisManager(const BfChassisManager&) = delete;
-  BfChassisManager& operator=(const BfChassisManager&) = delete;
-  BfChassisManager(BfChassisManager&&) = delete;
-  BfChassisManager& operator=(BfChassisManager&&) = delete;
+  // TdiChassisManager is neither copyable nor movable.
+  TdiChassisManager(const TdiChassisManager&) = delete;
+  TdiChassisManager& operator=(const TdiChassisManager&) = delete;
+  TdiChassisManager(TdiChassisManager&&) = delete;
+  TdiChassisManager& operator=(TdiChassisManager&&) = delete;
 
  protected:
   // Default constructor. To be called by the Mock class instance only.
-  BfChassisManager();
+  TdiChassisManager();
 
  private:
   // ReaderArgs encapsulates the arguments for a Channel reader thread.
   template <typename T>
   struct ReaderArgs {
-    BfChassisManager* manager;
+    TdiChassisManager* manager;
     std::unique_ptr<ChannelReader<T>> reader;
   };
 
@@ -116,8 +116,8 @@ class BfChassisManager {
 
   // Private constructor. Use CreateInstance() to create an instance of this
   // class.
-  BfChassisManager(OperationMode mode, PhalInterface* phal_interface,
-                   BfSdeInterface* bf_sde_interface);
+  TdiChassisManager(OperationMode mode, PhalInterface* phal_interface,
+                   TdiSdeInterface* tdi_sde_interface);
 
   ::util::StatusOr<const PortConfig*> GetPortConfig(uint64 node_id,
                                                     uint32 port_id) const
@@ -151,7 +151,7 @@ class BfChassisManager {
   // a ChannelReader thread which processes transceiver module insert/removal
   // events. Port is the 1-based frontpanel port number.
   // NOTE: This method should never be executed directly from a context which
-  // first accesses the internal structures of a class below BfChassisManager
+  // first accesses the internal structures of a class below TdiChassisManager
   // as this may result in deadlock.
   void TransceiverEventHandler(int slot, int port, HwState new_state)
       LOCKS_EXCLUDED(chassis_lock);
@@ -171,7 +171,7 @@ class BfChassisManager {
   // thread which processes SDE port status events. Port is the sdk port number
   // used by the SDE. NOTE: This method should never be executed directly from a
   // context which first accesses the internal structures of a class below
-  // BfChassisManager as this may result in deadlock.
+  // TdiChassisManager as this may result in deadlock.
   void PortStatusEventHandler(int device, int port, PortState new_state,
                               absl::Time time_last_changed)
       LOCKS_EXCLUDED(chassis_lock);
@@ -184,15 +184,15 @@ class BfChassisManager {
   // Reads and processes port state events using the given ChannelReader. Called
   // by PortStatusEventHandlerThreadFunc.
   void ReadPortStatusEvents(
-      const std::unique_ptr<ChannelReader<BfSdeInterface::PortStatusEvent>>&
+      const std::unique_ptr<ChannelReader<TdiSdeInterface::PortStatusEvent>>&
           reader) LOCKS_EXCLUDED(chassis_lock);
 
-  // helper to add / configure / enable a port with BfSdeInterface
+  // helper to add / configure / enable a port with TdiSdeInterface
   ::util::Status AddPortHelper(uint64 node_id, int unit, uint32 port_id,
                                const SingletonPort& singleton_port,
                                PortConfig* config);
 
-  // helper to update port configuration with BfSdeInterface
+  // helper to update port configuration with TdiSdeInterface
   ::util::Status UpdatePortHelper(uint64 node_id, int unit, uint32 port_id,
                                   const SingletonPort& singleton_port,
                                   const PortConfig& config_old,
@@ -216,8 +216,8 @@ class BfChassisManager {
 
   bool initialized_ GUARDED_BY(chassis_lock);
 
-  // Channel for receiving port status events from the BfSdeInterface.
-  std::shared_ptr<Channel<BfSdeInterface::PortStatusEvent>>
+  // Channel for receiving port status events from the TdiSdeInterface.
+  std::shared_ptr<Channel<TdiSdeInterface::PortStatusEvent>>
       port_status_event_channel_ GUARDED_BY(chassis_lock);
 
   // The id of the transceiver module insert/removal event ChannelWriter, as
@@ -251,8 +251,8 @@ class BfChassisManager {
       node_id_to_port_id_to_time_last_changed_ GUARDED_BY(chassis_lock);
 
   // Map from node ID to another map from port ID to port configuration.
-  // We may change this once missing "get" methods get added to BfSdeInterface,
-  // as we would be able to rely on BfSdeInterface to query config parameters,
+  // We may change this once missing "get" methods get added to TdiSdeInterface,
+  // as we would be able to rely on TdiSdeInterface to query config parameters,
   // instead of maintaining a "consistent" view in this map.
   std::map<uint64, std::map<uint32, PortConfig>>
       node_id_to_port_id_to_port_config_ GUARDED_BY(chassis_lock);
@@ -288,10 +288,10 @@ class BfChassisManager {
   // Pointer to a PhalInterface implementation.
   PhalInterface* phal_interface_;  // not owned by this class.
 
-  // Pointer to a BfSdeInterface implementation that wraps all the SDE calls.
-  BfSdeInterface* bf_sde_interface_;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps all the SDE calls.
+  TdiSdeInterface* tdi_sde_interface_;  // not owned by this class.
 
-  friend class BfChassisManagerTest;
+  friend class TdiChassisManagerTest;
 };
 
 }  // namespace barefoot
diff --git a/stratum/hal/lib/barefoot/bf_chassis_manager_mock.h b/stratum/hal/lib/barefoot/bf_chassis_manager_mock.h
index 4290f85d..81b8756a 100644
--- a/stratum/hal/lib/barefoot/bf_chassis_manager_mock.h
+++ b/stratum/hal/lib/barefoot/bf_chassis_manager_mock.h
@@ -15,7 +15,7 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class BfChassisManagerMock : public BfChassisManager {
+class TdiChassisManagerMock : public TdiChassisManager {
  public:
   MOCK_METHOD1(PushChassisConfig, ::util::Status(const ChassisConfig& config));
   MOCK_METHOD1(VerifyChassisConfig,
diff --git a/stratum/hal/lib/barefoot/bf_chassis_manager_test.cc b/stratum/hal/lib/barefoot/bf_chassis_manager_test.cc
index c9a1bdfd..ef79b41e 100644
--- a/stratum/hal/lib/barefoot/bf_chassis_manager_test.cc
+++ b/stratum/hal/lib/barefoot/bf_chassis_manager_test.cc
@@ -28,7 +28,7 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-using PortStatusEvent = BfSdeInterface::PortStatusEvent;
+using PortStatusEvent = TdiSdeInterface::PortStatusEvent;
 using test_utils::EqualsProto;
 using ::testing::_;
 using ::testing::AtLeast;
@@ -76,7 +76,7 @@ MATCHER_P(GnmiEventEq, event, "") {
 class ChassisConfigBuilder {
  public:
   explicit ChassisConfigBuilder(uint64 node_id = kNodeId) : node_id(node_id) {
-    config_.set_description("Test config for BfChassisManager");
+    config_.set_description("Test config for TdiChassisManager");
     auto* chassis = config_.mutable_chassis();
     chassis->set_platform(PLT_GENERIC_BAREFOOT_TOFINO);
     chassis->set_name("Tofino");
@@ -127,15 +127,15 @@ class ChassisConfigBuilder {
 
 }  // namespace
 
-class BfChassisManagerTest : public ::testing::Test {
+class TdiChassisManagerTest : public ::testing::Test {
  protected:
-  BfChassisManagerTest() {}
+  TdiChassisManagerTest() {}
 
   void SetUp() override {
     phal_mock_ = absl::make_unique<PhalMock>();
     bf_sde_mock_ = absl::make_unique<BfSdeMock>();
     // TODO(max): create parametrized test suite over mode.
-    bf_chassis_manager_ = BfChassisManager::CreateInstance(
+    tdi_chassis_manager_ = TdiChassisManager::CreateInstance(
         OPERATION_MODE_STANDALONE, phal_mock_.get(), bf_sde_mock_.get());
     ON_CALL(*bf_sde_mock_, IsValidPort(_, _))
         .WillByDefault(
@@ -156,41 +156,41 @@ class BfChassisManagerTest : public ::testing::Test {
   }
 
   ::util::Status CheckCleanInternalState() {
-    CHECK_RETURN_IF_FALSE(bf_chassis_manager_->unit_to_node_id_.empty());
-    CHECK_RETURN_IF_FALSE(bf_chassis_manager_->node_id_to_unit_.empty());
+    CHECK_RETURN_IF_FALSE(tdi_chassis_manager_->unit_to_node_id_.empty());
+    CHECK_RETURN_IF_FALSE(tdi_chassis_manager_->node_id_to_unit_.empty());
     CHECK_RETURN_IF_FALSE(
-        bf_chassis_manager_->node_id_to_port_id_to_port_state_.empty());
+        tdi_chassis_manager_->node_id_to_port_id_to_port_state_.empty());
     CHECK_RETURN_IF_FALSE(
-        bf_chassis_manager_->node_id_to_port_id_to_port_config_.empty());
+        tdi_chassis_manager_->node_id_to_port_id_to_port_config_.empty());
     CHECK_RETURN_IF_FALSE(
-        bf_chassis_manager_->node_id_to_port_id_to_singleton_port_key_.empty());
+        tdi_chassis_manager_->node_id_to_port_id_to_singleton_port_key_.empty());
     CHECK_RETURN_IF_FALSE(
-        bf_chassis_manager_->node_id_to_port_id_to_sdk_port_id_.empty());
+        tdi_chassis_manager_->node_id_to_port_id_to_sdk_port_id_.empty());
     CHECK_RETURN_IF_FALSE(
-        bf_chassis_manager_->node_id_to_sdk_port_id_to_port_id_.empty());
+        tdi_chassis_manager_->node_id_to_sdk_port_id_to_port_id_.empty());
     CHECK_RETURN_IF_FALSE(
-        bf_chassis_manager_->xcvr_port_key_to_xcvr_state_.empty());
-    CHECK_RETURN_IF_FALSE(bf_chassis_manager_->port_status_event_channel_ ==
+        tdi_chassis_manager_->xcvr_port_key_to_xcvr_state_.empty());
+    CHECK_RETURN_IF_FALSE(tdi_chassis_manager_->port_status_event_channel_ ==
                           nullptr);
-    CHECK_RETURN_IF_FALSE(bf_chassis_manager_->xcvr_event_channel_ == nullptr);
+    CHECK_RETURN_IF_FALSE(tdi_chassis_manager_->xcvr_event_channel_ == nullptr);
     return ::util::OkStatus();
   }
 
-  bool Initialized() { return bf_chassis_manager_->initialized_; }
+  bool Initialized() { return tdi_chassis_manager_->initialized_; }
 
   ::util::Status VerifyChassisConfig(const ChassisConfig& config) {
     absl::ReaderMutexLock l(&chassis_lock);
-    return bf_chassis_manager_->VerifyChassisConfig(config);
+    return tdi_chassis_manager_->VerifyChassisConfig(config);
   }
 
   ::util::Status PushChassisConfig(const ChassisConfig& config) {
     absl::WriterMutexLock l(&chassis_lock);
-    return bf_chassis_manager_->PushChassisConfig(config);
+    return tdi_chassis_manager_->PushChassisConfig(config);
   }
 
   ::util::Status PushChassisConfig(const ChassisConfigBuilder& builder) {
     absl::WriterMutexLock l(&chassis_lock);
-    return bf_chassis_manager_->PushChassisConfig(builder.Get());
+    return tdi_chassis_manager_->PushChassisConfig(builder.Get());
   }
 
   ::util::Status PushBaseChassisConfig(ChassisConfigBuilder* builder) {
@@ -228,7 +228,7 @@ class BfChassisManagerTest : public ::testing::Test {
 
   ::util::Status ReplayPortsConfig(uint64 node_id) {
     absl::WriterMutexLock l(&chassis_lock);
-    return bf_chassis_manager_->ReplayPortsConfig(node_id);
+    return tdi_chassis_manager_->ReplayPortsConfig(node_id);
   }
 
   ::util::Status PushBaseChassisConfig() {
@@ -238,10 +238,10 @@ class BfChassisManagerTest : public ::testing::Test {
 
   ::util::StatusOr<int> GetUnitFromNodeId(uint64 node_id) const {
     absl::ReaderMutexLock l(&chassis_lock);
-    return bf_chassis_manager_->GetUnitFromNodeId(node_id);
+    return tdi_chassis_manager_->GetUnitFromNodeId(node_id);
   }
 
-  ::util::Status Shutdown() { return bf_chassis_manager_->Shutdown(); }
+  ::util::Status Shutdown() { return tdi_chassis_manager_->Shutdown(); }
 
   ::util::Status ShutdownAndTestCleanState() {
     EXPECT_CALL(*bf_sde_mock_, UnregisterPortStatusEventWriter())
@@ -253,19 +253,19 @@ class BfChassisManagerTest : public ::testing::Test {
 
   ::util::Status RegisterEventNotifyWriter(
       const std::shared_ptr<WriterInterface<GnmiEventPtr>>& writer) {
-    return bf_chassis_manager_->RegisterEventNotifyWriter(writer);
+    return tdi_chassis_manager_->RegisterEventNotifyWriter(writer);
   }
 
   ::util::Status UnregisterEventNotifyWriter() {
-    return bf_chassis_manager_->UnregisterEventNotifyWriter();
+    return tdi_chassis_manager_->UnregisterEventNotifyWriter();
   }
 
   std::unique_ptr<ChannelWriter<TransceiverEvent>> GetTransceiverEventWriter() {
     absl::WriterMutexLock l(&chassis_lock);
-    CHECK(bf_chassis_manager_->xcvr_event_channel_ != nullptr)
+    CHECK(tdi_chassis_manager_->xcvr_event_channel_ != nullptr)
         << "xcvr channel is null!";
     return ChannelWriter<PhalInterface::TransceiverEvent>::Create(
-        bf_chassis_manager_->xcvr_event_channel_);
+        tdi_chassis_manager_->xcvr_event_channel_);
   }
 
   void TriggerPortStatusEvent(int device, int port, PortState state,
@@ -281,24 +281,24 @@ class BfChassisManagerTest : public ::testing::Test {
   std::unique_ptr<PhalMock> phal_mock_;
   std::unique_ptr<BfSdeMock> bf_sde_mock_;
   std::unique_ptr<ChannelWriter<PortStatusEvent>> sde_event_writer_;
-  std::unique_ptr<BfChassisManager> bf_chassis_manager_;
+  std::unique_ptr<TdiChassisManager> tdi_chassis_manager_;
 
   static constexpr int kTestTransceiverWriterId = 20;
 };
 
-TEST_F(BfChassisManagerTest, PreFirstConfigPushState) {
+TEST_F(TdiChassisManagerTest, PreFirstConfigPushState) {
   ASSERT_OK(CheckCleanInternalState());
   EXPECT_FALSE(Initialized());
   // TODO(antonin): add more checks (to verify that method calls fail as
   // expected)
 }
 
-TEST_F(BfChassisManagerTest, FirstConfigPush) {
+TEST_F(TdiChassisManagerTest, FirstConfigPush) {
   ASSERT_OK(PushBaseChassisConfig());
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, RemovePort) {
+TEST_F(TdiChassisManagerTest, RemovePort) {
   ChassisConfigBuilder builder;
   ASSERT_OK(PushBaseChassisConfig(&builder));
 
@@ -309,7 +309,7 @@ TEST_F(BfChassisManagerTest, RemovePort) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, AddPortFec) {
+TEST_F(TdiChassisManagerTest, AddPortFec) {
   ChassisConfigBuilder builder;
   ASSERT_OK(PushBaseChassisConfig(&builder));
 
@@ -326,7 +326,7 @@ TEST_F(BfChassisManagerTest, AddPortFec) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, SetPortLoopback) {
+TEST_F(TdiChassisManagerTest, SetPortLoopback) {
   ChassisConfigBuilder builder;
   ASSERT_OK(PushBaseChassisConfig(&builder));
 
@@ -342,7 +342,7 @@ TEST_F(BfChassisManagerTest, SetPortLoopback) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, ApplyPortShaping) {
+TEST_F(TdiChassisManagerTest, ApplyPortShaping) {
   const std::string kVendorConfigText = R"PROTO(
     tofino_config {
       node_id_to_port_shaping_config {
@@ -382,7 +382,7 @@ TEST_F(BfChassisManagerTest, ApplyPortShaping) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, ApplyDeflectOnDrop) {
+TEST_F(TdiChassisManagerTest, ApplyDeflectOnDrop) {
   const std::string kVendorConfigText = R"PROTO(
     tofino_config {
       node_id_to_deflect_on_drop_configs {
@@ -418,7 +418,7 @@ TEST_F(BfChassisManagerTest, ApplyDeflectOnDrop) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, ReplayPorts) {
+TEST_F(TdiChassisManagerTest, ReplayPorts) {
   const std::string kVendorConfigText = R"PROTO(
     tofino_config {
       node_id_to_deflect_on_drop_configs {
@@ -486,7 +486,7 @@ TEST_F(BfChassisManagerTest, ReplayPorts) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, TransceiverEvent) {
+TEST_F(TdiChassisManagerTest, TransceiverEvent) {
   ASSERT_OK(PushBaseChassisConfig());
   auto xcvr_event_writer = GetTransceiverEventWriter();
 
@@ -503,7 +503,7 @@ TEST_F(BfChassisManagerTest, TransceiverEvent) {
 }
 
 template <typename T>
-T GetPortData(BfChassisManager* bf_chassis_manager_, uint64 node_id,
+T GetPortData(TdiChassisManager* tdi_chassis_manager_, uint64 node_id,
               int port_id,
               DataRequest::Request::Port* (
                   DataRequest::Request::*get_mutable_message_func)(),
@@ -512,7 +512,7 @@ T GetPortData(BfChassisManager* bf_chassis_manager_, uint64 node_id,
   DataRequest::Request req;
   (req.*get_mutable_message_func)()->set_node_id(node_id);
   (req.*get_mutable_message_func)()->set_port_id(port_id);
-  auto resp = bf_chassis_manager_->GetPortData(req);
+  auto resp = tdi_chassis_manager_->GetPortData(req);
   EXPECT_OK(resp);
 
   DataResponse data_resp = resp.ValueOrDie();
@@ -521,7 +521,7 @@ T GetPortData(BfChassisManager* bf_chassis_manager_, uint64 node_id,
 }
 
 template <typename T, typename U>
-void GetPortDataTest(BfChassisManager* bf_chassis_manager_, uint64 node_id,
+void GetPortDataTest(TdiChassisManager* tdi_chassis_manager_, uint64 node_id,
                      int port_id,
                      DataRequest::Request::Port* (
                          DataRequest::Request::*get_mutable_message_func)(),
@@ -531,13 +531,13 @@ void GetPortDataTest(BfChassisManager* bf_chassis_manager_, uint64 node_id,
                          const,
                      U (T::*get_inner_message_func)() const, U expected_value) {
   const T& val = GetPortData(
-      bf_chassis_manager_, node_id, port_id, get_mutable_message_func,
+      tdi_chassis_manager_, node_id, port_id, get_mutable_message_func,
       data_response_get_message_func, data_response_has_message_func);
   EXPECT_EQ((val.*get_inner_message_func)(), expected_value);
 }
 
 template <typename T>
-void GetPortDataTest(BfChassisManager* bf_chassis_manager_, uint64 node_id,
+void GetPortDataTest(TdiChassisManager* tdi_chassis_manager_, uint64 node_id,
                      int port_id,
                      DataRequest::Request::Port* (
                          DataRequest::Request::*get_mutable_message_func)(),
@@ -546,13 +546,13 @@ void GetPortDataTest(BfChassisManager* bf_chassis_manager_, uint64 node_id,
                      bool (DataResponse::*data_response_has_message_func)()
                          const,
                      T expected_msg) {
-  T val = GetPortData(bf_chassis_manager_, node_id, port_id,
+  T val = GetPortData(tdi_chassis_manager_, node_id, port_id,
                       get_mutable_message_func, data_response_get_message_func,
                       data_response_has_message_func);
   EXPECT_THAT(val, EqualsProto(expected_msg));
 }
 
-TEST_F(BfChassisManagerTest, GetPortData) {
+TEST_F(TdiChassisManagerTest, GetPortData) {
   ChassisConfigBuilder builder;
   ASSERT_OK(PushBaseChassisConfig(&builder));
 
@@ -649,7 +649,7 @@ TEST_F(BfChassisManagerTest, GetPortData) {
   TriggerPortStatusEvent(456, sdkPortId, PORT_STATE_UP,
                          kPortTimeLastChanged1);  // Unknown device
   ASSERT_TRUE(first_link_up.WaitForNotificationWithTimeout(absl::Seconds(5)));
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_oper_status,
                   &DataResponse::oper_status, &DataResponse::has_oper_status,
                   &OperStatus::state, PORT_STATE_UP);
@@ -662,79 +662,79 @@ TEST_F(BfChassisManagerTest, GetPortData) {
                          kPortTimeLastChanged3);
   ASSERT_TRUE(port_flip_done.WaitForNotificationWithTimeout(absl::Seconds(5)));
   OperStatus oper_status =
-      GetPortData(bf_chassis_manager_.get(), kNodeId, portId,
+      GetPortData(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_oper_status,
                   &DataResponse::oper_status, &DataResponse::has_oper_status);
   EXPECT_EQ(kPortTimeLastChanged3,
             absl::FromUnixNanos(oper_status.time_last_changed()));
 
   // Admin status
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_admin_status,
                   &DataResponse::admin_status, &DataResponse::has_admin_status,
                   &AdminStatus::state, ADMIN_STATE_ENABLED);
 
   // Port speed
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_port_speed,
                   &DataResponse::port_speed, &DataResponse::has_port_speed,
                   &PortSpeed::speed_bps, kHundredGigBps);
 
   // LACP router MAC
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_lacp_router_mac,
                   &DataResponse::lacp_router_mac,
                   &DataResponse::has_lacp_router_mac, &MacAddress::mac_address,
                   0x112233445566ul);
 
   // Negotiated port speed
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_negotiated_port_speed,
                   &DataResponse::negotiated_port_speed,
                   &DataResponse::has_negotiated_port_speed,
                   &PortSpeed::speed_bps, kHundredGigBps);
 
   // Port counters
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_port_counters,
                   &DataResponse::port_counters,
                   &DataResponse::has_port_counters, counters);
 
   // Autoneg status
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_autoneg_status,
                   &DataResponse::autoneg_status,
                   &DataResponse::has_autoneg_status,
                   &AutonegotiationStatus::state, TRI_STATE_TRUE);
 
   // Front panel info
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_front_panel_port_info,
                   &DataResponse::front_panel_port_info,
                   &DataResponse::has_front_panel_port_info,
                   front_panel_port_info);
 
   // FEC status
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_fec_status,
                   &DataResponse::fec_status, &DataResponse::has_fec_status,
                   &FecStatus::mode, FEC_MODE_ON);
 
   // Loopback mode
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_loopback_status,
                   &DataResponse::loopback_status,
                   &DataResponse::has_loopback_status, &LoopbackStatus::state,
                   LOOPBACK_STATE_MAC);
 
   // SDK port number
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_sdn_port_id,
                   &DataResponse::sdn_port_id, &DataResponse::has_sdn_port_id,
                   &SdnPortId::port_id, sdkPortId);
 
   // Forwarding Viability
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_forwarding_viability,
                   &DataResponse::forwarding_viability,
                   &DataResponse::has_forwarding_viability,
@@ -742,14 +742,14 @@ TEST_F(BfChassisManagerTest, GetPortData) {
                   TRUNK_MEMBER_BLOCK_STATE_UNKNOWN);
 
   // Health Indicator
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_health_indicator,
                   &DataResponse::health_indicator,
                   &DataResponse::has_health_indicator, &HealthIndicator::state,
                   HEALTH_STATE_UNKNOWN);
 
   // SDN port ID
-  GetPortDataTest(bf_chassis_manager_.get(), kNodeId, portId,
+  GetPortDataTest(tdi_chassis_manager_.get(), kNodeId, portId,
                   &DataRequest::Request::mutable_sdn_port_id,
                   &DataResponse::sdn_port_id, &DataResponse::has_sdn_port_id,
                   &SdnPortId::port_id, sdkPortId);
@@ -758,7 +758,7 @@ TEST_F(BfChassisManagerTest, GetPortData) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, UpdateInvalidPort) {
+TEST_F(TdiChassisManagerTest, UpdateInvalidPort) {
   ASSERT_OK(PushBaseChassisConfig());
   ChassisConfigBuilder builder;
   const uint32 portId = kPortId + 1;
@@ -789,7 +789,7 @@ TEST_F(BfChassisManagerTest, UpdateInvalidPort) {
   ASSERT_OK(ShutdownAndTestCleanState());
 }
 
-TEST_F(BfChassisManagerTest, VerifyChassisConfigSuccess) {
+TEST_F(TdiChassisManagerTest, VerifyChassisConfigSuccess) {
   const std::string kConfigText1 = R"(
       description: "Sample Generic Tofino config 2x25G ports."
       chassis {
diff --git a/stratum/hal/lib/barefoot/bf_sde_interface.h b/stratum/hal/lib/barefoot/bf_sde_interface.h
index 5ce91295..174dfc9e 100644
--- a/stratum/hal/lib/barefoot/bf_sde_interface.h
+++ b/stratum/hal/lib/barefoot/bf_sde_interface.h
@@ -21,12 +21,12 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-// The "BfSdeInterface" class in HAL implements a shim layer around the Barefoot
+// The "TdiSdeInterface" class in HAL implements a shim layer around the Barefoot
 // SDE. It is defined as an abstract class to allow multiple implementations:
-// 1- BfSdeWrapper: The real implementation which includes all the SDE API
+// 1- TdiSdeWrapper: The real implementation which includes all the SDE API
 //    calls.
 // 2- BfSdeMock: Mock class used for unit testing.
-class BfSdeInterface {
+class TdiSdeInterface {
  public:
   // PortStatusEvent encapsulates the information received on a port status
   // event. Port refers to the SDE internal device port ID.
@@ -37,7 +37,33 @@ class BfSdeInterface {
     absl::Time time_last_changed;
   };
 
-  // SessionInterface is a proxy class for BfRt sessions. Most API calls require
+  struct HotplugConfigParams {
+    uint32 qemu_socket_port;
+    uint64 qemu_vm_mac_address;
+    std::string qemu_socket_ip;
+    std::string qemu_vm_netdev_id;
+    std::string qemu_vm_chardev_id;
+    std::string qemu_vm_device_id;
+    std::string native_socket_path;
+    SWBackendQemuHotplugStatus qemu_hotplug;
+  };
+
+  struct PortConfigParams {
+    SWBackendPortType port_type;
+    SWBackendDeviceType device_type;
+    SWBackendPktDirType packet_dir;
+    int queues;
+    int mtu;
+    std::string socket_path;
+    std::string host_name;
+    std::string port_name;
+    std::string pipeline_name;
+    std::string mempool_name;
+    std::string pci_bdf;
+    struct HotplugConfigParams hotplug_config;
+  };
+
+  // SessionInterface is a proxy class for TdiRt sessions. Most API calls require
   // an active session. It also allows batching requests for performance.
   class SessionInterface {
    public:
@@ -50,7 +76,7 @@ class BfSdeInterface {
     virtual ::util::Status EndBatch() = 0;
   };
 
-  // TableKeyInterface is a proxy class for BfRt table keys.
+  // TableKeyInterface is a proxy class for TdiRt table keys.
   class TableKeyInterface {
    public:
     virtual ~TableKeyInterface() {}
@@ -86,13 +112,13 @@ class BfSdeInterface {
                                     std::string* high) const = 0;
 
     // Sets the priority of this table key. 0 is the highest priority.
-    virtual ::util::Status SetPriority(uint32 priority) = 0;
+    virtual ::util::Status SetPriority(uint64 priority) = 0;
 
     // Gets the priority of this table key. 0 is the highest priority.
     virtual ::util::Status GetPriority(uint32* priority) const = 0;
   };
 
-  // TableKeyInterface is a proxy class for BfRt table data.
+  // TableKeyInterface is a proxy class for TdiRt table data.
   class TableDataInterface {
    public:
     virtual ~TableDataInterface() {}
@@ -132,7 +158,7 @@ class BfSdeInterface {
     virtual ::util::Status Reset(int action_id) = 0;
   };
 
-  virtual ~BfSdeInterface() {}
+  virtual ~TdiSdeInterface() {}
 
   // Initializes the SDE. Must be called before any other methods.
   virtual ::util::Status InitializeSde(const std::string& sde_install_path,
@@ -142,9 +168,9 @@ class BfSdeInterface {
   // Add and initialize a device. The device config (pipeline) will be loaded
   // into the ASIC. Can be used to re-initialize an existing device.
   virtual ::util::Status AddDevice(int device,
-                                   const BfrtDeviceConfig& device_config) = 0;
+                                   const TdirtDeviceConfig& device_config) = 0;
 
-  // Creates a new BfRt session.
+  // Creates a new TdiRt session.
   virtual ::util::StatusOr<std::shared_ptr<SessionInterface>>
   CreateSession() = 0;
 
@@ -166,10 +192,23 @@ class BfSdeInterface {
   // Unregisters the port status writer.
   virtual ::util::Status UnregisterPortStatusEventWriter() = 0;
 
+  // Get Port Info
+  virtual ::util::Status GetPortInfo(int device, int port,
+                                     TargetDatapathId *target_dp_id) = 0;
+
   // Add a new port with the given parameters.
   virtual ::util::Status AddPort(int device, int port, uint64 speed_bps,
                                  FecMode fec_mode = FEC_MODE_UNKNOWN) = 0;
 
+  // Add a new port with the given parameters.
+  virtual ::util::Status AddPort(int device, int port, uint64 speed_bps,
+                                 PortConfigParams& config,
+                                 FecMode fec_mode = FEC_MODE_UNKNOWN) = 0 ;
+
+  // Hotplug add/delete the port
+  virtual ::util::Status HotplugPort(int device, int port,
+                            HotplugConfigParams& hotplug_config) = 0;
+
   // Delete a port.
   virtual ::util::Status DeletePort(int device, int port) = 0;
 
@@ -255,86 +294,86 @@ class BfSdeInterface {
   // Create a new multicast node with the given parameters. Returns the newly
   // allocated node id.
   virtual ::util::StatusOr<uint32> CreateMulticastNode(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       int mc_replication_id, const std::vector<uint32>& mc_lag_ids,
       const std::vector<uint32>& ports) = 0;
 
   // Returns the node IDs linked to the given multicast group ID.
   // TODO(max): rename to GetMulticastNodeIdsInMulticastGroup
   virtual ::util::StatusOr<std::vector<uint32>> GetNodesInMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id) = 0;
 
   // Delete the given multicast nodes.
   virtual ::util::Status DeleteMulticastNodes(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const std::vector<uint32>& mc_node_ids) = 0;
 
   // Returns the multicast node with the given ID ($pre.node table).
   virtual ::util::Status GetMulticastNode(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 mc_node_id, int* replication_id, std::vector<uint32>* lag_ids,
       std::vector<uint32>* ports) = 0;
 
   // Inserts a multicast group ($pre.mgid table).
   virtual ::util::Status InsertMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id, const std::vector<uint32>& mc_node_ids) = 0;
 
   // Modifies a multicast group ($pre.mgid table).
   virtual ::util::Status ModifyMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id, const std::vector<uint32>& mc_node_ids) = 0;
 
   // Deletes a multicast group ($pre.mgid table).
   virtual ::util::Status DeleteMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id) = 0;
 
   // Returns the multicast group with the given ID ($pre.mgid table), or all
   // groups if ID is 0.
   virtual ::util::Status GetMulticastGroups(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id, std::vector<uint32>* group_ids,
       std::vector<std::vector<uint32>>* mc_node_ids) = 0;
 
   // Inserts a clone session ($mirror.cfg table).
   virtual ::util::Status InsertCloneSession(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id, int egress_port, int cos, int max_pkt_len) = 0;
 
   // Modifies a clone session ($mirror.cfg table).
   virtual ::util::Status ModifyCloneSession(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id, int egress_port, int cos, int max_pkt_len) = 0;
 
   // Deletes a clone session ($mirror.cfg table).
   virtual ::util::Status DeleteCloneSession(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id) = 0;
 
   // Returns the clone session with the given ID ($mirror.cfg table), or all
   // sessions if ID is 0.
   virtual ::util::Status GetCloneSessions(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id, std::vector<uint32>* session_ids,
       std::vector<int>* egress_ports, std::vector<int>* coss,
       std::vector<int>* max_pkt_lens) = 0;
 
   // Updates an indirect counter at the given index. The counter ID must be a
-  // BfRt table ID, not P4Runtime.
+  // TdiRt table ID, not P4Runtime.
   // TODO(max): figure out optional counter data API, see TotW#163
   virtual ::util::Status WriteIndirectCounter(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 counter_id, int counter_index, absl::optional<uint64> byte_count,
       absl::optional<uint64> packet_count) = 0;
 
   // Reads the data from an indirect counter. The counter ID must be a
-  // BfRt table ID, not P4Runtime. Timeout specifies the maximum time to wait
+  // TdiRt table ID, not P4Runtime. Timeout specifies the maximum time to wait
   // for the counters to sync.
   // TODO(max): figure out optional counter data API, see TotW#163
   virtual ::util::Status ReadIndirectCounter(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 counter_id, absl::optional<uint32> counter_index,
       std::vector<uint32>* counter_indices,
       std::vector<absl::optional<uint64>>* byte_counts,
@@ -342,92 +381,92 @@ class BfSdeInterface {
       absl::Duration timeout) = 0;
 
   // Updates a register at the given index in a table. The table ID must be a
-  // BfRt table ID, not P4Runtime. Timeout specifies the maximum time to wait
+  // TdiRt table ID, not P4Runtime. Timeout specifies the maximum time to wait
   // for the registers to sync.
   // TODO(max): figure out optional register index API, see TotW#163
   virtual ::util::Status WriteRegister(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> register_index,
       const std::string& register_data) = 0;
 
   // Reads the data from a register in a table, or all registers if index is 0.
-  // The table ID must be a BfRt table ID, not P4Runtime.
+  // The table ID must be a TdiRt table ID, not P4Runtime.
   // TODO(max): figure out optional register index API, see TotW#163
   virtual ::util::Status ReadRegisters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> register_index,
       std::vector<uint32>* register_indices,
       std::vector<uint64>* register_datas, absl::Duration timeout) = 0;
 
   // Updates an indirect meter at the given index. The table ID must be a
-  // BfRt table ID, not P4Runtime.
+  // TdiRt table ID, not P4Runtime.
   // TODO(max): figure out optional register index API, see TotW#163
   virtual ::util::Status WriteIndirectMeter(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> meter_index, bool in_pps,
       uint64 cir, uint64 cburst, uint64 pir, uint64 pburst) = 0;
 
   // Reads the data from an indirect meter, or all meters if index is 0.
-  // The table ID must be a BfRt table ID, not P4Runtime.
+  // The table ID must be a TdiRt table ID, not P4Runtime.
   // TODO(max): figure out optional register index API, see TotW#163
   virtual ::util::Status ReadIndirectMeters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> meter_index,
       std::vector<uint32>* meter_indices, std::vector<uint64>* cirs,
       std::vector<uint64>* cbursts, std::vector<uint64>* pirs,
       std::vector<uint64>* pbursts, std::vector<bool>* in_pps) = 0;
 
-  // Inserts an action profile member. The table ID must be a BfRt table, not
+  // Inserts an action profile member. The table ID must be a TdiRt table, not
   // P4Runtime.
   virtual ::util::Status InsertActionProfileMember(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id, const TableDataInterface* table_data) = 0;
 
-  // Modifies an existing action profile member. The table ID must be a BfRt
+  // Modifies an existing action profile member. The table ID must be a TdiRt
   // table, not P4Runtime.
   virtual ::util::Status ModifyActionProfileMember(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id, const TableDataInterface* table_data) = 0;
 
-  // Deletes an action profile member. The table ID must be a BfRt
+  // Deletes an action profile member. The table ID must be a TdiRt
   // table, not P4Runtime. Returns an error if the member does not exist.
   virtual ::util::Status DeleteActionProfileMember(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id) = 0;
 
   // Returns the action profile member from the given table, or all
   // members if member ID is 0.
   virtual ::util::Status GetActionProfileMembers(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id, std::vector<int>* member_ids,
       std::vector<std::unique_ptr<TableDataInterface>>* table_datas) = 0;
 
-  // Inserts an action profile group. The table ID must be a BfRt table, not
+  // Inserts an action profile group. The table ID must be a TdiRt table, not
   // P4Runtime.
   virtual ::util::Status InsertActionProfileGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id, int max_group_size,
       const std::vector<uint32>& member_ids,
       const std::vector<bool>& member_status) = 0;
 
-  // Modifies an action profile group. The table ID must be a BfRt table, not
+  // Modifies an action profile group. The table ID must be a TdiRt table, not
   // P4Runtime.
   virtual ::util::Status ModifyActionProfileGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id, int max_group_size,
       const std::vector<uint32>& member_ids,
       const std::vector<bool>& member_status) = 0;
 
-  // Deletes an action profile group. The table ID must be a BfRt table, not
+  // Deletes an action profile group. The table ID must be a TdiRt table, not
   // P4Runtime.
   virtual ::util::Status DeleteActionProfileGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id) = 0;
 
   // Returns the action profile group from the given table, or all
   // groups if member ID is 0.
   virtual ::util::Status GetActionProfileGroups(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id, std::vector<int>* group_ids,
       std::vector<int>* max_group_sizes,
       std::vector<std::vector<uint32>>* member_ids,
@@ -436,75 +475,75 @@ class BfSdeInterface {
   // Inserts a new table entry with the given key and data. Fails if the table
   // entry already exists.
   virtual ::util::Status InsertTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key,
       const TableDataInterface* table_data) = 0;
 
   // Modifies an existing table entry with the given key and data. Fails if the
   // table entry does not exists.
   virtual ::util::Status ModifyTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key,
       const TableDataInterface* table_data) = 0;
 
   // Delets an existing table entry with the given key and data. Fails if the
   // table entry does not exists.
   virtual ::util::Status DeleteTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key) = 0;
 
   // Fetches an existing table entry for the given key. Fails if the table entry
   // does not exists.
   virtual ::util::Status GetTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key,
       TableDataInterface* table_data) = 0;
 
   // Fetches all table entries in the given table.
   virtual ::util::Status GetAllTableEntries(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id,
       std::vector<std::unique_ptr<TableKeyInterface>>* table_keys,
       std::vector<std::unique_ptr<TableDataInterface>>* table_datas) = 0;
 
   // Sets the default table entry (action) for a table.
   virtual ::util::Status SetDefaultTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableDataInterface* table_data) = 0;
 
   // Resets the default table entry (action) of a table.
   virtual ::util::Status ResetDefaultTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id) = 0;
 
   // Gets the default table entry (action) of a table.
   virtual ::util::Status GetDefaultTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, TableDataInterface* table_data) = 0;
 
   // Synchronizes the driver cached counter values with the current hardware
-  // state for a given BfRt table.
+  // state for a given TdiRt table.
   virtual ::util::Status SynchronizeCounters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::Duration timeout) = 0;
 
-  // Returns the equivalent BfRt ID for the given P4RT ID.
-  virtual ::util::StatusOr<uint32> GetBfRtId(uint32 p4info_id) const = 0;
+  // Returns the equivalent TdiRt ID for the given P4RT ID.
+  virtual ::util::StatusOr<uint32> GetTdiRtId(uint32 p4info_id) const = 0;
 
-  // Returns the equivalent P4RT ID for the given BfRt ID.
+  // Returns the equivalent P4RT ID for the given TdiRt ID.
   virtual ::util::StatusOr<uint32> GetP4InfoId(uint32 bfrt_id) const = 0;
 
   // Gets the action selector ID of an action profile.
-  virtual ::util::StatusOr<uint32> GetActionSelectorBfRtId(
+  virtual ::util::StatusOr<uint32> GetActionSelectorTdiRtId(
       uint32 action_profile_id) const = 0;
 
   // Gets the action profile ID of an action selector.
-  virtual ::util::StatusOr<uint32> GetActionProfileBfRtId(
+  virtual ::util::StatusOr<uint32> GetActionProfileTdiRtId(
       uint32 action_selector_id) const = 0;
 
  protected:
   // Default constructor. To be called by the Mock class instance only.
-  BfSdeInterface() {}
+  TdiSdeInterface() {}
 };
 
 }  // namespace barefoot
diff --git a/stratum/hal/lib/barefoot/bf_sde_mock.h b/stratum/hal/lib/barefoot/bf_sde_mock.h
index 4afa1532..d2e70214 100644
--- a/stratum/hal/lib/barefoot/bf_sde_mock.h
+++ b/stratum/hal/lib/barefoot/bf_sde_mock.h
@@ -11,7 +11,7 @@
 #include "gmock/gmock.h"
 #include "stratum/hal/lib/barefoot/bf_sde_interface.h"
 
-DEFINE_bool(incompatible_enable_bfrt_legacy_bytestring_responses, true,
+DEFINE_bool(incompatible_enable_tdirt_legacy_bytestring_responses, true,
             "Enables the legacy padded byte string format in P4Runtime "
             "responses for Stratum-bfrt. The strings are left unchanged from "
             "the underlying SDE.");
@@ -20,13 +20,13 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class SessionMock : public BfSdeInterface::SessionInterface {
+class SessionMock : public TdiSdeInterface::SessionInterface {
  public:
   MOCK_METHOD0(BeginBatch, ::util::Status());
   MOCK_METHOD0(EndBatch, ::util::Status());
 };
 
-class TableKeyMock : public BfSdeInterface::TableKeyInterface {
+class TableKeyMock : public TdiSdeInterface::TableKeyInterface {
  public:
   MOCK_METHOD2(SetExact, ::util::Status(int id, const std::string& value));
   MOCK_CONST_METHOD2(GetExact, ::util::Status(int id, std::string* value));
@@ -46,7 +46,7 @@ class TableKeyMock : public BfSdeInterface::TableKeyInterface {
   MOCK_CONST_METHOD1(GetPriority, ::util::Status(uint32* priority));
 };
 
-class TableDataMock : public BfSdeInterface::TableDataInterface {
+class TableDataMock : public TdiSdeInterface::TableDataInterface {
  public:
   MOCK_METHOD2(SetParam, ::util::Status(int id, const std::string& value));
   MOCK_CONST_METHOD2(GetParam, ::util::Status(int id, std::string* value));
@@ -63,7 +63,7 @@ class TableDataMock : public BfSdeInterface::TableDataInterface {
   MOCK_METHOD1(Reset, ::util::Status(int action_id));
 };
 
-class BfSdeMock : public BfSdeInterface {
+class BfSdeMock : public TdiSdeInterface {
  public:
   MOCK_METHOD3(InitializeSde,
                ::util::Status(const std::string& sde_install_path,
@@ -71,7 +71,7 @@ class BfSdeMock : public BfSdeInterface {
                               bool run_in_background));
   MOCK_METHOD2(AddDevice,
                ::util::Status(int device,
-                              const BfrtDeviceConfig& device_config));
+                              const TdirtDeviceConfig& device_config));
   MOCK_METHOD0(CreateSession,
                ::util::StatusOr<std::shared_ptr<SessionInterface>>());
   MOCK_METHOD2(GetPortState, ::util::StatusOr<PortState>(int device, int port));
@@ -118,29 +118,29 @@ class BfSdeMock : public BfSdeInterface {
   MOCK_METHOD5(CreateMulticastNode,
                ::util::StatusOr<uint32>(
                    int device,
-                   std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                   std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                    int mc_replication_id, const std::vector<uint32>& mc_lag_ids,
                    const std::vector<uint32>& ports));
   MOCK_METHOD3(
       DeleteMulticastNodes,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      const std::vector<uint32>& mc_node_ids));
   MOCK_METHOD6(
       GetMulticastNode,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 mc_node_id, int* replication_id,
                      std::vector<uint32>* lag_ids, std::vector<uint32>* ports));
   MOCK_METHOD4(
       InsertMulticastGroup,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 group_id, const std::vector<uint32>& mc_node_ids));
   MOCK_METHOD4(
       ModifyMulticastGroup,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 group_id, const std::vector<uint32>& mc_node_ids));
   MOCK_METHOD3(DeleteMulticastGroup,
                ::util::Status(int device,
@@ -149,49 +149,49 @@ class BfSdeMock : public BfSdeInterface {
   MOCK_METHOD5(
       GetMulticastGroups,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 group_id, std::vector<uint32>* group_ids,
                      std::vector<std::vector<uint32>>* mc_node_ids));
   MOCK_METHOD6(
       InsertCloneSession,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 session_id, int egress_port, int cos,
                      int max_pkt_len));
   MOCK_METHOD6(
       ModifyCloneSession,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 session_id, int egress_port, int cos,
                      int max_pkt_len));
   MOCK_METHOD3(GetNodesInMulticastGroup,
                ::util::StatusOr<std::vector<uint32>>(
                    int device,
-                   std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                   std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                    uint32 group_id));
   MOCK_METHOD3(
       DeleteCloneSession,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 session_id));
   MOCK_METHOD7(
       GetCloneSessions,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 session_id, std::vector<uint32>* session_ids,
                      std::vector<int>* egress_ports, std::vector<int>* coss,
                      std::vector<int>* max_pkt_lens));
   MOCK_METHOD6(
       WriteIndirectCounter,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 counter_id, int counter_index,
                      absl::optional<uint64> byte_count,
                      absl::optional<uint64> packet_count));
   MOCK_METHOD8(
       ReadIndirectCounter,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 counter_id, absl::optional<uint32> counter_index,
                      std::vector<uint32>* counter_indices,
                      std::vector<absl::optional<uint64>>* byte_counts,
@@ -200,13 +200,13 @@ class BfSdeMock : public BfSdeInterface {
   MOCK_METHOD5(
       WriteRegister,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, absl::optional<uint32> register_index,
                      const std::string& register_data));
   MOCK_METHOD7(
       ReadRegisters,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, absl::optional<uint32> register_index,
                      std::vector<uint32>* register_indices,
                      std::vector<uint64>* register_datas,
@@ -214,14 +214,14 @@ class BfSdeMock : public BfSdeInterface {
   MOCK_METHOD9(
       WriteIndirectMeter,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, absl::optional<uint32> meter_index,
                      bool in_pps, uint64 cir, uint64 cburst, uint64 pir,
                      uint64 pburst));
   MOCK_METHOD10(
       ReadIndirectMeters,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, absl::optional<uint32> meter_index,
                      std::vector<uint32>* meter_indices,
                      std::vector<uint64>* cirs, std::vector<uint64>* cbursts,
@@ -230,49 +230,49 @@ class BfSdeMock : public BfSdeInterface {
   MOCK_METHOD5(
       InsertActionProfileMember,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, int member_id,
                      const TableDataInterface* table_data));
   MOCK_METHOD5(
       ModifyActionProfileMember,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, int member_id,
                      const TableDataInterface* table_data));
   MOCK_METHOD4(
       DeleteActionProfileMember,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, int member_id));
   MOCK_METHOD6(
       GetActionProfileMembers,
       ::util::Status(
-          int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+          int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
           uint32 table_id, int member_id, std::vector<int>* member_ids,
           std::vector<std::unique_ptr<TableDataInterface>>* table_datas));
   MOCK_METHOD7(
       InsertActionProfileGroup,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, int group_id, int max_group_size,
                      const std::vector<uint32>& member_ids,
                      const std::vector<bool>& member_status));
   MOCK_METHOD7(
       ModifyActionProfileGroup,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, int group_id, int max_group_size,
                      const std::vector<uint32>& member_ids,
                      const std::vector<bool>& member_status));
   MOCK_METHOD4(
       DeleteActionProfileGroup,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, int group_id));
   MOCK_METHOD8(
       GetActionProfileGroups,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, int group_id, std::vector<int>* group_ids,
                      std::vector<int>* max_group_sizes,
                      std::vector<std::vector<uint32>>* member_ids,
@@ -286,58 +286,58 @@ class BfSdeMock : public BfSdeInterface {
   MOCK_METHOD5(
       InsertTableEntry,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, const TableKeyInterface* table_key,
                      const TableDataInterface* table_data));
   MOCK_METHOD5(
       ModifyTableEntry,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, const TableKeyInterface* table_key,
                      const TableDataInterface* table_data));
   MOCK_METHOD4(
       DeleteTableEntry,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, const TableKeyInterface* table_key));
   MOCK_METHOD5(
       GetTableEntry,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, const TableKeyInterface* table_key,
                      TableDataInterface* table_data));
   MOCK_METHOD5(
       GetAllTableEntries,
       ::util::Status(
-          int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+          int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
           uint32 table_id,
           std::vector<std::unique_ptr<TableKeyInterface>>* table_keys,
           std::vector<std::unique_ptr<TableDataInterface>>* table_datas));
   MOCK_METHOD4(
       SetDefaultTableEntry,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, const TableDataInterface* table_data));
   MOCK_METHOD3(
       ResetDefaultTableEntry,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id));
   MOCK_METHOD4(
       GetDefaultTableEntry,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, TableDataInterface* table_data));
   MOCK_METHOD4(
       SynchronizeCounters,
       ::util::Status(int device,
-                     std::shared_ptr<BfSdeInterface::SessionInterface> session,
+                     std::shared_ptr<TdiSdeInterface::SessionInterface> session,
                      uint32 table_id, absl::Duration timeout));
-  MOCK_CONST_METHOD1(GetBfRtId, ::util::StatusOr<uint32>(uint32 p4info_id));
+  MOCK_CONST_METHOD1(GetTdiRtId, ::util::StatusOr<uint32>(uint32 p4info_id));
   MOCK_CONST_METHOD1(GetP4InfoId, ::util::StatusOr<uint32>(uint32 bfrt_id));
-  MOCK_CONST_METHOD1(GetActionSelectorBfRtId,
+  MOCK_CONST_METHOD1(GetActionSelectorTdiRtId,
                      ::util::StatusOr<uint32>(uint32 action_profile_id));
-  MOCK_CONST_METHOD1(GetActionProfileBfRtId,
+  MOCK_CONST_METHOD1(GetActionProfileTdiRtId,
                      ::util::StatusOr<uint32>(uint32 action_selector_id));
 };
 
diff --git a/stratum/hal/lib/barefoot/bf_sde_wrapper.cc b/stratum/hal/lib/barefoot/bf_sde_wrapper.cc
index 9f4bb3a9..901990a6 100644
--- a/stratum/hal/lib/barefoot/bf_sde_wrapper.cc
+++ b/stratum/hal/lib/barefoot/bf_sde_wrapper.cc
@@ -11,8 +11,10 @@
 #include "absl/synchronization/mutex.h"
 #include "absl/synchronization/notification.h"
 #include "absl/time/time.h"
-#include "bf_rt/bf_rt_table_operations.hpp"
+#ifdef P4SDE_DPDK_TARGET_STUB
 #include "lld/lld_sku.h"
+#endif
+
 #include "stratum/glue/gtl/cleanup.h"
 #include "stratum/glue/gtl/map_util.h"
 #include "stratum/glue/gtl/stl_util.h"
@@ -30,21 +32,33 @@
 #include "stratum/lib/utils.h"
 
 extern "C" {
-#include "bf_switchd/bf_switchd.h"
-#include "tofino/bf_pal/bf_pal_port_intf.h"
-#include "tofino/bf_pal/dev_intf.h"
+#include "bf_switchd/lib/bf_switchd_lib_init.h"
+#include "bf_pal/bf_pal_port_intf.h"
+#include "bf_pal/dev_intf.h"
+#ifdef P4SDE_DPDK_TARGET_STUB
+#include "tofino/bf_pal/pltfm_intf.h"
+#include "tofino/pdfixed/pd_devport_mgr.h"
+#include "pdfixed/pd_tm.h"
+#endif
+#ifdef P4SDE_DPDK_TARGET_STUB
 #include "tofino/bf_pal/pltfm_intf.h"
 #include "tofino/pdfixed/pd_devport_mgr.h"
-#include "tofino/pdfixed/pd_tm.h"
+#include "pdfixed/pd_tm.h"
+#endif
 // Flag to enable detailed logging in the SDE pipe manager.
+#ifdef P4SDE_DPDK_TARGET_STUB
 extern bool stat_mgr_enable_detail_trace;
+#endif //P4SDE_DPDK_TARGET_STUB
 // Get the /sys fs file name of the first Tofino ASIC.
 int switch_pci_sysfs_str_get(char* name, size_t name_size);
 }
 
-DEFINE_string(bfrt_sde_config_dir, "/var/run/stratum/bfrt_config",
+/* Newly Defined Macros */
+#define MAX_PORT_HDL_STRING_LEN 100
+
+DEFINE_string(tdirt_sde_config_dir, "/var/run/stratum/tdirt_config",
               "The dir used by the SDE to load the device configuration.");
-DEFINE_bool(incompatible_enable_bfrt_legacy_bytestring_responses, true,
+DEFINE_bool(incompatible_enable_tdirt_legacy_bytestring_responses, true,
             "Enables the legacy padded byte string format in P4Runtime "
             "responses for Stratum-bfrt. The strings are left unchanged from "
             "the underlying SDE.");
@@ -53,8 +67,8 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-constexpr absl::Duration BfSdeWrapper::kWriteTimeout;
-constexpr int32 BfSdeWrapper::kBfDefaultMtu;
+constexpr absl::Duration TdiSdeWrapper::kWriteTimeout;
+constexpr int32 TdiSdeWrapper::kBfDefaultMtu;
 constexpr int _PI_UPDATE_MAX_NAME_SIZE = 100;
 
 // Helper functions for dealing with the SDE API.
@@ -69,72 +83,86 @@ inline constexpr uint64 BytesPerSecondToKbits(uint64 bytes) {
   return bytes / 125;
 }
 
-::util::StatusOr<std::string> DumpTableMetadata(const bfrt::BfRtTable* table) {
-  std::string table_name;
-  RETURN_IF_BFRT_ERROR(table->tableNameGet(&table_name));
-  bf_rt_id_t table_id;
-  RETURN_IF_BFRT_ERROR(table->tableIdGet(&table_id));
-  bfrt::BfRtTable::TableType table_type;
-  RETURN_IF_BFRT_ERROR(table->tableTypeGet(&table_type));
+::util::StatusOr<std::string> DumpTableMetadata(const tdi::Table* table) {
+  std::string table_name = table->tableInfoGet()->nameGet().c_str();
+  tdi_id_t table_id = table->tableInfoGet()->idGet();
+  tdi_table_type_e table_type = table->tableInfoGet()->tableTypeGet();
 
   return absl::StrCat("table_name: ", table_name, ", table_id: ", table_id,
                       ", table_type: ", table_type);
 }
 
 ::util::StatusOr<std::string> DumpTableKey(
-    const bfrt::BfRtTableKey* table_key) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key->tableGet(&table));
-  std::vector<bf_rt_id_t> key_field_ids;
-  RETURN_IF_BFRT_ERROR(table->keyFieldIdListGet(&key_field_ids));
+    const tdi::TableKey* table_key) {
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key->tableGet(&table));
+  std::vector<tdi_id_t> key_field_ids;
+  key_field_ids = table->tableInfoGet()->keyFieldIdListGet();
 
   std::string s;
-  absl::StrAppend(&s, "bfrt_table_key { ");
+  absl::StrAppend(&s, "tdi_table_key { ");
   for (const auto& field_id : key_field_ids) {
+    const tdi::KeyFieldInfo *keyFieldInfo = table->tableInfoGet()->keyFieldGet(field_id);
     std::string field_name;
-    bfrt::KeyFieldType key_type;
+    tdi_match_type_core_e key_type;
     size_t field_size;
-    RETURN_IF_BFRT_ERROR(table->keyFieldNameGet(field_id, &field_name));
-    RETURN_IF_BFRT_ERROR(table->keyFieldTypeGet(field_id, &key_type));
-    RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(field_id, &field_size));
 
+    RETURN_IF_NULL(keyFieldInfo);
+    field_name = keyFieldInfo->nameGet().c_str();
+    key_type = static_cast<tdi_match_type_core_e>((*keyFieldInfo).matchTypeGet());
+    field_size = keyFieldInfo->sizeGet();
     std::string value;
+
     switch (key_type) {
-      case bfrt::KeyFieldType::EXACT: {
+      case TDI_MATCH_TYPE_EXACT: {
         std::string v(NumBitsToNumBytes(field_size), '\x00');
-        RETURN_IF_BFRT_ERROR(table_key->getValue(
-            field_id, v.size(),
-            reinterpret_cast<uint8*>(gtl::string_as_array(&v))));
+        const char *valueExact = reinterpret_cast<const char *>(v.data());
+        size_t size = reinterpret_cast<size_t>(v.size());
+
+        tdi::KeyFieldValueExact<const char *> exactKey(valueExact, size);
+        RETURN_IF_TDI_ERROR(table_key->getValue(field_id,
+                      &exactKey));
         value = absl::StrCat("0x", StringToHex(v));
         break;
       }
-      case bfrt::KeyFieldType::TERNARY: {
+
+      case TDI_MATCH_TYPE_TERNARY: {
         std::string v(NumBitsToNumBytes(field_size), '\x00');
         std::string m(NumBitsToNumBytes(field_size), '\x00');
-        RETURN_IF_BFRT_ERROR(table_key->getValueandMask(
-            field_id, v.size(),
-            reinterpret_cast<uint8*>(gtl::string_as_array(&v)),
-            reinterpret_cast<uint8*>(gtl::string_as_array(&m))));
+        const char *valueTernary = reinterpret_cast<const char *>(v.data());
+        const char *maskTernary = reinterpret_cast<const char *>(m.data());
+        size_t sizeTernary = reinterpret_cast<size_t>(v.size());
+        tdi::KeyFieldValueTernary<const char *> ternaryKey(valueTernary, maskTernary,
+                                                  sizeTernary);
+
+        RETURN_IF_TDI_ERROR(table_key->getValue(field_id,
+                                                &ternaryKey));
         value = absl::StrCat("0x", StringToHex(v), " & ", "0x", StringToHex(m));
         break;
       }
-      case bfrt::KeyFieldType::RANGE: {
+
+      case TDI_MATCH_TYPE_RANGE: {
         std::string l(NumBitsToNumBytes(field_size), '\x00');
         std::string h(NumBitsToNumBytes(field_size), '\x00');
-        RETURN_IF_BFRT_ERROR(table_key->getValueRange(
-            field_id, l.size(),
-            reinterpret_cast<uint8*>(gtl::string_as_array(&l)),
-            reinterpret_cast<uint8*>(gtl::string_as_array(&h))));
+        const char *lowRange =  reinterpret_cast<const char *>(l.data());
+        const char *highRange =  reinterpret_cast<const char *>(h.data());
+        size_t sizeRange = reinterpret_cast<size_t>(l.size());
+        tdi::KeyFieldValueRange<const char*> rangeKey(lowRange, highRange, sizeRange);
+        RETURN_IF_TDI_ERROR(table_key->getValue(field_id,
+                                                &rangeKey));
         value = absl::StrCat("0x", StringToHex(l), " - ", "0x", StringToHex(h));
         break;
       }
-      case bfrt::KeyFieldType::LPM: {
+
+      case TDI_MATCH_TYPE_LPM: {
         std::string v(NumBitsToNumBytes(field_size), '\x00');
-        uint16 p;
-        RETURN_IF_BFRT_ERROR(table_key->getValueLpm(
-            field_id, v.size(),
-            reinterpret_cast<uint8*>(gtl::string_as_array(&v)), &p));
-        value = absl::StrCat("0x", StringToHex(v), "/", p);
+        uint16 prefix_length;
+        const char *valueLpm =  reinterpret_cast<const char *>(v.data());
+        size_t sizeLpm = reinterpret_cast<size_t>(v.size());
+        tdi::KeyFieldValueLPM<const char *> lpmKey(valueLpm, prefix_length, sizeLpm);
+        RETURN_IF_TDI_ERROR(table_key->getValue(field_id,
+                                                 &lpmKey));
+        value = absl::StrCat("0x", StringToHex(v), "/", prefix_length);
         break;
       }
       default:
@@ -147,75 +175,63 @@ inline constexpr uint64 BytesPerSecondToKbits(uint64 bytes) {
                     " field_size: ", field_size, " value: ", value, " } ");
   }
   absl::StrAppend(&s, "}");
-
   return s;
 }
 
 ::util::StatusOr<std::string> DumpTableData(
-    const bfrt::BfRtTableData* table_data) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data->getParent(&table));
+    const tdi::TableData* table_data) {
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_data->getParent(&table));
 
   std::string s;
-  absl::StrAppend(&s, "bfrt_table_data { ");
-  std::vector<bf_rt_id_t> data_field_ids;
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data->actionIdGet(&action_id));
-    absl::StrAppend(&s, "action_id: ", action_id, " ");
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdListGet(action_id, &data_field_ids));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdListGet(&data_field_ids));
-  }
+  absl::StrAppend(&s, "tdi_table_data { ");
+  std::vector<tdi_id_t> data_field_ids;
+
+  tdi_id_t action_id = table_data->actionIdGet();
+  absl::StrAppend(&s, "action_id: ", action_id, " ");
+  data_field_ids = table->tableInfoGet()->dataFieldIdListGet(action_id);
 
   for (const auto& field_id : data_field_ids) {
     std::string field_name;
-    bfrt::DataType data_type;
+    tdi_field_data_type_e data_type;
     size_t field_size;
     bool is_active;
-    if (table->actionIdApplicable()) {
-      bf_rt_id_t action_id;
-      RETURN_IF_BFRT_ERROR(table_data->actionIdGet(&action_id));
-      RETURN_IF_BFRT_ERROR(
-          table->dataFieldNameGet(field_id, action_id, &field_name));
-      RETURN_IF_BFRT_ERROR(
-          table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-      RETURN_IF_BFRT_ERROR(
-          table->dataFieldSizeGet(field_id, action_id, &field_size));
-    } else {
-      RETURN_IF_BFRT_ERROR(table->dataFieldNameGet(field_id, &field_name));
-      RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-      RETURN_IF_BFRT_ERROR(table->dataFieldSizeGet(field_id, &field_size));
-    }
-    RETURN_IF_BFRT_ERROR(table_data->isActive(field_id, &is_active));
+    const tdi::DataFieldInfo *dataFieldInfo;
+    dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_id, action_id);
+    RETURN_IF_NULL(dataFieldInfo);
+
+    field_name = dataFieldInfo->nameGet().c_str();
+    data_type = dataFieldInfo->dataTypeGet();
+    field_size = dataFieldInfo->sizeGet();
+    RETURN_IF_TDI_ERROR(table_data->isActive(field_id, &is_active));
 
     std::string value;
     switch (data_type) {
-      case bfrt::DataType::UINT64: {
+      case TDI_FIELD_DATA_TYPE_UINT64: {
         uint64 v;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &v));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &v));
         value = std::to_string(v);
         break;
       }
-      case bfrt::DataType::BYTE_STREAM: {
+      case TDI_FIELD_DATA_TYPE_BYTE_STREAM: {
         std::string v(NumBitsToNumBytes(field_size), '\x00');
-        RETURN_IF_BFRT_ERROR(table_data->getValue(
+        RETURN_IF_TDI_ERROR(table_data->getValue(
             field_id, v.size(),
             reinterpret_cast<uint8*>(gtl::string_as_array(&v))));
         value = absl::StrCat("0x", StringToHex(v));
         break;
       }
-      case bfrt::DataType::INT_ARR: {
+      case TDI_FIELD_DATA_TYPE_INT_ARR: {
         // TODO(max): uint32 seems to be the most common type, but we could
         // differentiate based on field_size, if needed.
         std::vector<uint32_t> v;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &v));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &v));
         value = PrintVector(v, ",");
         break;
       }
-      case bfrt::DataType::BOOL_ARR: {
+      case TDI_FIELD_DATA_TYPE_BOOL_ARR: {
         std::vector<bool> bools;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &bools));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &bools));
         std::vector<uint16> bools_as_ints;
         for (bool b : bools) {
           bools_as_ints.push_back(b);
@@ -238,267 +254,280 @@ inline constexpr uint64 BytesPerSecondToKbits(uint64 bytes) {
   return s;
 }
 
-::util::Status GetField(const bfrt::BfRtTableKey& table_key,
-                        std::string field_name, uint64* field_value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_key.tableGet(&table));
-  RETURN_IF_BFRT_ERROR(table->keyFieldIdGet(field_name, &field_id));
-  RETURN_IF_BFRT_ERROR(table->keyFieldDataTypeGet(field_id, &data_type));
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::UINT64)
+::util::Status GetFieldExact(const tdi::TableKey& table_key,
+                             std::string field_name,
+                             uint32_t *field_value) {
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  RETURN_IF_TDI_ERROR(table_key.tableGet(&table));
+  tdi::KeyFieldValueExact <uint64_t> key_field_value(*field_value);
+  const tdi::KeyFieldInfo *keyFieldInfo = table->tableInfoGet()->keyFieldGet(field_name);
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_id = keyFieldInfo->idGet();
+  data_type = keyFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_UINT64)
       << "Requested uint64 but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_key.getValue(field_id, field_value));
+
+  RETURN_IF_TDI_ERROR(table_key.getValue(field_id, &key_field_value));
+
+  *field_value = key_field_value.value_;
 
   return ::util::OkStatus();
 }
 
-::util::Status SetField(bfrt::BfRtTableKey* table_key, std::string field_name,
-                        uint64 value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_key->tableGet(&table));
-  RETURN_IF_BFRT_ERROR(table->keyFieldIdGet(field_name, &field_id));
-  RETURN_IF_BFRT_ERROR(table->keyFieldDataTypeGet(field_id, &data_type));
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::UINT64)
+::util::Status SetFieldExact(tdi::TableKey* table_key,
+                             std::string field_name,
+                             uint64 field_value) {
+  tdi::KeyFieldValueExact <uint64_t> key_field_value(field_value);
+  const tdi::Table* table;
+  tdi_id_t field_id;
+  tdi_field_data_type_e data_type;
+  RETURN_IF_TDI_ERROR(table_key->tableGet(&table));
+  const tdi::KeyFieldInfo *keyFieldInfo = table->tableInfoGet()->keyFieldGet(field_name);
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_id = keyFieldInfo->idGet();
+  data_type = keyFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_UINT64)
       << "Setting uint64 but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_key->setValue(field_id, value));
+  RETURN_IF_TDI_ERROR(table_key->setValue(field_id, key_field_value));
+  return ::util::OkStatus();
+}
+
+::util::Status SetField(tdi::TableKey* table_key, std::string field_name,
+                        tdi::KeyFieldValue value) {
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  RETURN_IF_TDI_ERROR(table_key->tableGet(&table));
+  const tdi::KeyFieldInfo *keyFieldInfo = table->tableInfoGet()->keyFieldGet(field_name);
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_id = keyFieldInfo->idGet();
+  data_type = keyFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_UINT64)
+      << "Setting uint64 but field " << field_name << " has type "
+      << static_cast<int>(data_type);
+  RETURN_IF_TDI_ERROR(table_key->setValue(field_id, value));
 
   return ::util::OkStatus();
 }
 
-::util::Status GetField(const bfrt::BfRtTableData& table_data,
+::util::Status GetField(const tdi::TableData& table_data,
                         std::string field_name, uint64* field_value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data.getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data.actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::UINT64)
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data.getParent(&table));
+
+  tdi_id_t action_id = table_data.actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_UINT64)
       << "Requested uint64 but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data.getValue(field_id, field_value));
+  RETURN_IF_TDI_ERROR(table_data.getValue(field_id, field_value));
 
   return ::util::OkStatus();
 }
 
-::util::Status GetField(const bfrt::BfRtTableData& table_data,
+::util::Status GetField(const tdi::TableData& table_data,
                         std::string field_name, std::string* field_value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data.getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data.actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::STRING)
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data.getParent(&table));
+
+  tdi_id_t action_id = table_data.actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_STRING)
       << "Requested string but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data.getValue(field_id, field_value));
+  RETURN_IF_TDI_ERROR(table_data.getValue(field_id, field_value));
 
   return ::util::OkStatus();
 }
 
-::util::Status GetField(const bfrt::BfRtTableData& table_data,
+::util::Status GetFieldBool(const tdi::TableData& table_data,
                         std::string field_name, bool* field_value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data.getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data.actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::BOOL)
+
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data.getParent(&table));
+
+  tdi_id_t action_id = table_data.actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_BOOL)
       << "Requested bool but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data.getValue(field_id, field_value));
+  RETURN_IF_TDI_ERROR(table_data.getValue(field_id, field_value));
 
   return ::util::OkStatus();
 }
 
 template <typename T>
-::util::Status GetField(const bfrt::BfRtTableData& table_data,
+::util::Status GetField(const tdi::TableData& table_data,
                         std::string field_name, std::vector<T>* field_values) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data.getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data.actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::INT_ARR ||
-                        data_type == bfrt::DataType::BOOL_ARR)
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data.getParent(&table));
+
+  tdi_id_t action_id = table_data.actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_INT_ARR ||
+                        data_type == TDI_FIELD_DATA_TYPE_BOOL_ARR)
       << "Requested array but field has type " << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data.getValue(field_id, field_values));
+  RETURN_IF_TDI_ERROR(table_data.getValue(field_id, field_values));
 
   return ::util::OkStatus();
 }
 
-::util::Status SetField(bfrt::BfRtTableData* table_data, std::string field_name,
+::util::Status SetField(tdi::TableData* table_data, std::string field_name,
                         const uint64& value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data->getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data->actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::UINT64)
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data->getParent(&table));
+
+  tdi_id_t action_id = table_data->actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_UINT64)
       << "Setting uint64 but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data->setValue(field_id, value));
+  RETURN_IF_TDI_ERROR(table_data->setValue(field_id, value));
 
   return ::util::OkStatus();
 }
 
-::util::Status SetField(bfrt::BfRtTableData* table_data, std::string field_name,
+::util::Status SetField(tdi::TableData* table_data, std::string field_name,
                         const std::string& field_value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data->getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data->actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::STRING)
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data->getParent(&table));
+
+  tdi_id_t action_id = table_data->actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_STRING)
       << "Setting string but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data->setValue(field_id, field_value));
+  RETURN_IF_TDI_ERROR(table_data->setValue(field_id, field_value));
 
   return ::util::OkStatus();
 }
 
-::util::Status SetFieldBool(bfrt::BfRtTableData* table_data,
+::util::Status SetFieldBool(tdi::TableData* table_data,
                             std::string field_name, const bool& field_value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data->getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data->actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::BOOL)
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data->getParent(&table));
+
+  tdi_id_t action_id = table_data->actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_BOOL)
       << "Setting bool but field " << field_name << " has type "
       << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data->setValue(field_id, field_value));
+  RETURN_IF_TDI_ERROR(table_data->setValue(field_id, field_value));
 
   return ::util::OkStatus();
 }
 
 template <typename T>
-::util::Status SetField(bfrt::BfRtTableData* table_data, std::string field_name,
-                        const std::vector<T>& value) {
-  bf_rt_id_t field_id;
-  const bfrt::BfRtTable* table;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table_data->getParent(&table));
-  if (table->actionIdApplicable()) {
-    bf_rt_id_t action_id;
-    RETURN_IF_BFRT_ERROR(table_data->actionIdGet(&action_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldIdGet(field_name, action_id, &field_id));
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldDataTypeGet(field_id, action_id, &data_type));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(field_name, &field_id));
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  }
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::INT_ARR ||
-                        data_type == bfrt::DataType::BOOL_ARR)
+::util::Status SetField(tdi::TableData* table_data, std::string field_name,
+                        const std::vector<T>& field_value) {
+
+  tdi_id_t field_id;
+  const tdi::Table* table;
+  tdi_field_data_type_e data_type;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  RETURN_IF_TDI_ERROR(table_data->getParent(&table));
+
+  tdi_id_t action_id = table_data->actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_name, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_id = dataFieldInfo->idGet();
+  data_type = dataFieldInfo->dataTypeGet();
+  CHECK_RETURN_IF_FALSE(data_type == TDI_FIELD_DATA_TYPE_INT_ARR ||
+                        data_type == TDI_FIELD_DATA_TYPE_BOOL_ARR)
       << "Requested array but field has type " << static_cast<int>(data_type);
-  RETURN_IF_BFRT_ERROR(table_data->setValue(field_id, value));
+  RETURN_IF_TDI_ERROR(table_data->setValue(field_id, field_value));
 
   return ::util::OkStatus();
 }
 
 ::util::Status GetAllEntries(
-    std::shared_ptr<bfrt::BfRtSession> bfrt_session,
-    bf_rt_target_t bf_dev_target, const bfrt::BfRtTable* table,
-    std::vector<std::unique_ptr<bfrt::BfRtTableKey>>* table_keys,
-    std::vector<std::unique_ptr<bfrt::BfRtTableData>>* table_datums) {
+    std::shared_ptr<tdi::Session> tdirt_session,
+    tdi::Target tdi_dev_target, const tdi::Table* table,
+    std::vector<std::unique_ptr<tdi::TableKey>>* table_keys,
+    std::vector<std::unique_ptr<tdi::TableData>>* table_datums) {
   CHECK_RETURN_IF_FALSE(table_keys) << "table_keys is null";
   CHECK_RETURN_IF_FALSE(table_datums) << "table_datums is null";
 
   // Get number of entries. Some types of tables are preallocated and are always
   // "full". The SDE does not support querying the usage on these.
-  uint32 entries;
-  bfrt::BfRtTable::TableType table_type;
-  RETURN_IF_BFRT_ERROR(table->tableTypeGet(&table_type));
-  if (table_type == bfrt::BfRtTable::TableType::METER ||
-      table_type == bfrt::BfRtTable::TableType::COUNTER) {
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(0, &device);
+  tdi::Flags *flags = new tdi::Flags(0);
+  uint32 entries = 0;
+  auto table_type = static_cast<tdi_rt_table_type_e>(table->tableInfoGet()->tableTypeGet());
+  if (table_type == TDI_RT_TABLE_TYPE_COUNTER ||
+      table_type == TDI_RT_TABLE_TYPE_METER) {
     size_t table_size;
 #if defined(SDE_9_4_0) || defined(SDE_9_5_0)
-    RETURN_IF_BFRT_ERROR(
-        table->tableSizeGet(*bfrt_session, bf_dev_target, &table_size));
+    RETURN_IF_TDI_ERROR(
+        table->sizeGet(*tdirt_session, tdi_dev_target, *flags, &table_size));
 #else
-    RETURN_IF_BFRT_ERROR(table->tableSizeGet(&table_size));
+    RETURN_IF_TDI_ERROR(table->tableSizeGet(&table_size));
 #endif  // SDE_9_4_0
     entries = table_size;
   } else {
-    RETURN_IF_BFRT_ERROR(table->tableUsageGet(
-        *bfrt_session, bf_dev_target,
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, &entries));
+    RETURN_IF_TDI_ERROR(table->usageGet(
+        *tdirt_session, tdi_dev_target,
+        *flags, &entries));
   }
 
   table_keys->resize(0);
@@ -507,13 +536,13 @@ template <typename T>
 
   // Get first entry.
   {
-    std::unique_ptr<bfrt::BfRtTableKey> table_key;
-    std::unique_ptr<bfrt::BfRtTableData> table_data;
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGetFirst(
-        *bfrt_session, bf_dev_target,
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, table_key.get(),
+    std::unique_ptr<tdi::TableKey> table_key;
+    std::unique_ptr<tdi::TableData> table_data;
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
+    RETURN_IF_TDI_ERROR(table->entryGetFirst(
+        *tdirt_session, tdi_dev_target,
+        *flags, table_key.get(),
         table_data.get()));
 
     table_keys->push_back(std::move(table_key));
@@ -523,18 +552,18 @@ template <typename T>
 
   // Get all entries following the first.
   {
-    std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys(entries - 1);
-    std::vector<std::unique_ptr<bfrt::BfRtTableData>> data(keys.size());
-    bfrt::BfRtTable::keyDataPairs pairs;
+    std::vector<std::unique_ptr<tdi::TableKey>> keys(entries - 1);
+    std::vector<std::unique_ptr<tdi::TableData>> data(keys.size());
+    tdi::Table::keyDataPairs pairs;
     for (size_t i = 0; i < keys.size(); ++i) {
-      RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[i]));
-      RETURN_IF_BFRT_ERROR(table->dataAllocate(&data[i]));
+      RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[i]));
+      RETURN_IF_TDI_ERROR(table->dataAllocate(&data[i]));
       pairs.push_back(std::make_pair(keys[i].get(), data[i].get()));
     }
     uint32 actual = 0;
-    RETURN_IF_BFRT_ERROR(table->tableEntryGetNext_n(
-        *bfrt_session, bf_dev_target, *(*table_keys)[0], pairs.size(),
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, &pairs, &actual));
+    RETURN_IF_TDI_ERROR(table->entryGetNextN(
+        *tdirt_session, tdi_dev_target, *flags, *(*table_keys)[0], pairs.size(),
+        &pairs, &actual));
 
     table_keys->insert(table_keys->end(), std::make_move_iterator(keys.begin()),
                        std::make_move_iterator(keys.end()));
@@ -552,90 +581,127 @@ template <typename T>
 }  // namespace
 
 ::util::Status TableKey::SetExact(int id, const std::string& value) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   std::string v = P4RuntimeByteStringToPaddedByteString(
       value, NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_key_->setValue(
-      id, reinterpret_cast<const uint8*>(v.data()), v.size()));
+
+  const char *valueExact = reinterpret_cast<const char *>(v.data());
+  size_t size = reinterpret_cast<size_t>(v.size());
+
+  tdi::KeyFieldValueExact<const char *> exactKey(valueExact, size);
+
+  RETURN_IF_TDI_ERROR(table_key_->setValue(static_cast<tdi_id_t>(id),
+                      exactKey));
 
   return ::util::OkStatus();
 }
 
 ::util::Status TableKey::SetTernary(int id, const std::string& value,
                                     const std::string& mask) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   std::string v = P4RuntimeByteStringToPaddedByteString(
       value, NumBitsToNumBytes(field_size_bits));
   std::string m = P4RuntimeByteStringToPaddedByteString(
       mask, NumBitsToNumBytes(field_size_bits));
   DCHECK_EQ(v.size(), m.size());
-  RETURN_IF_BFRT_ERROR(table_key_->setValueandMask(
-      id, reinterpret_cast<const uint8*>(v.data()),
-      reinterpret_cast<const uint8*>(m.data()), v.size()));
+  const char *valueTernary = reinterpret_cast<const char *>(v.data());
+  const char *maskTernary = reinterpret_cast<const char *>(m.data());
+  size_t sizeTernary = reinterpret_cast<size_t>(v.size());
+
+  tdi::KeyFieldValueTernary<const char *> ternaryKey(valueTernary, maskTernary,
+                                                  sizeTernary);
 
+  RETURN_IF_TDI_ERROR(table_key_->setValue(static_cast<tdi_id_t>(id),
+                                           ternaryKey));
   return ::util::OkStatus();
 }
 
 ::util::Status TableKey::SetLpm(int id, const std::string& prefix,
                                 uint16 prefix_length) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   std::string p = P4RuntimeByteStringToPaddedByteString(
       prefix, NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_key_->setValueLpm(
-      id, reinterpret_cast<const uint8*>(p.data()), prefix_length, p.size()));
+
+  const char *valueLpm =  reinterpret_cast<const char *>(p.data());
+  size_t sizeLpm = reinterpret_cast<size_t>(p.size());
+  tdi::KeyFieldValueLPM<const char *> lpmKey(valueLpm, prefix_length, sizeLpm);
+  RETURN_IF_TDI_ERROR(table_key_->setValue(static_cast<tdi_id_t>(id),
+                                           lpmKey));
 
   return ::util::OkStatus();
 }
 
 ::util::Status TableKey::SetRange(int id, const std::string& low,
                                   const std::string& high) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   std::string l = P4RuntimeByteStringToPaddedByteString(
       low, NumBitsToNumBytes(field_size_bits));
   std::string h = P4RuntimeByteStringToPaddedByteString(
       high, NumBitsToNumBytes(field_size_bits));
   DCHECK_EQ(l.size(), h.size());
-  RETURN_IF_BFRT_ERROR(table_key_->setValueRange(
-      id, reinterpret_cast<const uint8*>(l.data()),
-      reinterpret_cast<const uint8*>(h.data()), l.size()));
 
+  const char *lowRange =  reinterpret_cast<const char *>(l.data());
+  const char *highRange =  reinterpret_cast<const char *>(h.data());
+  size_t sizeRange = reinterpret_cast<size_t>(l.size());
+  tdi::KeyFieldValueRange<const char*> rangeKey(lowRange, highRange, sizeRange);
+  RETURN_IF_TDI_ERROR(table_key_->setValue(static_cast<tdi_id_t>(id),
+                                           rangeKey));
   return ::util::OkStatus();
 }
 
-::util::Status TableKey::SetPriority(uint32 priority) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
-  bf_rt_id_t priority_field_id;
-  RETURN_IF_BFRT_ERROR(
-      table->keyFieldIdGet(kMatchPriority, &priority_field_id));
-  RETURN_IF_BFRT_ERROR(table_key_->setValue(priority_field_id, priority));
-
-  return ::util::OkStatus();
+::util::Status TableKey::SetPriority(uint64 priority) {
+  return SetFieldExact(table_key_.get(), kMatchPriority, priority);
 }
 
 ::util::Status TableKey::GetExact(int id, std::string* value) const {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   value->clear();
   value->resize(NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_key_->getValue(
-      id, value->size(),
-      reinterpret_cast<uint8*>(gtl::string_as_array(value))));
-  if (!FLAGS_incompatible_enable_bfrt_legacy_bytestring_responses) {
+
+  const char *valueExact = reinterpret_cast<const char *>(value->data());
+  size_t size = reinterpret_cast<size_t>(value->size());
+
+  tdi::KeyFieldValueExact<const char *> exactKey(valueExact, size);
+
+  RETURN_IF_TDI_ERROR(table_key_->getValue(static_cast<tdi_id_t>(id),
+                      &exactKey));
+
+  if (!FLAGS_incompatible_enable_tdirt_legacy_bytestring_responses) {
     *value = ByteStringToP4RuntimeByteString(*value);
   }
 
@@ -644,18 +710,30 @@ template <typename T>
 
 ::util::Status TableKey::GetTernary(int id, std::string* value,
                                     std::string* mask) const {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   value->clear();
   value->resize(NumBitsToNumBytes(field_size_bits));
   mask->clear();
   mask->resize(NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_key_->getValueandMask(
-      id, value->size(), reinterpret_cast<uint8*>(gtl::string_as_array(value)),
-      reinterpret_cast<uint8*>(gtl::string_as_array(mask))));
-  if (!FLAGS_incompatible_enable_bfrt_legacy_bytestring_responses) {
+  DCHECK_EQ(value->size(), mask->size());
+
+  const char *valueTernary = reinterpret_cast<const char *>(value->data());
+  const char *maskTernary = reinterpret_cast<const char *>(mask->data());
+  size_t sizeTernary = reinterpret_cast<size_t>(value->size());
+
+  tdi::KeyFieldValueTernary<const char *> ternaryKey(valueTernary, maskTernary,
+                                                  sizeTernary);
+  RETURN_IF_TDI_ERROR(table_key_->getValue(static_cast<tdi_id_t>(id),
+                                           &ternaryKey));
+
+  if (!FLAGS_incompatible_enable_tdirt_legacy_bytestring_responses) {
     *value = ByteStringToP4RuntimeByteString(*value);
     *mask = ByteStringToP4RuntimeByteString(*mask);
   }
@@ -665,16 +743,25 @@ template <typename T>
 
 ::util::Status TableKey::GetLpm(int id, std::string* prefix,
                                 uint16* prefix_length) const {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   prefix->clear();
   prefix->resize(NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_key_->getValueLpm(
-      id, prefix->size(),
-      reinterpret_cast<uint8*>(gtl::string_as_array(prefix)), prefix_length));
-  if (!FLAGS_incompatible_enable_bfrt_legacy_bytestring_responses) {
+
+  const char *valueLpm =  reinterpret_cast<const char *>(prefix->data());
+  size_t sizeLpm = reinterpret_cast<size_t>(prefix->size());
+  tdi::KeyFieldValueLPM<const char *> lpmKey(valueLpm, *prefix_length, sizeLpm);
+
+  RETURN_IF_TDI_ERROR(table_key_->getValue(static_cast<tdi_id_t>(id),
+                                           &lpmKey));
+
+  if (!FLAGS_incompatible_enable_tdirt_legacy_bytestring_responses) {
     *prefix = ByteStringToP4RuntimeByteString(*prefix);
   }
 
@@ -683,91 +770,90 @@ template <typename T>
 
 ::util::Status TableKey::GetRange(int id, std::string* low,
                                   std::string* high) const {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_key_->tableGet(&table));
   size_t field_size_bits;
-  RETURN_IF_BFRT_ERROR(table->keyFieldSizeGet(id, &field_size_bits));
+  auto tableInfo = table->tableInfoGet();
+  const tdi::KeyFieldInfo *keyFieldInfo = tableInfo->keyFieldGet(static_cast<tdi_id_t>(id));
+  RETURN_IF_NULL(keyFieldInfo);
+
+  field_size_bits = keyFieldInfo->sizeGet();
   low->clear();
   low->resize(NumBitsToNumBytes(field_size_bits));
   high->clear();
   high->resize(NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_key_->getValueRange(
-      id, low->size(), reinterpret_cast<uint8*>(gtl::string_as_array(low)),
-      reinterpret_cast<uint8*>(gtl::string_as_array(high))));
-  if (!FLAGS_incompatible_enable_bfrt_legacy_bytestring_responses) {
+
+  const char *lowRange =  reinterpret_cast<const char *>(low->data());
+  const char *highRange =  reinterpret_cast<const char *>(high->data());
+  size_t sizeRange = reinterpret_cast<size_t>(low->size());
+  tdi::KeyFieldValueRange<const char*> rangeKey(lowRange, highRange, sizeRange);
+
+  RETURN_IF_TDI_ERROR(table_key_->getValue(static_cast<tdi_id_t>(id),
+                                           &rangeKey));
+  if (!FLAGS_incompatible_enable_tdirt_legacy_bytestring_responses) {
     *low = ByteStringToP4RuntimeByteString(*low);
     *high = ByteStringToP4RuntimeByteString(*high);
   }
-
   return ::util::OkStatus();
 }
 
 ::util::Status TableKey::GetPriority(uint32* priority) const {
-  // const bfrt::BfRtTable* table;
-  // RETURN_IF_BFRT_ERROR(table_key_->tableGet(&table));
-  uint64 bf_priority;
-  RETURN_IF_ERROR(GetField(*table_key_, kMatchPriority, &bf_priority));
-  *priority = bf_priority;
-
+  uint32_t value = 0;
+  GetFieldExact(*(table_key_.get()), kMatchPriority, &value);
+  *priority = value;
   return ::util::OkStatus();
 }
 
-::util::StatusOr<std::unique_ptr<BfSdeInterface::TableKeyInterface>>
-TableKey::CreateTableKey(const bfrt::BfRtInfo* bfrt_info_, int table_id) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  auto key = std::unique_ptr<BfSdeInterface::TableKeyInterface>(
+::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableKeyInterface>>
+TableKey::CreateTableKey(const tdi::TdiInfo* tdi_info_, int table_id) {
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+  std::unique_ptr<tdi::TableKey> table_key;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  auto key = std::unique_ptr<TdiSdeInterface::TableKeyInterface>(
       new TableKey(std::move(table_key)));
   return key;
 }
 
 ::util::Status TableData::SetParam(int id, const std::string& value) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
-  bf_rt_id_t action_id = 0;
-  if (table->actionIdApplicable()) {
-    RETURN_IF_BFRT_ERROR(table_data_->actionIdGet(&action_id));
-  }
-  size_t field_size_bits;
-  if (action_id) {
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldSizeGet(id, action_id, &field_size_bits));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldSizeGet(id, &field_size_bits));
-  }
+  tdi_id_t action_id = 0;
+  size_t field_size_bits = 0;
+  const tdi::DataFieldInfo * dataFieldInfo;
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_data_->getParent(&table));
+
+  action_id = table_data_->actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(id, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_size_bits = dataFieldInfo->sizeGet();
+
   std::string p = P4RuntimeByteStringToPaddedByteString(
       value, NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_data_->setValue(
+  RETURN_IF_TDI_ERROR(table_data_->setValue(
       id, reinterpret_cast<const uint8*>(p.data()), p.size()));
 
   return ::util::OkStatus();
 }
 
 ::util::Status TableData::GetParam(int id, std::string* value) const {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
-  bf_rt_id_t action_id = 0;
-  if (table->actionIdApplicable()) {
-    RETURN_IF_BFRT_ERROR(table_data_->actionIdGet(&action_id));
-  }
   size_t field_size_bits;
-  if (action_id) {
-    RETURN_IF_BFRT_ERROR(
-        table->dataFieldSizeGet(id, action_id, &field_size_bits));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldSizeGet(id, &field_size_bits));
-  }
+  const tdi::DataFieldInfo * dataFieldInfo;
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_data_->getParent(&table));
+
+  tdi_id_t action_id = table_data_->actionIdGet();
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(id, action_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  field_size_bits = dataFieldInfo->sizeGet();
+
   value->clear();
   value->resize(NumBitsToNumBytes(field_size_bits));
-  RETURN_IF_BFRT_ERROR(table_data_->getValue(
+  RETURN_IF_TDI_ERROR(table_data_->getValue(
       id, value->size(),
       reinterpret_cast<uint8*>(gtl::string_as_array(value))));
-  if (!FLAGS_incompatible_enable_bfrt_legacy_bytestring_responses) {
+  if (!FLAGS_incompatible_enable_tdirt_legacy_bytestring_responses) {
     *value = ByteStringToP4RuntimeByteString(*value);
   }
-
   return ::util::OkStatus();
 }
 
@@ -776,31 +862,7 @@ TableKey::CreateTableKey(const bfrt::BfRtInfo* bfrt_info_, int table_id) {
 }
 
 ::util::Status TableData::GetActionMemberId(uint64* action_member_id) const {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
-  // Here we assume that table entries with action IDs (direct match-action) can
-  // never hold action member or group IDs (indirect match-action). Since this
-  // function is regularly called on both, we do not log this error here.
-  if (table->actionIdApplicable()) {
-    return MAKE_ERROR(ERR_ENTRY_NOT_FOUND).without_logging()
-           << "This direct table does not contain action member IDs.";
-  }
-  bf_rt_id_t field_id;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(kActionMemberId, &field_id));
-  RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::UINT64)
-      << "Requested uint64 but field $ACTION_MEMBER_ID has type "
-      << static_cast<int>(data_type);
-  bool is_active;
-  RETURN_IF_BFRT_ERROR(table_data_->isActive(field_id, &is_active));
-  if (!is_active) {
-    RETURN_ERROR(ERR_ENTRY_NOT_FOUND).without_logging()
-        << "Field $ACTION_MEMBER_ID is not active.";
-  }
-  RETURN_IF_BFRT_ERROR(table_data_->getValue(field_id, action_member_id));
-
-  return ::util::OkStatus();
+  return GetField(*(table_data_.get()), kActionMemberId, action_member_id);
 }
 
 ::util::Status TableData::SetSelectorGroupId(uint64 selector_group_id) {
@@ -808,31 +870,7 @@ TableKey::CreateTableKey(const bfrt::BfRtInfo* bfrt_info_, int table_id) {
 }
 
 ::util::Status TableData::GetSelectorGroupId(uint64* selector_group_id) const {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
-  // Here we assume that table entries with action IDs (direct match-action) can
-  // never hold action member or group IDs (indirect match-action). Since this
-  // function is regularly called on both, we do not log this error here.
-  if (table->actionIdApplicable()) {
-    return MAKE_ERROR(ERR_ENTRY_NOT_FOUND).without_logging()
-           << "This direct table does not contain action group IDs.";
-  }
-  bf_rt_id_t field_id;
-  bfrt::DataType data_type;
-  RETURN_IF_BFRT_ERROR(table->dataFieldIdGet(kSelectorGroupId, &field_id));
-  RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
-  CHECK_RETURN_IF_FALSE(data_type == bfrt::DataType::UINT64)
-      << "Requested uint64 but field $SELECTOR_GROUP_ID has type "
-      << static_cast<int>(data_type);
-  bool is_active;
-  RETURN_IF_BFRT_ERROR(table_data_->isActive(field_id, &is_active));
-  if (!is_active) {
-    RETURN_ERROR(ERR_ENTRY_NOT_FOUND).without_logging()
-        << "Field $SELECTOR_GROUP_ID is not active.";
-  }
-  RETURN_IF_BFRT_ERROR(table_data_->getValue(field_id, selector_group_id));
-
-  return ::util::OkStatus();
+  return GetField(*(table_data_.get()), kSelectorGroupId, selector_group_id);
 }
 
 // The P4Runtime `CounterData` message has no mechanism to differentiate between
@@ -840,36 +878,26 @@ TableKey::CreateTableKey(const bfrt::BfRtInfo* bfrt_info_, int table_id) {
 // recognize a counter reset (set, e.g., bytes to zero) request from a set
 // request for a packet-only counter. Therefore we have to be careful when
 // making set calls for those fields against the SDE.
+
 ::util::Status TableData::SetCounterData(uint64 bytes, uint64 packets) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
-
-  bf_rt_id_t action_id = 0;
-  if (table->actionIdApplicable()) {
-    RETURN_IF_BFRT_ERROR(table_data_->actionIdGet(&action_id));
-  }
-  if (!action_id) {
-    bf_rt_id_t table_id;
-    table->tableIdGet(&table_id);
-    std::string table_name;
-    table->tableNameGet(&table_name);
-    LOG(WARNING) << "Trying to set counter data on a table entry without "
-                 << "action ID. This might not behave as expected, please "
-                 << "report this to the Stratum authors: table_id " << table_id
-                 << " table_name " << table_name << ".";
-  }
-  std::vector<bf_rt_id_t> data_field_ids;
-  RETURN_IF_BFRT_ERROR(table->dataFieldIdListGet(&data_field_ids));
-  for (const auto& field_id : data_field_ids) {
-    std::string field_name;
-    RETURN_IF_BFRT_ERROR(table->dataFieldNameGet(field_id, &field_name));
-    if (field_name == kCounterBytes) {
-      RETURN_IF_BFRT_ERROR(table_data_->setValue(field_id, bytes));
-    } else if (field_name == kCounterPackets) {
-      RETURN_IF_BFRT_ERROR(table_data_->setValue(field_id, packets));
-    }
-    // Uninteresting field, ignore.
-  }
+  std::vector<tdi_id_t> data_field_ids;
+  tdi_id_t field_id_bytes = 0;
+  tdi_id_t field_id_packets = 0;
+  const tdi::DataFieldInfo *dataFieldInfoPackets;
+  const tdi::DataFieldInfo *dataFieldInfoBytes;
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_data_->getParent(&table));
+
+  tdi_id_t action_id = table_data_->actionIdGet();
+  dataFieldInfoPackets = table->tableInfoGet()->dataFieldGet(kCounterPackets, action_id);
+  dataFieldInfoBytes = table->tableInfoGet()->dataFieldGet(kCounterBytes, action_id);
+  RETURN_IF_NULL(dataFieldInfoPackets);
+  RETURN_IF_NULL(dataFieldInfoBytes);
+  field_id_packets = dataFieldInfoPackets->idGet();
+  field_id_bytes = dataFieldInfoBytes->idGet();
+
+  RETURN_IF_TDI_ERROR(table_data_->setValue(field_id_bytes, bytes));
+  RETURN_IF_TDI_ERROR(table_data_->setValue(field_id_packets, packets));
 
   return ::util::OkStatus();
 }
@@ -877,80 +905,63 @@ TableKey::CreateTableKey(const bfrt::BfRtInfo* bfrt_info_, int table_id) {
 ::util::Status TableData::GetCounterData(uint64* bytes, uint64* packets) const {
   CHECK_RETURN_IF_FALSE(bytes);
   CHECK_RETURN_IF_FALSE(packets);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
+  tdi_id_t field_id_bytes = 0;
+  tdi_id_t field_id_packets = 0;
+  const tdi::DataFieldInfo *dataFieldInfoPackets;
+  const tdi::DataFieldInfo *dataFieldInfoBytes;
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_data_->getParent(&table));
+
+  tdi_id_t action_id = table_data_->actionIdGet();
+  dataFieldInfoPackets = table->tableInfoGet()->dataFieldGet(kCounterPackets, action_id);
+  dataFieldInfoBytes = table->tableInfoGet()->dataFieldGet(kCounterBytes, action_id);
+  RETURN_IF_NULL(dataFieldInfoPackets);
+  RETURN_IF_NULL(dataFieldInfoBytes);
+  field_id_packets = dataFieldInfoPackets->idGet();
+  field_id_bytes = dataFieldInfoBytes->idGet();
 
   // Clear values in case we set only one of them later.
   *bytes = 0;
   *packets = 0;
 
-  bf_rt_id_t action_id = 0;
-  if (table->actionIdApplicable()) {
-    RETURN_IF_BFRT_ERROR(table_data_->actionIdGet(&action_id));
-  }
-
-  std::vector<bf_rt_id_t> data_field_ids;
-  if (action_id) {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdListGet(action_id, &data_field_ids));
-  } else {
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdListGet(&data_field_ids));
-  }
-  for (const auto& field_id : data_field_ids) {
-    std::string field_name;
-    if (action_id) {
-      RETURN_IF_BFRT_ERROR(
-          table->dataFieldNameGet(field_id, action_id, &field_name));
-    } else {
-      RETURN_IF_BFRT_ERROR(table->dataFieldNameGet(field_id, &field_name));
-    }
-    if (field_name == kCounterBytes) {
-      RETURN_IF_BFRT_ERROR(table_data_->getValue(field_id, bytes));
-    } else if (field_name == kCounterPackets) {
-      RETURN_IF_BFRT_ERROR(table_data_->getValue(field_id, packets));
-    }
-    // Uninteresting field, ignore.
-  }
+  RETURN_IF_TDI_ERROR(table_data_->getValue(field_id_bytes, bytes));
+  RETURN_IF_TDI_ERROR(table_data_->getValue(field_id_packets, packets));
 
   return ::util::OkStatus();
 }
 
 ::util::Status TableData::GetActionId(int* action_id) const {
   CHECK_RETURN_IF_FALSE(action_id);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
-  bf_rt_id_t bf_action_id = 0;
-  if (table->actionIdApplicable()) {
-    RETURN_IF_BFRT_ERROR(table_data_->actionIdGet(&bf_action_id));
-  }
-  *action_id = bf_action_id;
-
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_data_->getParent(&table));
+  *action_id = table_data_->actionIdGet();
   return ::util::OkStatus();
 }
 
 ::util::Status TableData::Reset(int action_id) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(table_data_->getParent(&table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(table_data_->getParent(&table));
   if (action_id) {
-    RETURN_IF_BFRT_ERROR(table->dataReset(action_id, table_data_.get()));
+    RETURN_IF_TDI_ERROR(table->dataReset(action_id, table_data_.get()));
   } else {
-    RETURN_IF_BFRT_ERROR(table->dataReset(table_data_.get()));
+    RETURN_IF_TDI_ERROR(table->dataReset(table_data_.get()));
   }
 
   return ::util::OkStatus();
 }
 
-::util::StatusOr<std::unique_ptr<BfSdeInterface::TableDataInterface>>
-TableData::CreateTableData(const bfrt::BfRtInfo* bfrt_info_, int table_id,
+::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableDataInterface>>
+TableData::CreateTableData(const tdi::TdiInfo* tdi_info_, int table_id,
                            int action_id) {
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+  std::unique_ptr<tdi::TableData> table_data;
   if (action_id) {
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(action_id, &table_data));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(action_id, &table_data));
   } else {
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
   }
-  auto data = std::unique_ptr<BfSdeInterface::TableDataInterface>(
+  auto data = std::unique_ptr<TdiSdeInterface::TableDataInterface>(
       new TableData(std::move(table_data)));
   return data;
 }
@@ -961,18 +972,19 @@ namespace {
 bf_status_t sde_port_status_callback(bf_dev_id_t device, bf_dev_port_t dev_port,
                                      bool up, void* cookie) {
   absl::Time timestamp = absl::Now();
-  BfSdeWrapper* bf_sde_wrapper = BfSdeWrapper::GetSingleton();
-  if (!bf_sde_wrapper) {
-    LOG(ERROR) << "BfSdeWrapper singleton instance is not initialized.";
+  TdiSdeWrapper* tdi_sde_wrapper = TdiSdeWrapper::GetSingleton();
+  if (!tdi_sde_wrapper) {
+    LOG(ERROR) << "TdiSdeWrapper singleton instance is not initialized.";
     return BF_INTERNAL_ERROR;
   }
   // Forward the event.
   auto status =
-      bf_sde_wrapper->OnPortStatusEvent(device, dev_port, up, timestamp);
+      tdi_sde_wrapper->OnPortStatusEvent(device, dev_port, up, timestamp);
 
   return status.ok() ? BF_SUCCESS : BF_INTERNAL_ERROR;
 }
 
+#ifdef P4SDE_DPDK_TARGET_STUB
 ::util::StatusOr<bf_port_speed_t> PortSpeedHalToBf(uint64 speed_bps) {
   switch (speed_bps) {
     case kOneGigBps:
@@ -992,6 +1004,8 @@ bf_status_t sde_port_status_callback(bf_dev_id_t device, bf_dev_port_t dev_port,
   }
 }
 
+#endif
+
 ::util::StatusOr<int> AutonegHalToBf(TriState autoneg) {
   switch (autoneg) {
     case TRI_STATE_UNKNOWN:
@@ -1005,6 +1019,7 @@ bf_status_t sde_port_status_callback(bf_dev_id_t device, bf_dev_port_t dev_port,
   }
 }
 
+#ifdef P4SDE_DPDK_TARGET_STUB
 ::util::StatusOr<bf_fec_type_t> FecModeHalToBf(FecMode fec_mode,
                                                uint64 speed_bps) {
   if (fec_mode == FEC_MODE_UNKNOWN || fec_mode == FEC_MODE_OFF) {
@@ -1043,52 +1058,56 @@ bf_status_t sde_port_status_callback(bf_dev_id_t device, bf_dev_port_t dev_port,
           << ".";
   }
 }
+#endif //P4SDE_DPDK_TARGET_STUB
 
 }  // namespace
 
-BfSdeWrapper* BfSdeWrapper::singleton_ = nullptr;
-ABSL_CONST_INIT absl::Mutex BfSdeWrapper::init_lock_(absl::kConstInit);
+TdiSdeWrapper* TdiSdeWrapper::singleton_ = nullptr;
+ABSL_CONST_INIT absl::Mutex TdiSdeWrapper::init_lock_(absl::kConstInit);
 
-BfSdeWrapper::BfSdeWrapper() : port_status_event_writer_(nullptr) {}
+TdiSdeWrapper::TdiSdeWrapper() : port_status_event_writer_(nullptr) {}
 
-::util::StatusOr<PortState> BfSdeWrapper::GetPortState(int device, int port) {
-  int state;
-  RETURN_IF_BFRT_ERROR(
+::util::StatusOr<PortState> TdiSdeWrapper::GetPortState(int device, int port) {
+  int state = 0;
+#ifdef P4SDE_DPDK_TARGET_STUB
+  RETURN_IF_TDI_ERROR(
       bf_pal_port_oper_state_get(static_cast<bf_dev_id_t>(device),
                                  static_cast<bf_dev_port_t>(port), &state));
+#endif //P4SDE_DPDK_TARGET_STUB
   return state ? PORT_STATE_UP : PORT_STATE_DOWN;
 }
 
-::util::Status BfSdeWrapper::GetPortCounters(int device, int port,
+::util::Status TdiSdeWrapper::GetPortCounters(int device, int port,
                                              PortCounters* counters) {
-  uint64_t stats[BF_NUM_RMON_COUNTERS];
-  RETURN_IF_BFRT_ERROR(
+  uint64_t stats[BF_PORT_NUM_COUNTERS] = {0};
+
+  RETURN_IF_TDI_ERROR(
       bf_pal_port_all_stats_get(static_cast<bf_dev_id_t>(device),
                                 static_cast<bf_dev_port_t>(port), stats));
-  counters->set_in_octets(stats[bf_mac_stat_OctetsReceived]);
-  counters->set_out_octets(stats[bf_mac_stat_OctetsTransmittedTotal]);
-  counters->set_in_unicast_pkts(
-      stats[bf_mac_stat_FramesReceivedwithUnicastAddresses]);
-  counters->set_out_unicast_pkts(stats[bf_mac_stat_FramesTransmittedUnicast]);
-  counters->set_in_broadcast_pkts(
-      stats[bf_mac_stat_FramesReceivedwithBroadcastAddresses]);
-  counters->set_out_broadcast_pkts(
-      stats[bf_mac_stat_FramesTransmittedBroadcast]);
-  counters->set_in_multicast_pkts(
-      stats[bf_mac_stat_FramesReceivedwithMulticastAddresses]);
-  counters->set_out_multicast_pkts(
-      stats[bf_mac_stat_FramesTransmittedMulticast]);
-  counters->set_in_discards(stats[bf_mac_stat_FramesDroppedBufferFull]);
-  counters->set_out_discards(0);       // stat not available
+
+  LOG(INFO) << "Port stats retrieved for "
+            << " device=" << device
+            << " port=" << port;
+
+  counters->set_in_octets(stats[RX_BYTES]);
+  counters->set_out_octets(stats[TX_BYTES]);
+  counters->set_in_unicast_pkts(stats[RX_PACKETS]);
+  counters->set_out_unicast_pkts(stats[TX_PACKETS]);
+  counters->set_in_broadcast_pkts(stats[RX_BROADCAST]);
+  counters->set_out_broadcast_pkts(stats[TX_BROADCAST]);
+  counters->set_in_multicast_pkts(stats[RX_MULTICAST]);
+  counters->set_out_multicast_pkts(stats[TX_MULTICAST]);
+  counters->set_in_discards(stats[RX_DISCARDS]);
+  counters->set_out_discards(stats[TX_DISCARDS]);
   counters->set_in_unknown_protos(0);  // stat not meaningful
-  counters->set_in_errors(stats[bf_mac_stat_FrameswithanyError]);
-  counters->set_out_errors(stats[bf_mac_stat_FramesTransmittedwithError]);
-  counters->set_in_fcs_errors(stats[bf_mac_stat_FramesReceivedwithFCSError]);
+  counters->set_in_errors(stats[RX_ERRORS]);
+  counters->set_out_errors(stats[TX_ERRORS]);
+  counters->set_in_fcs_errors(0);
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::OnPortStatusEvent(int device, int port, bool up,
+::util::Status TdiSdeWrapper::OnPortStatusEvent(int device, int port, bool up,
                                                absl::Time timestamp) {
   // Create PortStatusEvent message.
   PortState state = up ? PORT_STATE_UP : PORT_STATE_DOWN;
@@ -1103,117 +1122,288 @@ BfSdeWrapper::BfSdeWrapper() : port_status_event_writer_(nullptr) {}
   }
 }
 
-::util::Status BfSdeWrapper::RegisterPortStatusEventWriter(
+::util::Status TdiSdeWrapper::RegisterPortStatusEventWriter(
     std::unique_ptr<ChannelWriter<PortStatusEvent>> writer) {
   absl::WriterMutexLock l(&port_status_event_writer_lock_);
   port_status_event_writer_ = std::move(writer);
-  RETURN_IF_BFRT_ERROR(
+#ifdef P4SDE_DPDK_TARGET_STUB
+  RETURN_IF_TDI_ERROR(
       bf_pal_port_status_notif_reg(sde_port_status_callback, nullptr));
+#endif //P4SDE_DPDK_TARGET_STUB
+
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::UnregisterPortStatusEventWriter() {
+::util::Status TdiSdeWrapper::UnregisterPortStatusEventWriter() {
   absl::WriterMutexLock l(&port_status_event_writer_lock_);
   port_status_event_writer_ = nullptr;
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::AddPort(int device, int port, uint64 speed_bps,
+dpdk_port_type_t get_target_port_type(SWBackendPortType type) {
+  switch(type) {
+    case PORT_TYPE_VHOST: return BF_DPDK_LINK;
+    case PORT_TYPE_TAP: return BF_DPDK_TAP;
+    case PORT_TYPE_LINK: return BF_DPDK_LINK;
+    case PORT_TYPE_SOURCE: return BF_DPDK_SOURCE;
+    case PORT_TYPE_SINK: return BF_DPDK_SINK;
+  }
+  return BF_DPDK_PORT_MAX;
+}
+
+::util::Status TdiSdeWrapper::GetPortInfo(int device, int port,
+                                         TargetDatapathId *target_dp_id) {
+  struct port_info_t *port_info = NULL;
+  RETURN_IF_TDI_ERROR(bf_pal_port_info_get(static_cast<bf_dev_id_t>(device),
+                                            static_cast<bf_dev_port_t>(port),
+                                            &port_info));
+  target_dp_id->set_tdi_portin_id((port_info)->port_attrib.port_in_id);
+  target_dp_id->set_tdi_portout_id((port_info)->port_attrib.port_out_id);
+
+  return ::util::OkStatus();
+}
+
+::util::Status TdiSdeWrapper::HotplugPort(int device, int port,
+                            HotplugConfigParams& hotplug_config) {
+  auto hotplug_attrs = absl::make_unique<hotplug_attributes_t>();
+  strncpy(hotplug_attrs->qemu_socket_ip,
+          hotplug_config.qemu_socket_ip.c_str(),
+          sizeof(hotplug_attrs->qemu_socket_ip));
+  strncpy(hotplug_attrs->qemu_vm_netdev_id,
+          hotplug_config.qemu_vm_netdev_id.c_str(),
+          sizeof(hotplug_attrs->qemu_vm_netdev_id));
+  strncpy(hotplug_attrs->qemu_vm_chardev_id,
+          hotplug_config.qemu_vm_chardev_id.c_str(),
+          sizeof(hotplug_attrs->qemu_vm_chardev_id));
+  strncpy(hotplug_attrs->qemu_vm_device_id,
+          hotplug_config.qemu_vm_device_id.c_str(),
+          sizeof(hotplug_attrs->qemu_vm_device_id));
+  strncpy(hotplug_attrs->native_socket_path,
+          hotplug_config.native_socket_path.c_str(),
+          sizeof(hotplug_attrs->native_socket_path));
+  hotplug_attrs->qemu_hotplug = hotplug_config.qemu_hotplug;
+  hotplug_attrs->qemu_socket_port = hotplug_config.qemu_socket_port;
+  uint64 mac_address = hotplug_config.qemu_vm_mac_address;
+
+  std::string string_mac = (absl::StrFormat("%02x:%02x:%02x:%02x:%02x:%02x",
+                                            (mac_address >> 40) & 0xFF,
+                                            (mac_address >> 32) & 0xFF,
+                                            (mac_address >> 24) & 0xFF,
+                                            (mac_address >> 16) & 0xFF,
+                                            (mac_address >> 8) & 0xFF,
+                                             mac_address & 0xFF));
+  strcpy(hotplug_attrs->qemu_vm_mac_address, string_mac.c_str());
+
+  LOG(INFO) << "Parameters for hotplug are: qemu_socket_port="
+            << hotplug_attrs->qemu_socket_port
+            << " qemu_vm_mac_address=" <<hotplug_attrs->qemu_vm_mac_address
+            << " qemu_socket_ip=" <<hotplug_attrs->qemu_socket_ip
+            << " qemu_vm_netdev_id=" <<hotplug_attrs->qemu_vm_netdev_id
+            << " qemu_vm_chardev_id=" <<hotplug_attrs->qemu_vm_chardev_id
+            << " qemu_vm_device_id=" <<hotplug_attrs->qemu_vm_device_id
+            << " native_socket_path=" <<hotplug_attrs->native_socket_path
+            << " qemu_hotplug = " <<hotplug_attrs->qemu_hotplug;
+
+  if (hotplug_config.qemu_hotplug == HOTPLUG_ADD) {
+       RETURN_IF_TDI_ERROR(bf_pal_hotplug_add(static_cast<bf_dev_id_t>(device),
+                                               static_cast<bf_dev_port_t>(port),
+                                               hotplug_attrs.get()));
+  } else if (hotplug_config.qemu_hotplug == HOTPLUG_DEL) {
+       RETURN_IF_TDI_ERROR(bf_pal_hotplug_del(static_cast<bf_dev_id_t>(device),
+                                               static_cast<bf_dev_port_t>(port),
+                                               hotplug_attrs.get()));
+  }
+
+  return ::util::OkStatus();
+}
+
+::util::Status TdiSdeWrapper::AddPort(int device, int port, uint64 speed_bps,
                                      FecMode fec_mode) {
+  auto port_attrs = absl::make_unique<port_attributes_t>();
+#ifdef P4SDE_DPDK_TARGET_STUB
   ASSIGN_OR_RETURN(auto bf_speed, PortSpeedHalToBf(speed_bps));
   ASSIGN_OR_RETURN(auto bf_fec_mode, FecModeHalToBf(fec_mode, speed_bps));
-  RETURN_IF_BFRT_ERROR(bf_pal_port_add(static_cast<bf_dev_id_t>(device),
+#endif
+  RETURN_IF_TDI_ERROR(bf_pal_port_add(static_cast<bf_dev_id_t>(device),
                                        static_cast<bf_dev_port_t>(port),
-                                       bf_speed, bf_fec_mode));
+                                       port_attrs.get()));
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::DeletePort(int device, int port) {
-  RETURN_IF_BFRT_ERROR(bf_pal_port_del(static_cast<bf_dev_id_t>(device),
+::util::Status TdiSdeWrapper::AddPort(int device, int port, uint64 speed_bps,
+                                     PortConfigParams& config,
+                                     FecMode fec_mode) {
+  static int port_in;
+  static int port_out;
+
+  auto port_attrs = absl::make_unique<port_attributes_t>();
+#ifdef P4SDE_DPDK_TARGET_STUB
+  ASSIGN_OR_RETURN(auto bf_speed, PortSpeedHalToBf(speed_bps));
+  ASSIGN_OR_RETURN(auto bf_fec_mode, FecModeHalToBf(fec_mode, speed_bps));
+#endif
+  strncpy(port_attrs->port_name, config.port_name.c_str(),
+          sizeof(port_attrs->port_name));
+  strncpy(port_attrs->pipe_in, config.pipeline_name.c_str(),
+          sizeof(port_attrs->pipe_in));
+  strncpy(port_attrs->pipe_out, config.pipeline_name.c_str(),
+          sizeof(port_attrs->pipe_out));
+  strncpy(port_attrs->mempool_name, config.mempool_name.c_str(),
+          sizeof(port_attrs->mempool_name));
+  port_attrs->port_type = get_target_port_type(config.port_type);
+  port_attrs->port_dir = PM_PORT_DIR_DEFAULT;
+  port_attrs->port_in_id = port_in++;
+  port_attrs->port_out_id = port_out++;
+  port_attrs->net_port = config.packet_dir;
+
+  LOG(INFO) << "Parameters for backend are: port_name=" << port_attrs->port_name
+            << " port_type=" << port_attrs->port_type
+            << " port_in_id=" << port_attrs->port_in_id
+            << " port_out_id=" << port_attrs->port_out_id
+            << " pipeline_in_name=" << port_attrs->pipe_in
+            << " pipeline_out_name=" << port_attrs->pipe_out
+            << " mempool_name=" << port_attrs->mempool_name
+            << " net_port=" << port_attrs->net_port
+            << " sdk_port_id = " << port;
+
+  if (port_attrs->port_type == BF_DPDK_LINK) {
+    // Update LINK parameters
+    if(config.port_type == PORT_TYPE_VHOST) {
+      port_attrs->link.dev_hotplug_enabled = 1;
+      strncpy(port_attrs->link.pcie_domain_bdf, config.port_name.c_str(),
+          sizeof(port_attrs->link.pcie_domain_bdf));
+      snprintf(port_attrs->link.dev_args, DEV_ARGS_LEN, "iface=%s,queues=%d",
+             config.socket_path.c_str(), config.queues);
+    } else {
+      strncpy(port_attrs->link.pcie_domain_bdf, config.pci_bdf.c_str(),
+          sizeof(port_attrs->link.pcie_domain_bdf));
+    }
+      LOG(INFO) << "LINK Parameters of the port are "
+             << " pcie_domain_bdf=" << port_attrs->link.pcie_domain_bdf
+             << " dev_args=" << port_attrs->link.dev_args;
+  }
+  else if (port_attrs->port_type == BF_DPDK_TAP) {
+      port_attrs->tap.mtu = config.mtu;
+      LOG(INFO) << "TAP Parameters of the port are "
+        << "mtu = " << port_attrs->tap.mtu;
+  }
+
+  auto bf_status = bf_pal_port_add(static_cast<bf_dev_id_t>(device),
+                                       static_cast<bf_dev_port_t>(port),
+                                       port_attrs.get());
+  if (bf_status != BF_SUCCESS) {
+      // Revert the port_in and port_out values
+      port_in--;
+      port_out--;
+      RETURN_IF_TDI_ERROR(bf_status);
+  }
+
+  return ::util::OkStatus();
+}
+
+::util::Status TdiSdeWrapper::DeletePort(int device, int port) {
+  RETURN_IF_TDI_ERROR(bf_pal_port_del(static_cast<bf_dev_id_t>(device),
                                        static_cast<bf_dev_port_t>(port)));
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::EnablePort(int device, int port) {
-  RETURN_IF_BFRT_ERROR(bf_pal_port_enable(static_cast<bf_dev_id_t>(device),
+::util::Status TdiSdeWrapper::EnablePort(int device, int port) {
+#ifdef P4SDE_DPDK_TARGET_STUB
+  RETURN_IF_TDI_ERROR(bf_pal_port_enable(static_cast<bf_dev_id_t>(device),
                                           static_cast<bf_dev_port_t>(port)));
+#endif //P4SDE_DPDK_TARGET_STUB
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::DisablePort(int device, int port) {
-  RETURN_IF_BFRT_ERROR(bf_pal_port_disable(static_cast<bf_dev_id_t>(device),
+::util::Status TdiSdeWrapper::DisablePort(int device, int port) {
+#ifdef P4SDE_DPDK_TARGET_STUB
+ RETURN_IF_TDI_ERROR(bf_pal_port_disable(static_cast<bf_dev_id_t>(device),
                                            static_cast<bf_dev_port_t>(port)));
+#endif //P4SDE_DPDK_TARGET_STUB
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::SetPortShapingRate(int device, int port,
+::util::Status TdiSdeWrapper::SetPortShapingRate(int device, int port,
                                                 bool is_in_pps,
                                                 uint32 burst_size,
                                                 uint64 rate_per_second) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   if (!is_in_pps) {
     rate_per_second /= 1000;  // The SDE expects the bitrate in kbps.
   }
 
-  RETURN_IF_BFRT_ERROR(p4_pd_tm_set_port_shaping_rate(
+  RETURN_IF_TDI_ERROR(p4_pd_tm_set_port_shaping_rate(
       device, port, is_in_pps, burst_size, rate_per_second));
-
+#endif
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::EnablePortShaping(int device, int port,
+::util::Status TdiSdeWrapper::EnablePortShaping(int device, int port,
                                                TriState enable) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   if (enable == TriState::TRI_STATE_TRUE) {
-    RETURN_IF_BFRT_ERROR(p4_pd_tm_enable_port_shaping(device, port));
+    RETURN_IF_TDI_ERROR(p4_pd_tm_enable_port_shaping(device, port));
   } else if (enable == TriState::TRI_STATE_FALSE) {
-    RETURN_IF_BFRT_ERROR(p4_pd_tm_disable_port_shaping(device, port));
+    RETURN_IF_TDI_ERROR(p4_pd_tm_disable_port_shaping(device, port));
   }
+#endif
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::SetPortAutonegPolicy(int device, int port,
+::util::Status TdiSdeWrapper::SetPortAutonegPolicy(int device, int port,
                                                   TriState autoneg) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   ASSIGN_OR_RETURN(auto autoneg_v, AutonegHalToBf(autoneg));
-  RETURN_IF_BFRT_ERROR(bf_pal_port_autoneg_policy_set(
+  RETURN_IF_TDI_ERROR(bf_pal_port_autoneg_policy_set(
       static_cast<bf_dev_id_t>(device), static_cast<bf_dev_port_t>(port),
       autoneg_v));
+#endif //P4SDE_DPDK_TARGET_STUB
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::SetPortMtu(int device, int port, int32 mtu) {
+::util::Status TdiSdeWrapper::SetPortMtu(int device, int port, int32 mtu) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   if (mtu < 0) {
     RETURN_ERROR(ERR_INVALID_PARAM) << "Invalid MTU value.";
   }
   if (mtu == 0) mtu = kBfDefaultMtu;
-  RETURN_IF_BFRT_ERROR(bf_pal_port_mtu_set(
+  RETURN_IF_TDI_ERROR(bf_pal_port_mtu_set(
       static_cast<bf_dev_id_t>(device), static_cast<bf_dev_port_t>(port),
       static_cast<uint32>(mtu), static_cast<uint32>(mtu)));
+#endif //P4SDE_DPDK_TARGET_STUB
+
   return ::util::OkStatus();
 }
 
-bool BfSdeWrapper::IsValidPort(int device, int port) {
+bool TdiSdeWrapper::IsValidPort(int device, int port) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   return bf_pal_port_is_valid(device, port) == BF_SUCCESS;
+#endif //P4SDE_DPDK_TARGET_STUB
+  return BF_SUCCESS;
 }
 
-::util::Status BfSdeWrapper::SetPortLoopbackMode(int device, int port,
+::util::Status TdiSdeWrapper::SetPortLoopbackMode(int device, int port,
                                                  LoopbackState loopback_mode) {
   if (loopback_mode == LOOPBACK_STATE_UNKNOWN) {
     // Do nothing if we try to set loopback mode to the default one (UNKNOWN).
     return ::util::OkStatus();
   }
+#ifdef P4SDE_DPDK_TARGET_STUB
   ASSIGN_OR_RETURN(bf_loopback_mode_e lp_mode, LoopbackModeToBf(loopback_mode));
-  RETURN_IF_BFRT_ERROR(
+  RETURN_IF_TDI_ERROR(
       bf_pal_port_loopback_mode_set(static_cast<bf_dev_id_t>(device),
                                     static_cast<bf_dev_port_t>(port), lp_mode));
-
+#endif
   return ::util::OkStatus();
 }
 
-::util::StatusOr<bool> BfSdeWrapper::IsSoftwareModel(int device) {
-  bool is_sw_model;
+::util::StatusOr<bool> TdiSdeWrapper::IsSoftwareModel(int device) {
+  bool is_sw_model = true;
+#ifdef P4SDE_DPDK_TARGET_STUB
   auto bf_status = bf_pal_pltfm_type_get(device, &is_sw_model);
   CHECK_RETURN_IF_FALSE(bf_status == BF_SUCCESS)
       << "Error getting software model status.";
+#endif //P4SDE_DPDK_TARGET_STUB
 
   return is_sw_model;
 }
@@ -1221,6 +1411,7 @@ bool BfSdeWrapper::IsValidPort(int device, int port) {
 // Helper functions around reading the switch SKU.
 namespace {
 std::string GetBfChipFamilyAndType(int device) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   bf_dev_type_t dev_type = lld_sku_get_dev_type(device);
   switch (dev_type) {
     case BF_DEV_BFNT10064Q:
@@ -1284,9 +1475,12 @@ std::string GetBfChipFamilyAndType(int device) {
     default:
       return "UNKNOWN";
   }
+#endif //P4SDE_DPDK_TARGET_STUB
+  return "UNKNOWN";
 }
 
 std::string GetBfChipRevision(int device) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   bf_sku_chip_part_rev_t revision_number;
   lld_sku_get_chip_part_revision_number(device, &revision_number);
   switch (revision_number) {
@@ -1297,22 +1491,26 @@ std::string GetBfChipRevision(int device) {
     default:
       return "UNKOWN";
   }
+#endif //P4SDE_DPDK_TARGET_STUB
+  return "UNKNOWN";
 }
 
 std::string GetBfChipId(int device) {
   uint64 chip_id = 0;
+#ifdef P4SDE_DPDK_TARGET_STUB
   lld_sku_get_chip_id(device, &chip_id);
+#endif
   return absl::StrCat("0x", absl::Hex(chip_id));
 }
 }  // namespace
 
-std::string BfSdeWrapper::GetBfChipType(int device) const {
+std::string TdiSdeWrapper::GetBfChipType(int device) const {
   return absl::StrCat(GetBfChipFamilyAndType(device), ", revision ",
                       GetBfChipRevision(device), ", chip_id ",
                       GetBfChipId(device));
 }
 
-std::string BfSdeWrapper::GetSdeVersion() const {
+std::string TdiSdeWrapper::GetSdeVersion() const {
 #if defined(SDE_9_1_0)
   return "9.1.0";
 #elif defined(SDE_9_2_0)
@@ -1332,7 +1530,7 @@ std::string BfSdeWrapper::GetSdeVersion() const {
 #endif
 }
 
-::util::StatusOr<uint32> BfSdeWrapper::GetPortIdFromPortKey(
+::util::StatusOr<uint32> TdiSdeWrapper::GetPortIdFromPortKey(
     int device, const PortKey& port_key) {
   const int port = port_key.port;
   CHECK_RETURN_IF_FALSE(port >= 0)
@@ -1358,35 +1556,44 @@ std::string BfSdeWrapper::GetSdeVersion() const {
       << channel << " on dev " << device << ".";
 
   bf_dev_port_t dev_port;
-  RETURN_IF_BFRT_ERROR(bf_pal_port_str_to_dev_port_map(
+  RETURN_IF_TDI_ERROR(bf_pal_port_str_to_dev_port_map(
       static_cast<bf_dev_id_t>(device), port_string, &dev_port));
   return static_cast<uint32>(dev_port);
 }
 
-::util::StatusOr<int> BfSdeWrapper::GetPcieCpuPort(int device) {
+::util::StatusOr<int> TdiSdeWrapper::GetPcieCpuPort(int device) {
+  int port = 0;
+#ifdef P4SDE_DPDK_TARGET_STUB
   int port = p4_devport_mgr_pcie_cpu_port_get(device);
   CHECK_RETURN_IF_FALSE(port != -1);
+#endif //P4SDE_DPDK_TARGET_STUB
   return port;
 }
 
-::util::Status BfSdeWrapper::SetTmCpuPort(int device, int port) {
+::util::Status TdiSdeWrapper::SetTmCpuPort(int device, int port) {
+
+#ifdef P4SDE_DPDK_TARGET_STUB
   CHECK_RETURN_IF_FALSE(p4_pd_tm_set_cpuport(device, port) == 0)
       << "Unable to set CPU port " << port << " on device " << device;
+#endif
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::SetDeflectOnDropDestination(int device, int port,
+::util::Status TdiSdeWrapper::SetDeflectOnDropDestination(int device, int port,
                                                          int queue) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   // The DoD destination must be a pipe-local port.
   p4_pd_tm_pipe_t pipe = DEV_PORT_TO_PIPE(port);
-  RETURN_IF_BFRT_ERROR(
+  RETURN_IF_TDI_ERROR(
       p4_pd_tm_set_negative_mirror_dest(device, pipe, port, queue));
+#endif
+
   return ::util::OkStatus();
 }
 
 // BFRT
 
-::util::Status BfSdeWrapper::InitializeSde(const std::string& sde_install_path,
+::util::Status TdiSdeWrapper::InitializeSde(const std::string& sde_install_path,
                                            const std::string& sde_config_file,
                                            bool run_in_background) {
   CHECK_RETURN_IF_FALSE(sde_install_path != "")
@@ -1408,7 +1615,7 @@ std::string BfSdeWrapper::GetSdeVersion() const {
   std::string bf_sysfs_fname;
   {
     char buf[128] = {};
-    RETURN_IF_BFRT_ERROR(switch_pci_sysfs_str_get(buf, sizeof(buf)));
+    RETURN_IF_TDI_ERROR(switch_pci_sysfs_str_get(buf, sizeof(buf)));
     bf_sysfs_fname = buf;
   }
   absl::StrAppend(&bf_sysfs_fname, "/dev_add");
@@ -1417,55 +1624,58 @@ std::string BfSdeWrapper::GetSdeVersion() const {
     // Override previous parsing if bf_kpkt KLM was loaded.
     LOG(INFO)
         << "kernel mode packet driver present, forcing kernel_pkt option!";
+#ifdef P4SDE_DPDK_TARGET_STUB
     switchd_main_ctx->kernel_pkt = true;
+#endif //P4SDE_DPDK_TARGET_STUB
   }
 
-  RETURN_IF_BFRT_ERROR(bf_switchd_lib_init(switchd_main_ctx.get()))
+#ifdef P4SDE_DPDK_TARGET_STUB
+  switchd_main_ctx->skip_hld.mc_mgr = true;
+  switchd_main_ctx->skip_hld.pkt_mgr = true;
+  switchd_main_ctx->skip_hld.traffic_mgr = true;
+#endif
+
+  RETURN_IF_TDI_ERROR(bf_switchd_lib_init(switchd_main_ctx.get()))
       << "Error when starting switchd.";
   LOG(INFO) << "switchd started successfully";
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::AddDevice(int device,
-                                       const BfrtDeviceConfig& device_config) {
+::util::Status TdiSdeWrapper::AddDevice(int dev_id,
+                                       const TdirtDeviceConfig& device_config) {
+  const tdi::Device *device = nullptr;
   absl::WriterMutexLock l(&data_lock_);
 
-  // CHECK_RETURN_IF_FALSE(initialized_) << "Not initialized";
   CHECK_RETURN_IF_FALSE(device_config.programs_size() > 0);
 
-  // if (pipeline_initialized_) {
-  // RETURN_IF_BFRT_ERROR(bf_device_remove(device));
-  // }
+  tdirt_id_mapper_.reset();
 
-  bfrt_device_manager_ = &bfrt::BfRtDevMgr::getInstance();
-  bfrt_id_mapper_.reset();
-
-  RETURN_IF_BFRT_ERROR(bf_pal_device_warm_init_begin(
-      device, BF_DEV_WARM_INIT_FAST_RECFG, BF_DEV_SERDES_UPD_NONE,
+  RETURN_IF_TDI_ERROR(bf_pal_device_warm_init_begin(
+      dev_id, BF_DEV_WARM_INIT_FAST_RECFG,
       /* upgrade_agents */ true));
   bf_device_profile_t device_profile = {};
 
   // Commit new files to disk and build device profile for SDE to load.
-  RETURN_IF_ERROR(RecursivelyCreateDir(FLAGS_bfrt_sde_config_dir));
+  RETURN_IF_ERROR(RecursivelyCreateDir(FLAGS_tdirt_sde_config_dir));
   // Need to extend the lifetime of the path strings until the SDE read them.
   std::vector<std::unique_ptr<std::string>> path_strings;
   device_profile.num_p4_programs = device_config.programs_size();
   for (int i = 0; i < device_config.programs_size(); ++i) {
     const auto& program = device_config.programs(i);
     const std::string program_path =
-        absl::StrCat(FLAGS_bfrt_sde_config_dir, "/", program.name());
-    auto bfrt_path = absl::make_unique<std::string>(
+        absl::StrCat(FLAGS_tdirt_sde_config_dir, "/", program.name());
+    auto tdirt_path = absl::make_unique<std::string>(
         absl::StrCat(program_path, "/bfrt.json"));
     RETURN_IF_ERROR(RecursivelyCreateDir(program_path));
-    RETURN_IF_ERROR(WriteStringToFile(program.bfrt(), *bfrt_path));
+    RETURN_IF_ERROR(WriteStringToFile(program.bfrt(), *tdirt_path));
 
     bf_p4_program_t* p4_program = &device_profile.p4_programs[i];
     ::snprintf(p4_program->prog_name, _PI_UPDATE_MAX_NAME_SIZE, "%s",
                program.name().c_str());
-    p4_program->bfrt_json_file = &(*bfrt_path)[0];
+    p4_program->bfrt_json_file = &(*tdirt_path)[0];
     p4_program->num_p4_pipelines = program.pipelines_size();
-    path_strings.emplace_back(std::move(bfrt_path));
+    path_strings.emplace_back(std::move(tdirt_path));
     CHECK_RETURN_IF_FALSE(program.pipelines_size() > 0);
     for (int j = 0; j < program.pipelines_size(); ++j) {
       const auto& pipeline = program.pipelines(j);
@@ -1496,10 +1706,9 @@ std::string BfSdeWrapper::GetSdeVersion() const {
     }
   }
 
-  // bf_device_add?
   // This call re-initializes most SDE components.
-  RETURN_IF_BFRT_ERROR(bf_pal_device_add(device, &device_profile));
-  RETURN_IF_BFRT_ERROR(bf_pal_device_warm_init_end(device));
+  RETURN_IF_TDI_ERROR(bf_pal_device_add(dev_id, &device_profile));
+  RETURN_IF_TDI_ERROR(bf_pal_device_warm_init_end(dev_id));
 
   // Set SDE log levels for modules of interest.
   // TODO(max): create story around SDE logs. How to get them into glog? What
@@ -1510,114 +1719,123 @@ std::string BfSdeWrapper::GetSdeVersion() const {
       bf_sys_log_level_set(BF_MOD_PKT, BF_LOG_DEST_STDOUT, BF_LOG_WARN) == 0);
   CHECK_RETURN_IF_FALSE(
       bf_sys_log_level_set(BF_MOD_PIPE, BF_LOG_DEST_STDOUT, BF_LOG_WARN) == 0);
+#ifdef P4SDE_DPDK_TARGET_STUB
   stat_mgr_enable_detail_trace = false;
+#endif //P4SDE_DPDK_TARGET_STUB
   if (VLOG_IS_ON(2)) {
     CHECK_RETURN_IF_FALSE(bf_sys_log_level_set(BF_MOD_PIPE, BF_LOG_DEST_STDOUT,
-                                               BF_LOG_INFO) == 0);
+                                               BF_LOG_WARN) == 0);
+#ifdef P4SDE_DPDK_TARGET_STUB
     stat_mgr_enable_detail_trace = true;
+#endif //P4SDE_DPDK_TARGET_STUB
   }
 
-  RETURN_IF_BFRT_ERROR(bfrt_device_manager_->bfRtInfoGet(
-      device, device_config.programs(0).name(), &bfrt_info_));
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  RETURN_IF_TDI_ERROR(device->tdiInfoGet(
+       device_config.programs(0).name(), &tdi_info_));
 
   // FIXME: if all we ever do is create and push, this could be one call.
-  bfrt_id_mapper_ = BfrtIdMapper::CreateInstance();
+  tdirt_id_mapper_ = TdirtIdMapper::CreateInstance();
   RETURN_IF_ERROR(
-      bfrt_id_mapper_->PushForwardingPipelineConfig(device_config, bfrt_info_));
+      tdirt_id_mapper_->PushForwardingPipelineConfig(device_config, tdi_info_));
 
   return ::util::OkStatus();
 }
 
 // Create and start an new session.
-::util::StatusOr<std::shared_ptr<BfSdeInterface::SessionInterface>>
-BfSdeWrapper::CreateSession() {
+::util::StatusOr<std::shared_ptr<TdiSdeInterface::SessionInterface>>
+TdiSdeWrapper::CreateSession() {
   return Session::CreateSession();
 }
 
-::util::StatusOr<std::unique_ptr<BfSdeInterface::TableKeyInterface>>
-BfSdeWrapper::CreateTableKey(int table_id) {
+::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableKeyInterface>>
+TdiSdeWrapper::CreateTableKey(int table_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return TableKey::CreateTableKey(bfrt_info_, table_id);
+  return TableKey::CreateTableKey(tdi_info_, table_id);
 }
 
-::util::StatusOr<std::unique_ptr<BfSdeInterface::TableDataInterface>>
-BfSdeWrapper::CreateTableData(int table_id, int action_id) {
+::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableDataInterface>>
+TdiSdeWrapper::CreateTableData(int table_id, int action_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return TableData::CreateTableData(bfrt_info_, table_id, action_id);
+  return TableData::CreateTableData(tdi_info_, table_id, action_id);
 }
 
 //  Packetio
 
-::util::Status BfSdeWrapper::TxPacket(int device, const std::string& buffer) {
+::util::Status TdiSdeWrapper::TxPacket(int device, const std::string& buffer) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   bf_pkt* pkt = nullptr;
-  RETURN_IF_BFRT_ERROR(
+  RETURN_IF_TDI_ERROR(
       bf_pkt_alloc(device, &pkt, buffer.size(), BF_DMA_CPU_PKT_TRANSMIT_0));
   auto pkt_cleaner =
       gtl::MakeCleanup([pkt, device]() { bf_pkt_free(device, pkt); });
-  RETURN_IF_BFRT_ERROR(bf_pkt_data_copy(
+  RETURN_IF_TDI_ERROR(bf_pkt_data_copy(
       pkt, reinterpret_cast<const uint8*>(buffer.data()), buffer.size()));
-  RETURN_IF_BFRT_ERROR(bf_pkt_tx(device, pkt, BF_PKT_TX_RING_0, pkt));
+  RETURN_IF_TDI_ERROR(bf_pkt_tx(device, pkt, BF_PKT_TX_RING_0, pkt));
   pkt_cleaner.release();
-
+#endif
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::StartPacketIo(int device) {
+::util::Status TdiSdeWrapper::StartPacketIo(int device) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   // Maybe move to InitSde function?
   if (!bf_pkt_is_inited(device)) {
-    RETURN_IF_BFRT_ERROR(bf_pkt_init());
+    RETURN_IF_TDI_ERROR(bf_pkt_init());
   }
 
   // type of i should be bf_pkt_tx_ring_t?
   for (int tx_ring = BF_PKT_TX_RING_0; tx_ring < BF_PKT_TX_RING_MAX;
        ++tx_ring) {
-    RETURN_IF_BFRT_ERROR(bf_pkt_tx_done_notif_register(
-        device, BfSdeWrapper::BfPktTxNotifyCallback,
+    RETURN_IF_TDI_ERROR(bf_pkt_tx_done_notif_register(
+        device, TdiSdeWrapper::BfPktTxNotifyCallback,
         static_cast<bf_pkt_tx_ring_t>(tx_ring)));
   }
 
   for (int rx_ring = BF_PKT_RX_RING_0; rx_ring < BF_PKT_RX_RING_MAX;
        ++rx_ring) {
-    RETURN_IF_BFRT_ERROR(
-        bf_pkt_rx_register(device, BfSdeWrapper::BfPktRxNotifyCallback,
+    RETURN_IF_TDI_ERROR(
+        bf_pkt_rx_register(device, TdiSdeWrapper::BfPktRxNotifyCallback,
                            static_cast<bf_pkt_rx_ring_t>(rx_ring), nullptr));
   }
   VLOG(1) << "Registered packetio callbacks on device " << device << ".";
-
+#endif
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::StopPacketIo(int device) {
+::util::Status TdiSdeWrapper::StopPacketIo(int device) {
+#ifdef P4SDE_DPDK_TARGET_STUB
   for (int tx_ring = BF_PKT_TX_RING_0; tx_ring < BF_PKT_TX_RING_MAX;
        ++tx_ring) {
-    RETURN_IF_BFRT_ERROR(bf_pkt_tx_done_notif_deregister(
+    RETURN_IF_TDI_ERROR(bf_pkt_tx_done_notif_deregister(
         device, static_cast<bf_pkt_tx_ring_t>(tx_ring)));
   }
 
   for (int rx_ring = BF_PKT_RX_RING_0; rx_ring < BF_PKT_RX_RING_MAX;
        ++rx_ring) {
-    RETURN_IF_BFRT_ERROR(
+    RETURN_IF_TDI_ERROR(
         bf_pkt_rx_deregister(device, static_cast<bf_pkt_rx_ring_t>(rx_ring)));
   }
   VLOG(1) << "Unregistered packetio callbacks on device " << device << ".";
-
+#endif
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::RegisterPacketReceiveWriter(
+::util::Status TdiSdeWrapper::RegisterPacketReceiveWriter(
     int device, std::unique_ptr<ChannelWriter<std::string>> writer) {
   absl::WriterMutexLock l(&packet_rx_callback_lock_);
   device_to_packet_rx_writer_[device] = std::move(writer);
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::UnregisterPacketReceiveWriter(int device) {
+::util::Status TdiSdeWrapper::UnregisterPacketReceiveWriter(int device) {
   absl::WriterMutexLock l(&packet_rx_callback_lock_);
   device_to_packet_rx_writer_.erase(device);
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::HandlePacketRx(bf_dev_id_t device, bf_pkt* pkt,
+#ifdef P4SDE_DPDK_TARGET_STUB
+::util::Status TdiSdeWrapper::HandlePacketRx(bf_dev_id_t device, bf_pkt* pkt,
                                             bf_pkt_rx_ring_t rx_ring) {
   absl::ReaderMutexLock l(&packet_rx_callback_lock_);
   auto rx_writer = gtl::FindOrNull(device_to_packet_rx_writer_, device);
@@ -1635,7 +1853,7 @@ BfSdeWrapper::CreateTableData(int table_id, int action_id) {
   return ::util::OkStatus();
 }
 
-bf_status_t BfSdeWrapper::BfPktTxNotifyCallback(bf_dev_id_t device,
+bf_status_t TdiSdeWrapper::BfPktTxNotifyCallback(bf_dev_id_t device,
                                                 bf_pkt_tx_ring_t tx_ring,
                                                 uint64 tx_cookie,
                                                 uint32 status) {
@@ -1647,34 +1865,28 @@ bf_status_t BfSdeWrapper::BfPktTxNotifyCallback(bf_dev_id_t device,
   return bf_pkt_free(device, pkt);
 }
 
-bf_status_t BfSdeWrapper::BfPktRxNotifyCallback(bf_dev_id_t device, bf_pkt* pkt,
+bf_status_t TdiSdeWrapper::BfPktRxNotifyCallback(bf_dev_id_t device, bf_pkt* pkt,
                                                 void* cookie,
                                                 bf_pkt_rx_ring_t rx_ring) {
-  BfSdeWrapper* bf_sde_wrapper = BfSdeWrapper::GetSingleton();
+  TdiSdeWrapper* tdi_sde_wrapper = TdiSdeWrapper::GetSingleton();
   // TODO(max): Handle error
-  bf_sde_wrapper->HandlePacketRx(device, pkt, rx_ring);
+  tdi_sde_wrapper->HandlePacketRx(device, pkt, rx_ring);
   return bf_pkt_free(device, pkt);
 }
-
-bf_rt_target_t BfSdeWrapper::GetDeviceTarget(int device) const {
-  bf_rt_target_t dev_tgt = {};
-  dev_tgt.dev_id = device;
-  dev_tgt.pipe_id = BF_DEV_PIPE_ALL;
-  return dev_tgt;
-}
+#endif
 
 // PRE
 namespace {
-::util::Status PrintMcGroupEntry(const bfrt::BfRtTable* table,
-                                 const bfrt::BfRtTableKey* table_key,
-                                 const bfrt::BfRtTableData* table_data) {
+::util::Status PrintMcGroupEntry(const tdi::Table* table,
+                                 const tdi::TableKey* table_key,
+                                 const tdi::TableData* table_data) {
   std::vector<uint32> mc_node_list;
   std::vector<bool> l1_xid_valid_list;
   std::vector<uint32> l1_xid_list;
-  uint64 multicast_group_id;
 
   // Key: $MGID
-  RETURN_IF_ERROR(GetField(*table_key, kMgid, &multicast_group_id));
+  uint32_t multicast_group_id = 0;
+  RETURN_IF_ERROR(GetFieldExact(*table_key, kMgid, &multicast_group_id));
   // Data: $MULTICAST_NODE_ID
   RETURN_IF_ERROR(GetField(*table_data, kMcNodeId, &mc_node_list));
   // Data: $MULTICAST_NODE_L1_XID_VALID
@@ -1684,6 +1896,7 @@ namespace {
 
   LOG(INFO) << "Multicast group id " << multicast_group_id << " has "
             << mc_node_list.size() << " nodes.";
+
   for (const auto& node : mc_node_list) {
     LOG(INFO) << "\tnode id " << node;
   }
@@ -1691,12 +1904,12 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status PrintMcNodeEntry(const bfrt::BfRtTable* table,
-                                const bfrt::BfRtTableKey* table_key,
-                                const bfrt::BfRtTableData* table_data) {
+::util::Status PrintMcNodeEntry(const tdi::Table* table,
+                                const tdi::TableKey* table_key,
+                                const tdi::TableData* table_data) {
   // Key: $MULTICAST_NODE_ID (24 bit)
-  uint64 node_id;
-  RETURN_IF_ERROR(GetField(*table_key, kMcNodeId, &node_id));
+  uint32_t node_id = 0;
+  RETURN_IF_ERROR(GetFieldExact(*table_key, kMcNodeId, &node_id));
   // Data: $MULTICAST_RID (16 bit)
   uint64 rid;
   RETURN_IF_ERROR(GetField(*table_data, kMcReplicationId, &rid));
@@ -1715,41 +1928,44 @@ namespace {
 }
 }  // namespace
 
-::util::Status BfSdeWrapper::DumpPreState(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session) {
+::util::Status TdiSdeWrapper::DumpPreState(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session) {
   if (VLOG_IS_ON(2)) {
     auto real_session = std::dynamic_pointer_cast<Session>(session);
     CHECK_RETURN_IF_FALSE(real_session);
 
-    auto bf_dev_tgt = GetDeviceTarget(device);
-    const bfrt::BfRtTable* table;
+    const tdi::Table* table;
+    const tdi::Device *device = nullptr;
+    tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+    std::unique_ptr<tdi::Target> dev_tgt;
+    device->createTarget(&dev_tgt);
 
     // Dump group table
     LOG(INFO) << "#### $pre.mgid ####";
-    RETURN_IF_BFRT_ERROR(
-        bfrt_info_->bfrtTableFromNameGet(kPreMgidTable, &table));
-    std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-    std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
-    RETURN_IF_BFRT_ERROR(
-        bfrt_info_->bfrtTableFromNameGet(kPreMgidTable, &table));
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_TDI_ERROR(
+        tdi_info_->tableFromNameGet(kPreMgidTable, &table));
+    std::vector<std::unique_ptr<tdi::TableKey>> keys;
+    std::vector<std::unique_ptr<tdi::TableData>> datums;
+    RETURN_IF_TDI_ERROR(
+        tdi_info_->tableFromNameGet(kPreMgidTable, &table));
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
     for (size_t i = 0; i < keys.size(); ++i) {
-      const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-      const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+      const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+      const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
       PrintMcGroupEntry(table, table_key.get(), table_data.get());
     }
     LOG(INFO) << "###################";
 
     // Dump node table
     LOG(INFO) << "#### $pre.node ####";
-    RETURN_IF_BFRT_ERROR(
-        bfrt_info_->bfrtTableFromNameGet(kPreNodeTable, &table));
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_TDI_ERROR(
+        tdi_info_->tableFromNameGet(kPreNodeTable, &table));
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
     for (size_t i = 0; i < keys.size(); ++i) {
-      const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-      const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+      const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+      const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
       PrintMcNodeEntry(table, table_key.get(), table_data.get());
     }
     LOG(INFO) << "###################";
@@ -1757,51 +1973,59 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::StatusOr<uint32> BfSdeWrapper::GetFreeMulticastNodeId(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session) {
+::util::StatusOr<uint32> TdiSdeWrapper::GetFreeMulticastNodeId(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session) {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreNodeTable, &table));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreNodeTable, &table));
   size_t table_size;
+
 #if defined(SDE_9_4_0) || defined(SDE_9_5_0)
-  RETURN_IF_BFRT_ERROR(table->tableSizeGet(*real_session->bfrt_session_,
-                                           bf_dev_tgt, &table_size));
+  RETURN_IF_TDI_ERROR(table->sizeGet(*real_session->tdirt_session_,
+                                      *dev_tgt, *flags, &table_size));
 #else
-  RETURN_IF_BFRT_ERROR(table->tableSizeGet(&table_size));
+  RETURN_IF_TDI_ERROR(table->tableSizeGet(&table_size));
 #endif  // SDE_9_4_0
   uint32 usage;
-  RETURN_IF_BFRT_ERROR(table->tableUsageGet(
-      *real_session->bfrt_session_, bf_dev_tgt,
-      bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, &usage));
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  RETURN_IF_TDI_ERROR(table->usageGet(
+      *real_session->tdirt_session_, *dev_tgt,
+      *flags, &usage));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
   uint32 id = usage;
   for (size_t _ = 0; _ < table_size; ++_) {
     // Key: $MULTICAST_NODE_ID
-    RETURN_IF_ERROR(SetField(table_key.get(), kMcNodeId, id));
-    bf_status_t status = table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key,
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, table_data.get());
+    RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMcNodeId, id));
+    bf_status_t status;
+    status = table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key,
+        table_data.get());
     if (status == BF_OBJECT_NOT_FOUND) {
       return id;
     } else if (status == BF_SUCCESS) {
       id++;
       continue;
     } else {
-      RETURN_IF_BFRT_ERROR(status);
+      RETURN_IF_TDI_ERROR(status);
     }
   }
 
   RETURN_ERROR(ERR_TABLE_FULL) << "Could not find free multicast node id.";
 }
 
-::util::StatusOr<uint32> BfSdeWrapper::CreateMulticastNode(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::StatusOr<uint32> TdiSdeWrapper::CreateMulticastNode(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     int mc_replication_id, const std::vector<uint32>& mc_lag_ids,
     const std::vector<uint32>& ports) {
   ::absl::ReaderMutexLock l(&data_lock_);
@@ -1809,22 +2033,27 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;  // PRE node table.
-  bf_rt_id_t table_id;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreNodeTable, &table));
-  RETURN_IF_BFRT_ERROR(table->tableIdGet(&table_id));
+  const tdi::Table* table;  // PRE node table.
+  tdi_id_t table_id;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreNodeTable, &table));
+  table_id = table->tableInfoGet()->idGet();
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
-  ASSIGN_OR_RETURN(uint64 mc_node_id, GetFreeMulticastNodeId(device, session));
+  tdi::Flags *flags = new tdi::Flags(0);
+
+  ASSIGN_OR_RETURN(uint64 mc_node_id, GetFreeMulticastNodeId(dev_id, session));
 
   // Key: $MULTICAST_NODE_ID
-  RETURN_IF_ERROR(SetField(table_key.get(), kMcNodeId, mc_node_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMcNodeId, mc_node_id));
   // Data: $MULTICAST_RID (16 bit)
   RETURN_IF_ERROR(
       SetField(table_data.get(), kMcReplicationId, mc_replication_id));
@@ -1832,68 +2061,77 @@ namespace {
   RETURN_IF_ERROR(SetField(table_data.get(), kMcNodeLagId, mc_lag_ids));
   // Data: $DEV_PORT
   RETURN_IF_ERROR(SetField(table_data.get(), kMcNodeDevPort, ports));
-
-  RETURN_IF_BFRT_ERROR(table->tableEntryAdd(
-      *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
-
+  RETURN_IF_TDI_ERROR(table->entryAdd(
+      *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
   return mc_node_id;
 }
 
-::util::StatusOr<std::vector<uint32>> BfSdeWrapper::GetNodesInMulticastGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::StatusOr<std::vector<uint32>> TdiSdeWrapper::GetNodesInMulticastGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 group_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
 
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreMgidTable, &table));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreMgidTable, &table));
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
   // Key: $MGID
-  RETURN_IF_ERROR(SetField(table_key.get(), kMgid, group_id));
-  RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-      *real_session->bfrt_session_, bf_dev_tgt, *table_key,
-      bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, table_data.get()));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMgid, group_id));
+  RETURN_IF_TDI_ERROR(table->entryGet(
+      *real_session->tdirt_session_,*dev_tgt, *flags, *table_key,
+      table_data.get()));
   // Data: $MULTICAST_NODE_ID
   std::vector<uint32> mc_node_list;
   RETURN_IF_ERROR(GetField(*table_data, kMcNodeId, &mc_node_list));
-
   return mc_node_list;
+
+  return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::DeleteMulticastNodes(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::DeleteMulticastNodes(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const std::vector<uint32>& mc_node_ids) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  bf_rt_id_t table_id;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreNodeTable, &table));
-  RETURN_IF_BFRT_ERROR(table->tableIdGet(&table_id));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  tdi_id_t table_id;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreNodeTable, &table));
+  table_id = table->tableInfoGet()->idGet();
 
   // TODO(max): handle partial delete failures
   for (const auto& mc_node_id : mc_node_ids) {
-    std::unique_ptr<bfrt::BfRtTableKey> table_key;
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-    RETURN_IF_ERROR(SetField(table_key.get(), kMcNodeId, mc_node_id));
-    RETURN_IF_BFRT_ERROR(table->tableEntryDel(*real_session->bfrt_session_,
-                                              bf_dev_tgt, *table_key));
+    std::unique_ptr<tdi::TableKey> table_key;
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+    RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMcNodeId, mc_node_id));
+    RETURN_IF_TDI_ERROR(table->entryDel(*real_session->tdirt_session_,
+                                         *dev_tgt, *flags, *table_key));
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetMulticastNode(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetMulticastNode(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 mc_node_id, int* replication_id, std::vector<uint32>* lag_ids,
     std::vector<uint32>* ports) {
   CHECK_RETURN_IF_FALSE(replication_id);
@@ -1903,21 +2141,26 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;  // PRE node table.
-  bf_rt_id_t table_id;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreNodeTable, &table));
-  RETURN_IF_BFRT_ERROR(table->tableIdGet(&table_id));
-
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;  // PRE node table.
+  tdi_id_t table_id;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreNodeTable, &table));
+  table_id = table->tableInfoGet()->idGet();
+
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
   // Key: $MULTICAST_NODE_ID
-  RETURN_IF_ERROR(SetField(table_key.get(), kMcNodeId, mc_node_id));
-  RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-      *real_session->bfrt_session_, bf_dev_tgt, *table_key,
-      bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, table_data.get()));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMcNodeId, mc_node_id));
+  RETURN_IF_TDI_ERROR(table->entryGet(
+      *real_session->tdirt_session_, *dev_tgt, *flags, *table_key,
+      table_data.get()));
   // Data: $DEV_PORT
   std::vector<uint32> dev_ports;
   RETURN_IF_ERROR(GetField(*table_data, kMcNodeDevPort, &dev_ports));
@@ -1934,20 +2177,28 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::WriteMulticastGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::WriteMulticastGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 group_id, const std::vector<uint32>& mc_node_ids, bool insert) {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;  // PRE MGID table.
-  bf_rt_id_t table_id;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreMgidTable, &table));
-  RETURN_IF_BFRT_ERROR(table->tableIdGet(&table_id));
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  const tdi::Table* table;  // PRE MGID table.
+  tdi_id_t table_id;
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreMgidTable, &table));
+  table_id = table->tableInfoGet()->idGet();
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
 
   std::vector<uint32> mc_node_list;
   std::vector<bool> l1_xid_valid_list;
@@ -1959,7 +2210,7 @@ namespace {
     l1_xid_list.push_back(0);
   }
   // Key: $MGID
-  RETURN_IF_ERROR(SetField(table_key.get(), kMgid, group_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMgid, group_id));
   // Data: $MULTICAST_NODE_ID
   RETURN_IF_ERROR(SetField(table_data.get(), kMcNodeId, mc_node_list));
   // Data: $MULTICAST_NODE_L1_XID_VALID
@@ -1968,54 +2219,62 @@ namespace {
   // Data: $MULTICAST_NODE_L1_XID
   RETURN_IF_ERROR(SetField(table_data.get(), kMcNodeL1Xid, l1_xid_list));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
   if (insert) {
-    RETURN_IF_BFRT_ERROR(table->tableEntryAdd(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+    RETURN_IF_TDI_ERROR(table->entryAdd(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
 
   } else {
-    RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+    RETURN_IF_TDI_ERROR(table->entryMod(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::InsertMulticastGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::InsertMulticastGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 group_id, const std::vector<uint32>& mc_node_ids) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteMulticastGroup(device, session, group_id, mc_node_ids, true);
+  return WriteMulticastGroup(dev_id, session, group_id, mc_node_ids, true);
+
+  return ::util::OkStatus();
 }
-::util::Status BfSdeWrapper::ModifyMulticastGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ModifyMulticastGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 group_id, const std::vector<uint32>& mc_node_ids) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteMulticastGroup(device, session, group_id, mc_node_ids, false);
+  return WriteMulticastGroup(dev_id, session, group_id, mc_node_ids, false);
+
+  return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::DeleteMulticastGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::DeleteMulticastGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 group_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;  // PRE MGID table.
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreMgidTable, &table));
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;  // PRE MGID table.
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreMgidTable, &table));
+  std::unique_ptr<tdi::TableKey> table_key;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
   // Key: $MGID
-  RETURN_IF_ERROR(SetField(table_key.get(), kMgid, group_id));
-  RETURN_IF_BFRT_ERROR(table->tableEntryDel(*real_session->bfrt_session_,
-                                            bf_dev_tgt, *table_key));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMgid, group_id));
+  RETURN_IF_TDI_ERROR(table->entryDel(*real_session->tdirt_session_,
+                                            *dev_tgt, *flags, *table_key));
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetMulticastGroups(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetMulticastGroups(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 group_id, std::vector<uint32>* group_ids,
     std::vector<std::vector<uint32>>* mc_node_ids) {
   CHECK_RETURN_IF_FALSE(group_ids);
@@ -2024,36 +2283,41 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;  // PRE MGID table.
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromNameGet(kPreMgidTable, &table));
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;  // PRE MGID table.
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromNameGet(kPreMgidTable, &table));
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
   // Is this a wildcard read?
   if (group_id != 0) {
     keys.resize(1);
     datums.resize(1);
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[0]));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&datums[0]));
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[0]));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&datums[0]));
     // Key: $MGID
-    RETURN_IF_ERROR(SetField(keys[0].get(), kMgid, group_id));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *keys[0],
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, datums[0].get()));
+    RETURN_IF_ERROR(SetFieldExact(keys[0].get(), kMgid, group_id));
+    RETURN_IF_TDI_ERROR(table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *keys[0],
+        datums[0].get()));
   } else {
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
   }
 
   group_ids->resize(0);
   mc_node_ids->resize(0);
   for (size_t i = 0; i < keys.size(); ++i) {
-    const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-    const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+    const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+    const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
     ::p4::v1::MulticastGroupEntry result;
     // Key: $MGID
-    uint64 group_id;
-    RETURN_IF_ERROR(GetField(*table_key, kMgid, &group_id));
+    uint32_t group_id = 0;
+    RETURN_IF_ERROR(GetFieldExact(*table_key, kMgid, &group_id));
     group_ids->push_back(group_id);
     // Data: $MULTICAST_NODE_ID
     std::vector<uint32> mc_node_list;
@@ -2067,24 +2331,33 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::WriteCloneSession(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::WriteCloneSession(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 session_id, int egress_port, int cos, int max_pkt_len, bool insert) {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(
-      bfrt_info_->bfrtTableFromNameGet(kMirrorConfigTable, &table));
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  bf_rt_id_t action_id;
-  RETURN_IF_BFRT_ERROR(table->actionIdGet("$normal", &action_id));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(action_id, &table_data));
+  const tdi::Table* table;
+  const tdi::Device *device = nullptr;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(
+      tdi_info_->tableFromNameGet(kMirrorConfigTable, &table));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  tdi_id_t action_id;
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet("$normal");
+  RETURN_IF_NULL(dataFieldInfo);
+  action_id = dataFieldInfo->idGet();
+  RETURN_IF_TDI_ERROR(table->dataAllocate(action_id, &table_data));
 
   // Key: $sid
-  RETURN_IF_ERROR(SetField(table_key.get(), "$sid", session_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), "$sid", session_id));
   // Data: $direction
   RETURN_IF_ERROR(SetField(table_data.get(), "$direction", "BOTH"));
   // Data: $session_enable
@@ -2100,62 +2373,73 @@ namespace {
   // Data: $max_pkt_len
   RETURN_IF_ERROR(SetField(table_data.get(), "$max_pkt_len", max_pkt_len));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
   if (insert) {
-    RETURN_IF_BFRT_ERROR(table->tableEntryAdd(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+    RETURN_IF_TDI_ERROR(table->entryAdd(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
   } else {
-    RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+    RETURN_IF_TDI_ERROR(table->entryMod(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::InsertCloneSession(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::InsertCloneSession(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 session_id, int egress_port, int cos, int max_pkt_len) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteCloneSession(device, session, session_id, egress_port, cos,
+  return WriteCloneSession(dev_id, session, session_id, egress_port, cos,
                            max_pkt_len, true);
+
+  return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::ModifyCloneSession(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ModifyCloneSession(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 session_id, int egress_port, int cos, int max_pkt_len) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteCloneSession(device, session, session_id, egress_port, cos,
+  return WriteCloneSession(dev_id, session, session_id, egress_port, cos,
                            max_pkt_len, false);
+
+  return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::DeleteCloneSession(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::DeleteCloneSession(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 session_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
+  const tdi::DataFieldInfo *dataFieldInfo;
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(
-      bfrt_info_->bfrtTableFromNameGet(kMirrorConfigTable, &table));
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  bf_rt_id_t action_id;
-  RETURN_IF_BFRT_ERROR(table->actionIdGet("$normal", &action_id));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(action_id, &table_data));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(
+      tdi_info_->tableFromNameGet(kMirrorConfigTable, &table));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  tdi_id_t action_id;
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet("$normal");
+  RETURN_IF_NULL(dataFieldInfo);
+  action_id = dataFieldInfo->idGet();
+  RETURN_IF_TDI_ERROR(table->dataAllocate(action_id, &table_data));
   // Key: $sid
-  RETURN_IF_ERROR(SetField(table_key.get(), "$sid", session_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), "$sid", session_id));
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryDel(*real_session->bfrt_session_,
-                                            bf_dev_tgt, *table_key));
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->entryDel(*real_session->tdirt_session_,
+                                      *dev_tgt, *flags, *table_key));
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetCloneSessions(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetCloneSessions(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 session_id, std::vector<uint32>* session_ids,
     std::vector<int>* egress_ports, std::vector<int>* coss,
     std::vector<int>* max_pkt_lens) {
@@ -2165,29 +2449,37 @@ namespace {
   CHECK_RETURN_IF_FALSE(max_pkt_lens);
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
+  const tdi::DataFieldInfo *dataFieldInfo;
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(
-      bfrt_info_->bfrtTableFromNameGet(kMirrorConfigTable, &table));
-  bf_rt_id_t action_id;
-  RETURN_IF_BFRT_ERROR(table->actionIdGet("$normal", &action_id));
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(
+      tdi_info_->tableFromNameGet(kMirrorConfigTable, &table));
+  tdi_id_t action_id;
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet("$normal");
+  RETURN_IF_NULL(dataFieldInfo);
+  action_id = dataFieldInfo->idGet();
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
   // Is this a wildcard read?
   if (session_id != 0) {
     keys.resize(1);
     datums.resize(1);
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[0]));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(action_id, &datums[0]));
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[0]));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(action_id, &datums[0]));
     // Key: $sid
-    RETURN_IF_ERROR(SetField(keys[0].get(), "$sid", session_id));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *keys[0],
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, datums[0].get()));
+    RETURN_IF_ERROR(SetFieldExact(keys[0].get(), "$sid", session_id));
+    RETURN_IF_TDI_ERROR(table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *keys[0],
+        datums[0].get()));
   } else {
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
   }
 
@@ -2196,11 +2488,11 @@ namespace {
   coss->resize(0);
   max_pkt_lens->resize(0);
   for (size_t i = 0; i < keys.size(); ++i) {
-    const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-    const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+    const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+    const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
     // Key: $sid
-    uint64 session_id;
-    RETURN_IF_ERROR(GetField(*table_key, "$sid", &session_id));
+    uint32_t session_id = 0;
+    RETURN_IF_ERROR(GetFieldExact(*table_key, "$sid", &session_id));
     session_ids->push_back(session_id);
     // Data: $ingress_cos
     uint64 ingress_cos;
@@ -2216,12 +2508,12 @@ namespace {
     egress_ports->push_back(port);
     // Data: $session_enable
     bool session_enable;
-    RETURN_IF_ERROR(GetField(*table_data, "$session_enable", &session_enable));
+    RETURN_IF_ERROR(GetFieldBool(*table_data, "$session_enable", &session_enable));
     CHECK_RETURN_IF_FALSE(session_enable)
         << "Found a session that is not enabled.";
     // Data: $ucast_egress_port_valid
     bool ucast_egress_port_valid;
-    RETURN_IF_ERROR(GetField(*table_data, "$ucast_egress_port_valid",
+    RETURN_IF_ERROR(GetFieldBool(*table_data, "$ucast_egress_port_valid",
                              &ucast_egress_port_valid));
     CHECK_RETURN_IF_FALSE(ucast_egress_port_valid)
         << "Found a unicase egress port that is not set valid.";
@@ -2235,51 +2527,63 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::WriteIndirectCounter(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::WriteIndirectCounter(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 counter_id, int counter_index, absl::optional<uint64> byte_count,
     absl::optional<uint64> packet_count) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
+  const tdi::DataFieldInfo *dataFieldInfo;
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(counter_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(counter_id, &table));
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
 
   // Counter key: $COUNTER_INDEX
-  RETURN_IF_ERROR(SetField(table_key.get(), kCounterIndex, counter_index));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kCounterIndex, counter_index));
 
   // Counter data: $COUNTER_SPEC_BYTES
   if (byte_count.has_value()) {
-    bf_rt_id_t field_id;
-    auto bf_status = table->dataFieldIdGet(kCounterBytes, &field_id);
-    if (bf_status == BF_SUCCESS) {
-      RETURN_IF_BFRT_ERROR(table_data->setValue(field_id, byte_count.value()));
-    }
+    tdi_id_t field_id;
+    dataFieldInfo = table->tableInfoGet()->dataFieldGet(kCounterBytes);
+    RETURN_IF_NULL(dataFieldInfo);
+    field_id = dataFieldInfo->idGet();
+    RETURN_IF_TDI_ERROR(table_data->setValue(field_id, byte_count.value()));
   }
   // Counter data: $COUNTER_SPEC_PKTS
   if (packet_count.has_value()) {
-    bf_rt_id_t field_id;
-    auto bf_status = table->dataFieldIdGet(kCounterPackets, &field_id);
-    if (bf_status == BF_SUCCESS) {
-      RETURN_IF_BFRT_ERROR(
+    tdi_id_t field_id;
+    dataFieldInfo = table->tableInfoGet()->dataFieldGet(kCounterPackets);
+    RETURN_IF_NULL(dataFieldInfo);
+    field_id = dataFieldInfo->idGet();
+    RETURN_IF_TDI_ERROR(
           table_data->setValue(field_id, packet_count.value()));
-    }
   }
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-      *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  if(byte_count.value() == 0 && packet_count.value() == 0) {
+    LOG(INFO) << "Resetting counters";
+    RETURN_IF_TDI_ERROR(table->clear(
+      *real_session->tdirt_session_, *dev_tgt, *flags));
+  } else {
+    RETURN_IF_TDI_ERROR(table->entryMod(
+     *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
+  }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::ReadIndirectCounter(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ReadIndirectCounter(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 counter_id, absl::optional<uint32> counter_index,
     std::vector<uint32>* counter_indices,
     std::vector<absl::optional<uint64>>* byte_counts,
@@ -2292,29 +2596,35 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(counter_id, &table));
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(counter_id, &table));
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
 
-  RETURN_IF_ERROR(DoSynchronizeCounters(device, session, counter_id, timeout));
+  RETURN_IF_ERROR(DoSynchronizeCounters(dev_id, session, counter_id, timeout));
 
   // Is this a wildcard read?
   if (counter_index) {
     keys.resize(1);
     datums.resize(1);
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[0]));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&datums[0]));
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[0]));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&datums[0]));
 
     // Key: $COUNTER_INDEX
     RETURN_IF_ERROR(
-        SetField(keys[0].get(), kCounterIndex, counter_index.value()));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *keys[0],
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, datums[0].get()));
+        SetFieldExact(keys[0].get(), kCounterIndex, counter_index.value()));
+    RETURN_IF_TDI_ERROR(table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *keys[0],
+        datums[0].get()));
+
   } else {
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
   }
 
@@ -2322,31 +2632,32 @@ namespace {
   byte_counts->resize(0);
   packet_counts->resize(0);
   for (size_t i = 0; i < keys.size(); ++i) {
-    const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-    const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+    const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+    const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
     // Key: $COUNTER_INDEX
-    uint64 bf_counter_index;
-    RETURN_IF_ERROR(GetField(*table_key, kCounterIndex, &bf_counter_index));
-    counter_indices->push_back(bf_counter_index);
+    uint32_t tdi_counter_index = 0;
+    RETURN_IF_ERROR(GetFieldExact(*table_key, kCounterIndex, &tdi_counter_index));
+    counter_indices->push_back(tdi_counter_index);
 
     absl::optional<uint64> byte_count;
     absl::optional<uint64> packet_count;
     // Counter data: $COUNTER_SPEC_BYTES
-    bf_rt_id_t field_id;
-    auto bf_status = table->dataFieldIdGet(kCounterBytes, &field_id);
-    if (bf_status == BF_SUCCESS) {
-      uint64 counter_data;
-      RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &counter_data));
-      byte_count = counter_data;
+    tdi_id_t field_id;
+
+    if (table->tableInfoGet()->dataFieldGet(kCounterBytes)) {
+      field_id = table->tableInfoGet()->dataFieldGet(kCounterBytes)->idGet();
+      uint64 counter_bytes;
+      RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &counter_bytes));
+      byte_count = counter_bytes;
     }
     byte_counts->push_back(byte_count);
 
     // Counter data: $COUNTER_SPEC_PKTS
-    bf_status = table->dataFieldIdGet(kCounterPackets, &field_id);
-    if (bf_status == BF_SUCCESS) {
-      uint64 counter_data;
-      RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &counter_data));
-      packet_count = counter_data;
+    if (table->tableInfoGet()->dataFieldGet(kCounterPackets)) {
+      field_id = table->tableInfoGet()->dataFieldGet(kCounterPackets)->idGet();
+      uint64 counter_pkts;
+      RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &counter_pkts));
+      packet_count = counter_pkts;
     }
     packet_counts->push_back(packet_count);
   }
@@ -2362,87 +2673,101 @@ namespace {
 // Helper function to get the field ID of the "f1" register data field.
 // TODO(max): Maybe use table name and strip off "pipe." at the beginning?
 // std::string table_name;
-// RETURN_IF_BFRT_ERROR(table->tableNameGet(&table_name));
-// RETURN_IF_BFRT_ERROR(
+// RETURN_IF_TDI_ERROR(table->tableNameGet(&table_name));
+// RETURN_IF_TDI_ERROR(
 //     table->dataFieldIdGet(absl::StrCat(table_name, ".", "f1"), &field_id));
-::util::StatusOr<bf_rt_id_t> GetRegisterDataFieldId(
-    const bfrt::BfRtTable* table) {
-  std::vector<bf_rt_id_t> data_field_ids;
-  RETURN_IF_BFRT_ERROR(table->dataFieldIdListGet(&data_field_ids));
+
+::util::StatusOr<tdi_id_t> GetRegisterDataFieldId(
+    const tdi::Table* table) {
+  std::vector<tdi_id_t> data_field_ids;
+  const tdi::DataFieldInfo *dataFieldInfo;
+  data_field_ids = table->tableInfoGet()->dataFieldIdListGet();
   for (const auto& field_id : data_field_ids) {
     std::string field_name;
-    RETURN_IF_BFRT_ERROR(table->dataFieldNameGet(field_id, &field_name));
-    bfrt::DataType data_type;
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(field_id, &data_type));
+    dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_id);
+    RETURN_IF_NULL(dataFieldInfo);
+    field_name = dataFieldInfo->nameGet();
+    tdi_field_data_type_e data_type;
+    data_type = dataFieldInfo->dataTypeGet();
     if (absl::EndsWith(field_name, ".f1")) {
       return field_id;
     }
   }
 
   RETURN_ERROR(ERR_INTERNAL) << "Could not find register data field id.";
+
+   return ::util::OkStatus();
 }
 }  // namespace
 
-::util::Status BfSdeWrapper::WriteRegister(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::WriteRegister(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, absl::optional<uint32> register_index,
     const std::string& register_data) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
 
   // Register data: <register_name>.f1
   // The current bf-p4c compiler emits the fully-qualified field name, including
   // parent table and pipeline. We cannot use just "f1" as the field name.
-  bf_rt_id_t field_id;
+  tdi_id_t field_id;
   ASSIGN_OR_RETURN(field_id, GetRegisterDataFieldId(table));
   size_t data_field_size_bits;
-  RETURN_IF_BFRT_ERROR(
-      table->dataFieldSizeGet(field_id, &data_field_size_bits));
+  const tdi::DataFieldInfo *dataFieldInfo;
+  dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_id);
+  RETURN_IF_NULL(dataFieldInfo);
+  data_field_size_bits = dataFieldInfo->sizeGet();
   // The SDE expects a string with the full width.
   std::string value = P4RuntimeByteStringToPaddedByteString(
       register_data, data_field_size_bits);
-  RETURN_IF_BFRT_ERROR(table_data->setValue(
+  RETURN_IF_TDI_ERROR(table_data->setValue(
       field_id, reinterpret_cast<const uint8*>(value.data()), value.size()));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
   if (register_index) {
     // Single index target.
     // Register key: $REGISTER_INDEX
     RETURN_IF_ERROR(
-        SetField(table_key.get(), kRegisterIndex, register_index.value()));
-    RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+        SetFieldExact(table_key.get(), kRegisterIndex, register_index.value()));
+    RETURN_IF_TDI_ERROR(table->entryMod(
+        *real_session->tdirt_session_, *dev_tgt, *flags,
+        *table_key, *table_data));
   } else {
     // Wildcard write to all indices.
     size_t table_size;
 #if defined(SDE_9_4_0) || defined(SDE_9_5_0)
-    RETURN_IF_BFRT_ERROR(table->tableSizeGet(*real_session->bfrt_session_,
-                                             bf_dev_tgt, &table_size));
+    RETURN_IF_TDI_ERROR(table->sizeGet(*real_session->tdirt_session_,
+                                       *dev_tgt, *flags, &table_size));
 #else
-    RETURN_IF_BFRT_ERROR(table->tableSizeGet(&table_size));
+    RETURN_IF_TDI_ERROR(table->sizeGet(&table_size));
 #endif  // SDE_9_4_0
     for (size_t i = 0; i < table_size; ++i) {
       // Register key: $REGISTER_INDEX
-      RETURN_IF_ERROR(SetField(table_key.get(), kRegisterIndex, i));
-      RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-          *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+      RETURN_IF_ERROR(SetFieldExact(table_key.get(), kRegisterIndex, i));
+      RETURN_IF_TDI_ERROR(table->entryMod(
+          *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
     }
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::ReadRegisters(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ReadRegisters(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, absl::optional<uint32> register_index,
     std::vector<uint32>* register_indices, std::vector<uint64>* register_datas,
     absl::Duration timeout) {
@@ -2452,52 +2777,60 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  RETURN_IF_ERROR(SynchronizeRegisters(device, session, table_id, timeout));
+  RETURN_IF_ERROR(SynchronizeRegisters(dev_id, session, table_id, timeout));
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
 
   // Is this a wildcard read?
   if (register_index) {
     keys.resize(1);
     datums.resize(1);
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[0]));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&datums[0]));
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[0]));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&datums[0]));
 
     // Key: $REGISTER_INDEX
     RETURN_IF_ERROR(
-        SetField(keys[0].get(), kRegisterIndex, register_index.value()));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *keys[0],
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, datums[0].get()));
+        SetFieldExact(keys[0].get(), kRegisterIndex, register_index.value()));
+    RETURN_IF_TDI_ERROR(table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *keys[0],
+        datums[0].get()));
   } else {
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
   }
 
   register_indices->resize(0);
   register_datas->resize(0);
   for (size_t i = 0; i < keys.size(); ++i) {
-    const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-    const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+    const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+    const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
     // Key: $REGISTER_INDEX
-    uint64 bf_register_index;
-    RETURN_IF_ERROR(GetField(*table_key, kRegisterIndex, &bf_register_index));
-    register_indices->push_back(bf_register_index);
+    uint32_t tdi_register_index = 0;
+    RETURN_IF_ERROR(GetFieldExact(*table_key, kRegisterIndex, &tdi_register_index));
+    register_indices->push_back(tdi_register_index);
     // Data: <register_name>.f1
     ASSIGN_OR_RETURN(auto f1_field_id, GetRegisterDataFieldId(table));
 
-    bfrt::DataType data_type;
-    RETURN_IF_BFRT_ERROR(table->dataFieldDataTypeGet(f1_field_id, &data_type));
+    tdi_field_data_type_e data_type;
+    const tdi::DataFieldInfo *dataFieldInfo;
+    dataFieldInfo = table->tableInfoGet()->dataFieldGet(f1_field_id);
+    RETURN_IF_NULL(dataFieldInfo);
+    data_type = dataFieldInfo->dataTypeGet();
     switch (data_type) {
-      case bfrt::DataType::BYTE_STREAM: {
+      case TDI_FIELD_DATA_TYPE_BYTE_STREAM: {
         // Even though the data type says byte stream, the SDE can only allows
         // fetching the data in an uint64 vector with one entry per pipe.
         std::vector<uint64> register_data;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(f1_field_id, &register_data));
+        RETURN_IF_TDI_ERROR(table_data->getValue(f1_field_id, &register_data));
         CHECK_RETURN_IF_FALSE(register_data.size() > 0);
         register_datas->push_back(register_data[0]);
         break;
@@ -2515,21 +2848,21 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::WriteIndirectMeter(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::WriteIndirectMeter(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, absl::optional<uint32> meter_index, bool in_pps,
     uint64 cir, uint64 cburst, uint64 pir, uint64 pburst) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
 
   // Meter data: $METER_SPEC_*
   if (in_pps) {
@@ -2549,36 +2882,41 @@ namespace {
                              BytesPerSecondToKbits(pburst)));
   }
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
   if (meter_index) {
     // Single index target.
     // Meter key: $METER_INDEX
     RETURN_IF_ERROR(
-        SetField(table_key.get(), kMeterIndex, meter_index.value()));
-    RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+        SetFieldExact(table_key.get(), kMeterIndex, meter_index.value()));
+    RETURN_IF_TDI_ERROR(table->entryMod(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
   } else {
     // Wildcard write to all indices.
     size_t table_size;
 #if defined(SDE_9_4_0) || defined(SDE_9_5_0)
-    RETURN_IF_BFRT_ERROR(table->tableSizeGet(*real_session->bfrt_session_,
-                                             bf_dev_tgt, &table_size));
+    RETURN_IF_TDI_ERROR(table->sizeGet(*real_session->tdirt_session_,
+                                       *dev_tgt, *flags, &table_size));
 #else
-    RETURN_IF_BFRT_ERROR(table->tableSizeGet(&table_size));
+    RETURN_IF_TDI_ERROR(table->sizeGet(&table_size));
 #endif  // SDE_9_4_0
     for (size_t i = 0; i < table_size; ++i) {
       // Meter key: $METER_INDEX
-      RETURN_IF_ERROR(SetField(table_key.get(), kMeterIndex, i));
-      RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-          *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data));
+      RETURN_IF_ERROR(SetFieldExact(table_key.get(), kMeterIndex, i));
+      RETURN_IF_TDI_ERROR(table->entryMod(
+          *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data));
     }
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::ReadIndirectMeters(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ReadIndirectMeters(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, absl::optional<uint32> meter_index,
     std::vector<uint32>* meter_indices, std::vector<uint64>* cirs,
     std::vector<uint64>* cbursts, std::vector<uint64>* pirs,
@@ -2592,26 +2930,31 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
 
   // Is this a wildcard read?
   if (meter_index) {
     keys.resize(1);
     datums.resize(1);
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[0]));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&datums[0]));
-
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[0]));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&datums[0]));
     // Key: $METER_INDEX
-    RETURN_IF_ERROR(SetField(keys[0].get(), kMeterIndex, meter_index.value()));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *keys[0],
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, datums[0].get()));
+    RETURN_IF_ERROR(SetFieldExact(keys[0].get(), kMeterIndex,
+                    meter_index.value()));
+    RETURN_IF_TDI_ERROR(table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *keys[0],
+        datums[0].get()));
   } else {
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
   }
 
@@ -2622,52 +2965,55 @@ namespace {
   pbursts->resize(0);
   in_pps->resize(0);
   for (size_t i = 0; i < keys.size(); ++i) {
-    const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-    const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+    const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+    const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
     // Key: $METER_INDEX
-    uint64 bf_meter_index;
-    RETURN_IF_ERROR(GetField(*table_key, kMeterIndex, &bf_meter_index));
-    meter_indices->push_back(bf_meter_index);
+    uint32_t tdi_meter_index = 0;
+    RETURN_IF_ERROR(GetFieldExact(*table_key, kMeterIndex, &tdi_meter_index));
+    meter_indices->push_back(tdi_meter_index);
 
     // Data: $METER_SPEC_*
-    std::vector<bf_rt_id_t> data_field_ids;
-    RETURN_IF_BFRT_ERROR(table->dataFieldIdListGet(&data_field_ids));
+    std::vector<tdi_id_t> data_field_ids;
+    data_field_ids = table->tableInfoGet()->dataFieldIdListGet();
     for (const auto& field_id : data_field_ids) {
       std::string field_name;
-      RETURN_IF_BFRT_ERROR(table->dataFieldNameGet(field_id, &field_name));
+      const tdi::DataFieldInfo *dataFieldInfo;
+      dataFieldInfo = table->tableInfoGet()->dataFieldGet(field_id);
+      RETURN_IF_NULL(dataFieldInfo);
+      field_name = dataFieldInfo->nameGet();
       if (field_name == kMeterCirKbps) {  // kbits
         uint64 cir;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &cir));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &cir));
         cirs->push_back(KbitsToBytesPerSecond(cir));
         in_pps->push_back(false);
       } else if (field_name == kMeterCommitedBurstKbits) {
         uint64 cburst;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &cburst));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &cburst));
         cbursts->push_back(KbitsToBytesPerSecond(cburst));
       } else if (field_name == kMeterPirKbps) {
         uint64 pir;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &pir));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &pir));
         pirs->push_back(KbitsToBytesPerSecond(pir));
       } else if (field_name == kMeterPeakBurstKbits) {
         uint64 pburst;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &pburst));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &pburst));
         pbursts->push_back(KbitsToBytesPerSecond(pburst));
       } else if (field_name == kMeterCirPps) {  // Packets
         uint64 cir;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &cir));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &cir));
         cirs->push_back(cir);
         in_pps->push_back(true);
       } else if (field_name == kMeterCommitedBurstPackets) {
         uint64 cburst;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &cburst));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &cburst));
         cbursts->push_back(cburst);
       } else if (field_name == kMeterPirPps) {
         uint64 pir;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &pir));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &pir));
         pirs->push_back(pir);
       } else if (field_name == kMeterPeakBurstPackets) {
         uint64 pburst;
-        RETURN_IF_BFRT_ERROR(table_data->getValue(field_id, &pburst));
+        RETURN_IF_TDI_ERROR(table_data->getValue(field_id, &pburst));
         pbursts->push_back(pburst);
       } else {
         RETURN_ERROR(ERR_INVALID_PARAM)
@@ -2687,8 +3033,8 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::WriteActionProfileMember(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::WriteActionProfileMember(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int member_id, const TableDataInterface* table_data,
     bool insert) {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
@@ -2696,12 +3042,14 @@ namespace {
   auto real_table_data = dynamic_cast<const TableData*>(table_data);
   CHECK_RETURN_IF_FALSE(real_table_data);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
+  std::unique_ptr<tdi::TableKey> table_key;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
 
+  // DumpTableMetadata(table);
+  // DumpTableData(real_table_data->table_data_.get());
   auto dump_args = [&]() -> std::string {
     return absl::StrCat(
         DumpTableMetadata(table).ValueOr("<error reading table>"),
@@ -2710,54 +3058,58 @@ namespace {
         DumpTableData(real_table_data->table_data_.get())
             .ValueOr("<error parsing data>"));
   };
-
   // Key: $ACTION_MEMBER_ID
-  RETURN_IF_ERROR(SetField(table_key.get(), kActionMemberId, member_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kActionMemberId,
+                                member_id));
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
+  tdi::Flags *flags = new tdi::Flags(0);
   if (insert) {
-    RETURN_IF_BFRT_ERROR(table->tableEntryAdd(*real_session->bfrt_session_,
-                                              bf_dev_tgt, *table_key,
-                                              *real_table_data->table_data_))
+    RETURN_IF_TDI_ERROR(table->entryAdd(*real_session->tdirt_session_,
+                                        *dev_tgt, *flags, *table_key,
+                                        *real_table_data->table_data_))
         << "Could not add action profile member with: " << dump_args();
   } else {
-    RETURN_IF_BFRT_ERROR(table->tableEntryMod(*real_session->bfrt_session_,
-                                              bf_dev_tgt, *table_key,
-                                              *real_table_data->table_data_))
+    RETURN_IF_TDI_ERROR(table->entryMod(*real_session->tdirt_session_,
+                                             *dev_tgt, *flags, *table_key,
+                                             *real_table_data->table_data_))
         << "Could not modify action profile member with: " << dump_args();
   }
-
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::InsertActionProfileMember(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::InsertActionProfileMember(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int member_id, const TableDataInterface* table_data) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteActionProfileMember(device, session, table_id, member_id,
+  return WriteActionProfileMember(dev_id, session, table_id, member_id,
                                   table_data, true);
 }
 
-::util::Status BfSdeWrapper::ModifyActionProfileMember(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ModifyActionProfileMember(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int member_id, const TableDataInterface* table_data) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteActionProfileMember(device, session, table_id, member_id,
+  return WriteActionProfileMember(dev_id, session, table_id, member_id,
                                   table_data, false);
 }
 
-::util::Status BfSdeWrapper::DeleteActionProfileMember(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::DeleteActionProfileMember(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int member_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
+  std::unique_ptr<tdi::TableKey> table_key;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
 
   auto dump_args = [&]() -> std::string {
     return absl::StrCat(
@@ -2767,18 +3119,23 @@ namespace {
   };
 
   // Key: $ACTION_MEMBER_ID
-  RETURN_IF_ERROR(SetField(table_key.get(), kActionMemberId, member_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kActionMemberId,
+                                member_id));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryDel(*real_session->bfrt_session_,
-                                            bf_dev_tgt, *table_key))
-      << "Could not delete action profile member with: " << dump_args();
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->entryDel(*real_session->tdirt_session_,
+                                      *dev_tgt, *flags, *table_key))
+      << "Could not delete action profile member with: " << dump_args();
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetActionProfileMembers(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetActionProfileMembers(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int member_id, std::vector<int>* member_ids,
     std::vector<std::unique_ptr<TableDataInterface>>* table_datas) {
   CHECK_RETURN_IF_FALSE(member_ids);
@@ -2787,24 +3144,29 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
   // Is this a wildcard read?
   if (member_id != 0) {
     keys.resize(1);
     datums.resize(1);
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[0]));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&datums[0]));
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[0]));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&datums[0]));
     // Key: $ACTION_MEMBER_ID
-    RETURN_IF_ERROR(SetField(keys[0].get(), kActionMemberId, member_id));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *keys[0],
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, datums[0].get()));
+    RETURN_IF_ERROR(SetFieldExact(keys[0].get(), kActionMemberId, member_id));
+    RETURN_IF_TDI_ERROR(table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *keys[0],
+        datums[0].get()));
   } else {
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
   }
 
@@ -2812,8 +3174,8 @@ namespace {
   table_datas->resize(0);
   for (size_t i = 0; i < keys.size(); ++i) {
     // Key: $sid
-    uint64 member_id;
-    RETURN_IF_ERROR(GetField(*keys[i], kActionMemberId, &member_id));
+    uint32_t member_id = 0;
+    RETURN_IF_ERROR(GetFieldExact(*keys[i], kActionMemberId, &member_id));
     member_ids->push_back(member_id);
 
     // Data: action params
@@ -2827,21 +3189,21 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::WriteActionProfileGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::WriteActionProfileGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int group_id, int max_group_size,
     const std::vector<uint32>& member_ids,
     const std::vector<bool>& member_status, bool insert) {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  std::unique_ptr<bfrt::BfRtTableData> table_data;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
-  RETURN_IF_BFRT_ERROR(table->dataAllocate(&table_data));
+  std::unique_ptr<tdi::TableKey> table_key;
+  std::unique_ptr<tdi::TableData> table_data;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
+  RETURN_IF_TDI_ERROR(table->dataAllocate(&table_data));
 
   // We have to capture the std::unique_ptrs by reference [&] here.
   auto dump_args = [&]() -> std::string {
@@ -2854,7 +3216,7 @@ namespace {
   };
 
   // Key: $SELECTOR_GROUP_ID
-  RETURN_IF_ERROR(SetField(table_key.get(), kSelectorGroupId, group_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kSelectorGroupId, group_id));
   // Data: $ACTION_MEMBER_ID
   RETURN_IF_ERROR(SetField(table_data.get(), kActionMemberId, member_ids));
   // Data: $ACTION_MEMBER_STATUS
@@ -2864,53 +3226,58 @@ namespace {
   RETURN_IF_ERROR(
       SetField(table_data.get(), "$MAX_GROUP_SIZE", max_group_size));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
   if (insert) {
-    RETURN_IF_BFRT_ERROR(table->tableEntryAdd(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data))
+    RETURN_IF_TDI_ERROR(table->entryAdd(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data))
         << "Could not add action profile group with: " << dump_args();
   } else {
-    RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-        *real_session->bfrt_session_, bf_dev_tgt, *table_key, *table_data))
+    RETURN_IF_TDI_ERROR(table->entryMod(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *table_key, *table_data))
         << "Could not modify action profile group with: " << dump_args();
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::InsertActionProfileGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::InsertActionProfileGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int group_id, int max_group_size,
     const std::vector<uint32>& member_ids,
     const std::vector<bool>& member_status) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteActionProfileGroup(device, session, table_id, group_id,
+  return WriteActionProfileGroup(dev_id, session, table_id, group_id,
                                  max_group_size, member_ids, member_status,
                                  true);
 }
 
-::util::Status BfSdeWrapper::ModifyActionProfileGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ModifyActionProfileGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int group_id, int max_group_size,
     const std::vector<uint32>& member_ids,
     const std::vector<bool>& member_status) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return WriteActionProfileGroup(device, session, table_id, group_id,
+  return WriteActionProfileGroup(dev_id, session, table_id, group_id,
                                  max_group_size, member_ids, member_status,
                                  false);
 }
 
-::util::Status BfSdeWrapper::DeleteActionProfileGroup(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::DeleteActionProfileGroup(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int group_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  std::unique_ptr<bfrt::BfRtTableKey> table_key;
-  RETURN_IF_BFRT_ERROR(table->keyAllocate(&table_key));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+  std::unique_ptr<tdi::TableKey> table_key;
+  RETURN_IF_TDI_ERROR(table->keyAllocate(&table_key));
 
   auto dump_args = [&]() -> std::string {
     return absl::StrCat(
@@ -2920,18 +3287,23 @@ namespace {
   };
 
   // Key: $SELECTOR_GROUP_ID
-  RETURN_IF_ERROR(SetField(table_key.get(), kSelectorGroupId, group_id));
+  RETURN_IF_ERROR(SetFieldExact(table_key.get(), kSelectorGroupId, group_id));
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryDel(*real_session->bfrt_session_,
-                                            bf_dev_tgt, *table_key))
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->entryDel(*real_session->tdirt_session_,
+                                            *dev_tgt, *flags, *table_key))
       << "Could not delete action profile group with: " << dump_args();
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetActionProfileGroups(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetActionProfileGroups(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, int group_id, std::vector<int>* group_ids,
     std::vector<int>* max_group_sizes,
     std::vector<std::vector<uint32>>* member_ids,
@@ -2944,24 +3316,29 @@ namespace {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
   // Is this a wildcard read?
   if (group_id != 0) {
     keys.resize(1);
     datums.resize(1);
-    RETURN_IF_BFRT_ERROR(table->keyAllocate(&keys[0]));
-    RETURN_IF_BFRT_ERROR(table->dataAllocate(&datums[0]));
+    RETURN_IF_TDI_ERROR(table->keyAllocate(&keys[0]));
+    RETURN_IF_TDI_ERROR(table->dataAllocate(&datums[0]));
     // Key: $SELECTOR_GROUP_ID
-    RETURN_IF_ERROR(SetField(keys[0].get(), kSelectorGroupId, group_id));
-    RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-        *real_session->bfrt_session_, bf_dev_tgt, *keys[0],
-        bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW, datums[0].get()));
+    RETURN_IF_ERROR(SetFieldExact(keys[0].get(), kSelectorGroupId, group_id));
+    RETURN_IF_TDI_ERROR(table->entryGet(
+        *real_session->tdirt_session_, *dev_tgt, *flags, *keys[0],
+        datums[0].get()));
   } else {
-    RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt,
+    RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt,
                                   table, &keys, &datums));
   }
 
@@ -2970,11 +3347,11 @@ namespace {
   member_ids->resize(0);
   member_status->resize(0);
   for (size_t i = 0; i < keys.size(); ++i) {
-    const std::unique_ptr<bfrt::BfRtTableData>& table_data = datums[i];
-    const std::unique_ptr<bfrt::BfRtTableKey>& table_key = keys[i];
+    const std::unique_ptr<tdi::TableData>& table_data = datums[i];
+    const std::unique_ptr<tdi::TableKey>& table_key = keys[i];
     // Key: $SELECTOR_GROUP_ID
-    uint64 group_id;
-    RETURN_IF_ERROR(GetField(*table_key, kSelectorGroupId, &group_id));
+    uint32_t group_id = 0;
+    RETURN_IF_ERROR(GetFieldExact(*table_key, kSelectorGroupId, &group_id));
     group_ids->push_back(group_id);
 
     // Data: $MAX_GROUP_SIZE
@@ -3002,10 +3379,11 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::InsertTableEntry(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::InsertTableEntry(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, const TableKeyInterface* table_key,
     const TableDataInterface* table_data) {
+
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
@@ -3014,8 +3392,8 @@ namespace {
   auto real_table_data = dynamic_cast<const TableData*>(table_data);
   CHECK_RETURN_IF_FALSE(real_table_data);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
   auto dump_args = [&]() -> std::string {
     return absl::StrCat(
@@ -3027,19 +3405,29 @@ namespace {
             .ValueOr("<error parsing data>"));
   };
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryAdd(
-      *real_session->bfrt_session_, bf_dev_tgt, *real_table_key->table_key_,
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  /* Note: When multiple pipeline support is added, for device target
+   * pipeline id also should be set
+   */
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->entryAdd(
+      *real_session->tdirt_session_, *dev_tgt, *flags, *real_table_key->table_key_,
       *real_table_data->table_data_))
       << "Could not add table entry with: " << dump_args();
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::ModifyTableEntry(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ModifyTableEntry(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, const TableKeyInterface* table_key,
     const TableDataInterface* table_data) {
+
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
@@ -3047,8 +3435,9 @@ namespace {
   CHECK_RETURN_IF_FALSE(real_table_key);
   auto real_table_data = dynamic_cast<const TableData*>(table_data);
   CHECK_RETURN_IF_FALSE(real_table_data);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
   auto dump_args = [&]() -> std::string {
     return absl::StrCat(
@@ -3060,25 +3449,31 @@ namespace {
             .ValueOr("<error parsing data>"));
   };
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryMod(
-      *real_session->bfrt_session_, bf_dev_tgt, *real_table_key->table_key_,
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->entryMod(
+      *real_session->tdirt_session_, *dev_tgt, *flags, *real_table_key->table_key_,
       *real_table_data->table_data_))
       << "Could not modify table entry with: " << dump_args();
-
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::DeleteTableEntry(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::DeleteTableEntry(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, const TableKeyInterface* table_key) {
+
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
   auto real_table_key = dynamic_cast<const TableKey*>(table_key);
   CHECK_RETURN_IF_FALSE(real_table_key);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
   auto dump_args = [&]() -> std::string {
     return absl::StrCat(
@@ -3087,16 +3482,21 @@ namespace {
             .ValueOr("<error parsing key>"));
   };
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryDel(
-      *real_session->bfrt_session_, bf_dev_tgt, *real_table_key->table_key_))
-      << "Could not delete table entry with: " << dump_args();
+  // TDI comments; Hardcoding device = 0
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->entryDel(
+      *real_session->tdirt_session_, *dev_tgt, *flags, *real_table_key->table_key_))
+      << "Could not delete table entry with: " << dump_args();
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetTableEntry(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetTableEntry(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, const TableKeyInterface* table_key,
     TableDataInterface* table_data) {
   ::absl::ReaderMutexLock l(&data_lock_);
@@ -3106,35 +3506,41 @@ namespace {
   CHECK_RETURN_IF_FALSE(real_table_key);
   auto real_table_data = dynamic_cast<const TableData*>(table_data);
   CHECK_RETURN_IF_FALSE(real_table_data);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableEntryGet(
-      *real_session->bfrt_session_, bf_dev_tgt, *real_table_key->table_key_,
-      bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW,
-      real_table_data->table_data_.get()));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->entryGet(
+      *real_session->tdirt_session_, *dev_tgt, *flags, *real_table_key->table_key_,
+      real_table_data->table_data_.get()));
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetAllTableEntries(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetAllTableEntries(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id,
     std::vector<std::unique_ptr<TableKeyInterface>>* table_keys,
     std::vector<std::unique_ptr<TableDataInterface>>* table_datas) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-  auto bf_dev_tgt = GetDeviceTarget(device);
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  std::vector<std::unique_ptr<bfrt::BfRtTableKey>> keys;
-  std::vector<std::unique_ptr<bfrt::BfRtTableData>> datums;
-  RETURN_IF_ERROR(GetAllEntries(real_session->bfrt_session_, bf_dev_tgt, table,
-                                &keys, &datums));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
+  std::vector<std::unique_ptr<tdi::TableKey>> keys;
+  std::vector<std::unique_ptr<tdi::TableData>> datums;
+  RETURN_IF_ERROR(GetAllEntries(real_session->tdirt_session_, *dev_tgt, table,
+                                &keys, &datums));
   table_keys->resize(0);
   table_datas->resize(0);
 
@@ -3148,111 +3554,132 @@ namespace {
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::SetDefaultTableEntry(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::SetDefaultTableEntry(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, const TableDataInterface* table_data) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
   auto real_table_data = dynamic_cast<const TableData*>(table_data);
   CHECK_RETURN_IF_FALSE(real_table_data);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableDefaultEntrySet(
-      *real_session->bfrt_session_, bf_dev_tgt, *real_table_data->table_data_));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->defaultEntrySet(
+      *real_session->tdirt_session_, *dev_tgt,
+      *flags, *real_table_data->table_data_));
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::ResetDefaultTableEntry(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::ResetDefaultTableEntry(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(
-      table->tableDefaultEntryReset(*real_session->bfrt_session_, bf_dev_tgt));
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(
+      table->defaultEntryReset(*real_session->tdirt_session_, *dev_tgt, *flags));
 
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::GetDefaultTableEntry(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::GetDefaultTableEntry(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, TableDataInterface* table_data) {
   ::absl::ReaderMutexLock l(&data_lock_);
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
   auto real_table_data = dynamic_cast<const TableData*>(table_data);
   CHECK_RETURN_IF_FALSE(real_table_data);
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
-
-  auto bf_dev_tgt = GetDeviceTarget(device);
-  RETURN_IF_BFRT_ERROR(table->tableDefaultEntryGet(
-      *real_session->bfrt_session_, bf_dev_tgt,
-      bfrt::BfRtTable::BfRtTableGetFlag::GET_FROM_SW,
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
+
+  tdi::Flags *flags = new tdi::Flags(0);
+  RETURN_IF_TDI_ERROR(table->defaultEntryGet(
+      *real_session->tdirt_session_, *dev_tgt,
+      *flags,
       real_table_data->table_data_.get()));
 
   return ::util::OkStatus();
 }
 
-::util::StatusOr<uint32> BfSdeWrapper::GetBfRtId(uint32 p4info_id) const {
+::util::StatusOr<uint32> TdiSdeWrapper::GetTdiRtId(uint32 p4info_id) const {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return bfrt_id_mapper_->GetBfRtId(p4info_id);
+  return tdirt_id_mapper_->GetTdiRtId(p4info_id);
 }
 
-::util::StatusOr<uint32> BfSdeWrapper::GetP4InfoId(uint32 bfrt_id) const {
+::util::StatusOr<uint32> TdiSdeWrapper::GetP4InfoId(uint32 tdirt_id) const {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return bfrt_id_mapper_->GetP4InfoId(bfrt_id);
+  return tdirt_id_mapper_->GetP4InfoId(tdirt_id);
 }
 
-::util::StatusOr<uint32> BfSdeWrapper::GetActionSelectorBfRtId(
+::util::StatusOr<uint32> TdiSdeWrapper::GetActionSelectorTdiRtId(
     uint32 action_profile_id) const {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return bfrt_id_mapper_->GetActionSelectorBfRtId(action_profile_id);
+  return tdirt_id_mapper_->GetActionSelectorTdiRtId(action_profile_id);
 }
 
-::util::StatusOr<uint32> BfSdeWrapper::GetActionProfileBfRtId(
+::util::StatusOr<uint32> TdiSdeWrapper::GetActionProfileTdiRtId(
     uint32 action_selector_id) const {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return bfrt_id_mapper_->GetActionProfileBfRtId(action_selector_id);
+  return tdirt_id_mapper_->GetActionProfileTdiRtId(action_selector_id);
 }
 
-::util::Status BfSdeWrapper::SynchronizeCounters(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::SynchronizeCounters(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, absl::Duration timeout) {
   ::absl::ReaderMutexLock l(&data_lock_);
-  return DoSynchronizeCounters(device, session, table_id, timeout);
+  return DoSynchronizeCounters(dev_id, session, table_id, timeout);
 }
 
-::util::Status BfSdeWrapper::DoSynchronizeCounters(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::DoSynchronizeCounters(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, absl::Duration timeout) {
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
   // Sync table counter
-  std::set<bfrt::TableOperationsType> supported_ops;
-  RETURN_IF_BFRT_ERROR(table->tableOperationsSupported(&supported_ops));
-  if (supported_ops.count(bfrt::TableOperationsType::COUNTER_SYNC)) {
+  std::set<tdi_operations_type_e> supported_ops;
+  supported_ops = table->tableInfoGet()->operationsSupported();
+  // TODO TDI comments : Uncomment this after SDE exposes counterSyncSet
+#if 0
+  if (supported_ops.count(static_cast<tdi_operations_type_e>(tdi_rt_operations_type_e::COUNTER_SYNC))) {
     auto sync_notifier = std::make_shared<absl::Notification>();
     std::weak_ptr<absl::Notification> weak_ref(sync_notifier);
-    std::unique_ptr<bfrt::BfRtTableOperations> table_op;
-    RETURN_IF_BFRT_ERROR(table->operationsAllocate(
-        bfrt::TableOperationsType::COUNTER_SYNC, &table_op));
-    RETURN_IF_BFRT_ERROR(table_op->counterSyncSet(
-        *real_session->bfrt_session_, bf_dev_tgt,
-        [table_id, weak_ref](const bf_rt_target_t& dev_tgt, void* cookie) {
+    std::unique_ptr<tdi::TableOperations> table_op;
+    RETURN_IF_TDI_ERROR(table->operationsAllocate(
+          static_cast<tdi_operations_type_e>(tdi_rt_operations_type_e::COUNTER_SYNC), &table_op));
+    RETURN_IF_TDI_ERROR(table_op->counterSyncSet(
+        *real_session->tdirt_session_, dev_tgt,
+        [table_id, weak_ref](const tdi::Target& dev_tgt, void* cookie) {
           if (auto notifier = weak_ref.lock()) {
             VLOG(1) << "Table counter for table " << table_id << " synced.";
             notifier->Notify();
@@ -3262,7 +3689,7 @@ namespace {
           }
         },
         nullptr));
-    RETURN_IF_BFRT_ERROR(table->tableOperationsExecute(*table_op.get()));
+    RETURN_IF_TDI_ERROR(table->tableOperationsExecute(*table_op.get()));
     // Wait until sync done or timeout.
     if (!sync_notifier->WaitForNotificationWithTimeout(timeout)) {
       return MAKE_ERROR(ERR_OPER_TIMEOUT)
@@ -3270,32 +3697,43 @@ namespace {
              << table_id << ".";
     }
   }
-
+#endif
   return ::util::OkStatus();
 }
 
-::util::Status BfSdeWrapper::SynchronizeRegisters(
-    int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiSdeWrapper::SynchronizeRegisters(
+    int dev_id, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 table_id, absl::Duration timeout) {
+
   auto real_session = std::dynamic_pointer_cast<Session>(session);
   CHECK_RETURN_IF_FALSE(real_session);
 
-  const bfrt::BfRtTable* table;
-  RETURN_IF_BFRT_ERROR(bfrt_info_->bfrtTableFromIdGet(table_id, &table));
+  const tdi::Table* table;
+  RETURN_IF_TDI_ERROR(tdi_info_->tableFromIdGet(table_id, &table));
+
+  const tdi::Device *device = nullptr;
+  tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+  std::unique_ptr<tdi::Target> dev_tgt;
+  device->createTarget(&dev_tgt);
 
-  auto bf_dev_tgt = GetDeviceTarget(device);
   // Sync table registers.
-  std::set<bfrt::TableOperationsType> supported_ops;
-  RETURN_IF_BFRT_ERROR(table->tableOperationsSupported(&supported_ops));
-  if (supported_ops.count(bfrt::TableOperationsType::REGISTER_SYNC)) {
+  // TDI comments ; its supposed to be tdi_rt_operations_type_e ??
+  //const std::set<tdi_rt_operations_type_e> supported_ops;
+  //supported_ops = static_cast<tdi_rt_operations_type_e>(table->tableInfoGet()->operationsSupported());
+
+  std::set<tdi_operations_type_e> supported_ops;
+  supported_ops = table->tableInfoGet()->operationsSupported();
+  // TODO TDI comments : Need to uncomment this after SDE exposes registerSyncSet
+#if 0
+  if (supported_ops.count(static_cast<tdi_operations_type_e>(tdi_rt_operations_type_e::REGISTER_SYNC))) {
     auto sync_notifier = std::make_shared<absl::Notification>();
     std::weak_ptr<absl::Notification> weak_ref(sync_notifier);
-    std::unique_ptr<bfrt::BfRtTableOperations> table_op;
-    RETURN_IF_BFRT_ERROR(table->operationsAllocate(
-        bfrt::TableOperationsType::REGISTER_SYNC, &table_op));
-    RETURN_IF_BFRT_ERROR(table_op->registerSyncSet(
-        *real_session->bfrt_session_, bf_dev_tgt,
-        [table_id, weak_ref](const bf_rt_target_t& dev_tgt, void* cookie) {
+    std::unique_ptr<tdi::TableOperations> table_op;
+    RETURN_IF_TDI_ERROR(table->operationsAllocate(
+          static_cast<tdi_operations_type_e>(tdi_rt_operations_type_e::REGISTER_SYNC), &table_op));
+    RETURN_IF_TDI_ERROR(table_op->registerSyncSet(
+        *real_session->tdirt_session_, dev_tgt,
+        [table_id, weak_ref](const tdi::Target& dev_tgt, void* cookie) {
           if (auto notifier = weak_ref.lock()) {
             VLOG(1) << "Table registers for table " << table_id << " synced.";
             notifier->Notify();
@@ -3305,7 +3743,7 @@ namespace {
           }
         },
         nullptr));
-    RETURN_IF_BFRT_ERROR(table->tableOperationsExecute(*table_op.get()));
+    RETURN_IF_TDI_ERROR(table->tableOperationsExecute(*table_op.get()));
     // Wait until sync done or timeout.
     if (!sync_notifier->WaitForNotificationWithTimeout(timeout)) {
       return MAKE_ERROR(ERR_OPER_TIMEOUT)
@@ -3313,20 +3751,20 @@ namespace {
              << table_id << ".";
     }
   }
-
+#endif
   return ::util::OkStatus();
 }
 
-BfSdeWrapper* BfSdeWrapper::CreateSingleton() {
+TdiSdeWrapper* TdiSdeWrapper::CreateSingleton() {
   absl::WriterMutexLock l(&init_lock_);
   if (!singleton_) {
-    singleton_ = new BfSdeWrapper();
+    singleton_ = new TdiSdeWrapper();
   }
 
   return singleton_;
 }
 
-BfSdeWrapper* BfSdeWrapper::GetSingleton() {
+TdiSdeWrapper* TdiSdeWrapper::GetSingleton() {
   absl::ReaderMutexLock l(&init_lock_);
   return singleton_;
 }
diff --git a/stratum/hal/lib/barefoot/bf_sde_wrapper.h b/stratum/hal/lib/barefoot/bf_sde_wrapper.h
index f8b9962d..b717df51 100644
--- a/stratum/hal/lib/barefoot/bf_sde_wrapper.h
+++ b/stratum/hal/lib/barefoot/bf_sde_wrapper.h
@@ -11,11 +11,10 @@
 
 #include "absl/container/flat_hash_map.h"
 #include "absl/synchronization/mutex.h"
-#include "bf_rt/bf_rt_init.hpp"
-#include "bf_rt/bf_rt_session.hpp"
-#include "bf_rt/bf_rt_table.hpp"
-#include "bf_rt/bf_rt_table_key.hpp"
+
+#ifdef P4SDE_DPDK_TARGET_STUB
 #include "pkt_mgr/pkt_mgr_intf.h"
+#endif
 #include "stratum/glue/integral_types.h"
 #include "stratum/glue/status/status.h"
 #include "stratum/glue/status/statusor.h"
@@ -25,13 +24,22 @@
 #include "stratum/hal/lib/common/common.pb.h"
 #include "stratum/lib/channel/channel.h"
 
+#include "tdi/common/tdi_info.hpp"
+#include "tdi/common/tdi_table.hpp"
+#include "tdi/common/tdi_table_key.hpp"
+#include "tdi/common/tdi_defs.h"
+#include "tdi_rt/tdi_rt_defs.h"
+#include "tdi/common/tdi_init.hpp"
+#include "tdi/common/tdi_json_parser/tdi_table_info.hpp"
+#include "tdi/arch/pna/pna_defs.h"
+
 namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class TableKey : public BfSdeInterface::TableKeyInterface {
+class TableKey : public TdiSdeInterface::TableKeyInterface {
  public:
-  explicit TableKey(std::unique_ptr<bfrt::BfRtTableKey> table_key)
+  explicit TableKey(std::unique_ptr<tdi::TableKey> table_key)
       : table_key_(std::move(table_key)) {}
 
   // TableKeyInterface public methods.
@@ -49,23 +57,23 @@ class TableKey : public BfSdeInterface::TableKeyInterface {
                           const std::string& high) override;
   ::util::Status GetRange(int id, std::string* low,
                           std::string* high) const override;
-  ::util::Status SetPriority(uint32 priority) override;
+  ::util::Status SetPriority(uint64 priority) override;
   ::util::Status GetPriority(uint32* priority) const override;
 
   // Allocates a new table key object.
-  static ::util::StatusOr<std::unique_ptr<BfSdeInterface::TableKeyInterface>>
-  CreateTableKey(const bfrt::BfRtInfo* bfrt_info_, int table_id);
+  static ::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableKeyInterface>>
+  CreateTableKey(const tdi::TdiInfo* tdi_info_, int table_id);
 
   // Stores the underlying SDE object.
-  std::unique_ptr<bfrt::BfRtTableKey> table_key_;
+  std::unique_ptr<tdi::TableKey> table_key_;
 
  private:
   TableKey() {}
 };
 
-class TableData : public BfSdeInterface::TableDataInterface {
+class TableData : public TdiSdeInterface::TableDataInterface {
  public:
-  explicit TableData(std::unique_ptr<bfrt::BfRtTableData> table_data)
+  explicit TableData(std::unique_ptr<tdi::TableData> table_data)
       : table_data_(std::move(table_data)) {}
 
   // TableDataInterface public methods.
@@ -81,66 +89,69 @@ class TableData : public BfSdeInterface::TableDataInterface {
   ::util::Status Reset(int action_id) override;
 
   // Allocates a new table data object.
-  static ::util::StatusOr<std::unique_ptr<BfSdeInterface::TableDataInterface>>
-  CreateTableData(const bfrt::BfRtInfo* bfrt_info_, int table_id,
+  static ::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableDataInterface>>
+  CreateTableData(const tdi::TdiInfo* tdi_info_, int table_id,
                   int action_id);
 
   // Stores the underlying SDE object.
-  std::unique_ptr<bfrt::BfRtTableData> table_data_;
+  std::unique_ptr<tdi::TableData> table_data_;
 
  private:
   TableData() {}
 };
 
-// The "BfSdeWrapper" is an implementation of BfSdeInterface which is used
+// The "TdiSdeWrapper" is an implementation of TdiSdeInterface which is used
 // on real hardware to talk to the Tofino ASIC.
-class BfSdeWrapper : public BfSdeInterface {
+class TdiSdeWrapper : public TdiSdeInterface {
  public:
   // Default MTU for ports on Tofino.
   static constexpr int32 kBfDefaultMtu = 10 * 1024;  // 10K
 
-  // Wrapper around the bfrt session object.
-  class Session : public BfSdeInterface::SessionInterface {
+  // Wrapper around the tdirt session object.
+  class Session : public TdiSdeInterface::SessionInterface {
    public:
     // SessionInterface public methods.
     ::util::Status BeginBatch() override {
-      RETURN_IF_BFRT_ERROR(bfrt_session_->beginBatch());
+      RETURN_IF_TDI_ERROR(tdirt_session_->beginBatch());
       return ::util::OkStatus();
     }
     ::util::Status EndBatch() override {
-      RETURN_IF_BFRT_ERROR(bfrt_session_->endBatch(/*hardware sync*/ true));
-      RETURN_IF_BFRT_ERROR(bfrt_session_->sessionCompleteOperations());
+      RETURN_IF_TDI_ERROR(tdirt_session_->endBatch(/*hardware sync*/ true));
+      RETURN_IF_TDI_ERROR(tdirt_session_->completeOperations());
       return ::util::OkStatus();
     }
 
-    static ::util::StatusOr<std::shared_ptr<BfSdeInterface::SessionInterface>>
+    static ::util::StatusOr<std::shared_ptr<TdiSdeInterface::SessionInterface>>
     CreateSession() {
-      auto bfrt_session = bfrt::BfRtSession::sessionCreate();
-      CHECK_RETURN_IF_FALSE(bfrt_session) << "Failed to create new session.";
-      VLOG(1) << "Started new BfRt session with ID "
-              << bfrt_session->sessHandleGet();
+      std::shared_ptr<tdi::Session> tdirt_session;
+      const tdi::Device *device = nullptr;
+      uint32 dev_id = 0;
+      tdi::DevMgr::getInstance().deviceGet(dev_id, &device);
+      device->createSession(&tdirt_session);
+
+      CHECK_RETURN_IF_FALSE(tdirt_session) << "Failed to create new session.";
 
-      return std::shared_ptr<BfSdeInterface::SessionInterface>(
-          new Session(bfrt_session));
+      return std::shared_ptr<TdiSdeInterface::SessionInterface>(
+          new Session(tdirt_session));
     }
 
     // Stores the underlying SDE session.
-    std::shared_ptr<bfrt::BfRtSession> bfrt_session_;
+    std::shared_ptr<tdi::Session> tdirt_session_;
 
    private:
     // Private constructor. Use CreateSession() instead.
     Session() {}
-    explicit Session(std::shared_ptr<bfrt::BfRtSession> bfrt_session)
-        : bfrt_session_(bfrt_session) {}
+    explicit Session(std::shared_ptr<tdi::Session> tdirt_session)
+        : tdirt_session_(tdirt_session) {}
   };
 
-  // BfSdeInterface public methods.
+  // TdiSdeInterface public methods.
   ::util::Status InitializeSde(const std::string& sde_install_path,
                                const std::string& sde_config_file,
                                bool run_in_background) override;
   ::util::Status AddDevice(int device,
-                           const BfrtDeviceConfig& device_config) override;
-  ::util::StatusOr<std::shared_ptr<BfSdeInterface::SessionInterface>>
+                           const TdirtDeviceConfig& device_config) override;
+  ::util::StatusOr<std::shared_ptr<TdiSdeInterface::SessionInterface>>
   CreateSession() override;
   ::util::StatusOr<std::unique_ptr<TableKeyInterface>> CreateTableKey(
       int table_id) override;
@@ -154,8 +165,14 @@ class BfSdeWrapper : public BfSdeInterface {
       LOCKS_EXCLUDED(port_status_event_writer_lock_);
   ::util::Status UnregisterPortStatusEventWriter() override
       LOCKS_EXCLUDED(port_status_event_writer_lock_);
+  ::util::Status GetPortInfo(int device, int port,
+                             TargetDatapathId *target_dp_id) override;
   ::util::Status AddPort(int device, int port, uint64 speed_bps,
                          FecMode fec_mode) override;
+  ::util::Status AddPort(int device, int port, uint64 speed_bps,
+                         PortConfigParams& config, FecMode fec_mode) override;
+  ::util::Status HotplugPort(int device, int port,
+                            HotplugConfigParams& hotplug_config) override;
   ::util::Status DeletePort(int device, int port) override;
   ::util::Status EnablePort(int device, int port) override;
   ::util::Status DisablePort(int device, int port) override;
@@ -186,190 +203,187 @@ class BfSdeWrapper : public BfSdeInterface {
       int device, std::unique_ptr<ChannelWriter<std::string>> writer) override;
   ::util::Status UnregisterPacketReceiveWriter(int device) override;
   ::util::StatusOr<uint32> CreateMulticastNode(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       int mc_replication_id, const std::vector<uint32>& mc_lag_ids,
       const std::vector<uint32>& ports) override LOCKS_EXCLUDED(data_lock_);
   ::util::StatusOr<std::vector<uint32>> GetNodesInMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status DeleteMulticastNodes(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const std::vector<uint32>& mc_node_ids) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetMulticastNode(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 mc_node_id, int* replication_id, std::vector<uint32>* lag_ids,
       std::vector<uint32>* ports) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status InsertMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id, const std::vector<uint32>& mc_node_ids) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status ModifyMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id, const std::vector<uint32>& mc_node_ids) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status DeleteMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetMulticastGroups(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id, std::vector<uint32>* group_ids,
       std::vector<std::vector<uint32>>* mc_node_ids) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status InsertCloneSession(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id, int egress_port, int cos, int max_pkt_len) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status ModifyCloneSession(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id, int egress_port, int cos, int max_pkt_len) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status DeleteCloneSession(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetCloneSessions(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id, std::vector<uint32>* session_ids,
       std::vector<int>* egress_ports, std::vector<int>* coss,
       std::vector<int>* max_pkt_lens) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status WriteIndirectCounter(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 counter_id, int counter_index, absl::optional<uint64> byte_count,
       absl::optional<uint64> packet_count) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status ReadIndirectCounter(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 counter_id, absl::optional<uint32> counter_index,
       std::vector<uint32>* counter_indices,
       std::vector<absl::optional<uint64>>* byte_counts,
       std::vector<absl::optional<uint64>>* packet_counts,
       absl::Duration timeout) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status WriteRegister(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> register_index,
       const std::string& register_data) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status ReadRegisters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> register_index,
       std::vector<uint32>* register_indices,
       std::vector<uint64>* register_datas, absl::Duration timeout) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status WriteIndirectMeter(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> meter_index, bool in_pps,
       uint64 cir, uint64 cburst, uint64 pir, uint64 pburst) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status ReadIndirectMeters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::optional<uint32> meter_index,
       std::vector<uint32>* meter_indices, std::vector<uint64>* cirs,
       std::vector<uint64>* cbursts, std::vector<uint64>* pirs,
       std::vector<uint64>* pbursts, std::vector<bool>* in_pps) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status InsertActionProfileMember(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id,
       const TableDataInterface* table_data) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status ModifyActionProfileMember(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id,
       const TableDataInterface* table_data) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status DeleteActionProfileMember(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetActionProfileMembers(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id, std::vector<int>* member_ids,
       std::vector<std::unique_ptr<TableDataInterface>>* table_datas) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status InsertActionProfileGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id, int max_group_size,
       const std::vector<uint32>& member_ids,
       const std::vector<bool>& member_status) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status ModifyActionProfileGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id, int max_group_size,
       const std::vector<uint32>& member_ids,
       const std::vector<bool>& member_status) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status DeleteActionProfileGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetActionProfileGroups(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id, std::vector<int>* group_ids,
       std::vector<int>* max_group_sizes,
       std::vector<std::vector<uint32>>* member_ids,
       std::vector<std::vector<bool>>* member_status) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status SynchronizeCounters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::Duration timeout) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status InsertTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key,
       const TableDataInterface* table_data) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status ModifyTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key,
       const TableDataInterface* table_data) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status DeleteTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableKeyInterface* table_key,
       TableDataInterface* table_data) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetAllTableEntries(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id,
       std::vector<std::unique_ptr<TableKeyInterface>>* table_keys,
       std::vector<std::unique_ptr<TableDataInterface>>* table_datas) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status SetDefaultTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, const TableDataInterface* table_data) override
       LOCKS_EXCLUDED(data_lock_);
   ::util::Status ResetDefaultTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id) override LOCKS_EXCLUDED(data_lock_);
   ::util::Status GetDefaultTableEntry(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, TableDataInterface* table_data) override
       LOCKS_EXCLUDED(data_lock_);
 
-  ::util::StatusOr<uint32> GetBfRtId(uint32 p4info_id) const override
+  ::util::StatusOr<uint32> GetTdiRtId(uint32 p4info_id) const override
       LOCKS_EXCLUDED(data_lock_);
-  ::util::StatusOr<uint32> GetP4InfoId(uint32 bfrt_id) const override
+  ::util::StatusOr<uint32> GetP4InfoId(uint32 tdirt_id) const override
       LOCKS_EXCLUDED(data_lock_);
-  ::util::StatusOr<uint32> GetActionSelectorBfRtId(
+  ::util::StatusOr<uint32> GetActionSelectorTdiRtId(
       uint32 action_profile_id) const override LOCKS_EXCLUDED(data_lock_);
-  ::util::StatusOr<uint32> GetActionProfileBfRtId(
+  ::util::StatusOr<uint32> GetActionProfileTdiRtId(
       uint32 action_selector_id) const override LOCKS_EXCLUDED(data_lock_);
 
-  // Gets the device target (device id + pipe id) for a specific BfRt
-  // primitive (e.g. table).
-  // FIXME: Now we only return the device target with pipe "BF_DEV_PIPE_ALL"
-  bf_rt_target_t GetDeviceTarget(int device) const;
-
   // Creates the singleton instance. Expected to be called once to initialize
   // the instance.
-  static BfSdeWrapper* CreateSingleton() LOCKS_EXCLUDED(init_lock_);
+  static TdiSdeWrapper* CreateSingleton() LOCKS_EXCLUDED(init_lock_);
 
   // The following public functions are specific to this class. They are to be
   // called by SDE callbacks only.
 
   // Return the singleton instance to be used in the SDE callbacks.
-  static BfSdeWrapper* GetSingleton() LOCKS_EXCLUDED(init_lock_);
+  static TdiSdeWrapper* GetSingleton() LOCKS_EXCLUDED(init_lock_);
 
+#ifdef P4SDE_DPDK_TARGET_STUB
   // Writes a received packet to the registered Rx writer. Called from the SDE
   // callback function.
   ::util::Status HandlePacketRx(bf_dev_id_t device, bf_pkt* pkt,
                                 bf_pkt_rx_ring_t rx_ring)
       LOCKS_EXCLUDED(packet_rx_callback_lock_);
+#endif
 
   // Called whenever a port status event is received from SDK. It forwards the
   // port status event to the module who registered a callback by calling
@@ -378,11 +392,11 @@ class BfSdeWrapper : public BfSdeInterface {
                                    absl::Time timestamp)
       LOCKS_EXCLUDED(port_status_event_writer_lock_);
 
-  // BfSdeWrapper is neither copyable nor movable.
-  BfSdeWrapper(const BfSdeWrapper&) = delete;
-  BfSdeWrapper& operator=(const BfSdeWrapper&) = delete;
-  BfSdeWrapper(BfSdeWrapper&&) = delete;
-  BfSdeWrapper& operator=(BfSdeWrapper&&) = delete;
+  // TdiSdeWrapper is neither copyable nor movable.
+  TdiSdeWrapper(const TdiSdeWrapper&) = delete;
+  TdiSdeWrapper& operator=(const TdiSdeWrapper&) = delete;
+  TdiSdeWrapper(TdiSdeWrapper&&) = delete;
+  TdiSdeWrapper& operator=(TdiSdeWrapper&&) = delete;
 
  protected:
   // RW mutex lock for protecting the singleton instance initialization and
@@ -391,14 +405,14 @@ class BfSdeWrapper : public BfSdeInterface {
   static absl::Mutex init_lock_;
 
   // The singleton instance.
-  static BfSdeWrapper* singleton_ GUARDED_BY(init_lock_);
+  static TdiSdeWrapper* singleton_ GUARDED_BY(init_lock_);
 
  private:
   // Timeout for Write() operations on port status events.
   static constexpr absl::Duration kWriteTimeout = absl::InfiniteDuration();
 
   // Private constructor, use CreateSingleton and GetSingleton().
-  BfSdeWrapper();
+  TdiSdeWrapper();
 
   // RM Mutex to protect the port status writer.
   mutable absl::Mutex port_status_event_writer_lock_;
@@ -409,6 +423,7 @@ class BfSdeWrapper : public BfSdeInterface {
   // RW mutex lock for protecting the pipeline state.
   mutable absl::Mutex data_lock_;
 
+#ifdef P4SDE_DPDK_TARGET_STUB
   // Callback registed with the SDE for Tx notifications.
   static bf_status_t BfPktTxNotifyCallback(bf_dev_id_t device,
                                            bf_pkt_tx_ring_t tx_ring,
@@ -419,27 +434,29 @@ class BfSdeWrapper : public BfSdeInterface {
                                            void* cookie,
                                            bf_pkt_rx_ring_t rx_ring);
 
+#endif
+
   // Common code for multicast group handling.
   ::util::Status WriteMulticastGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 group_id, const std::vector<uint32>& mc_node_ids, bool insert)
       SHARED_LOCKS_REQUIRED(data_lock_);
 
   // Common code for clone session handling.
   ::util::Status WriteCloneSession(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 session_id, int egress_port, int cos, int max_pkt_len, bool insert)
       SHARED_LOCKS_REQUIRED(data_lock_);
 
   // Common code for action profile member handling.
   ::util::Status WriteActionProfileMember(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int member_id, const TableDataInterface* table_data,
       bool insert) SHARED_LOCKS_REQUIRED(data_lock_);
 
   // Common code for action profile group handling.
   ::util::Status WriteActionProfileGroup(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, int group_id, int max_group_size,
       const std::vector<uint32>& member_ids,
       const std::vector<bool>& member_status, bool insert)
@@ -448,26 +465,26 @@ class BfSdeWrapper : public BfSdeInterface {
   // Helper function to find, but not allocate, at free multicast node id.
   // This function is not optimized for speed yet.
   ::util::StatusOr<uint32> GetFreeMulticastNodeId(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session)
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session)
       SHARED_LOCKS_REQUIRED(data_lock_);
 
   // Helper to dump the entire PRE table state for debugging. Only runs at v=2.
   ::util::Status DumpPreState(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session)
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session)
       SHARED_LOCKS_REQUIRED(data_lock_);
 
   // Synchronizes the driver cached register values with the current hardware
-  // state for a given BfRt table.
+  // state for a given TdiRt table.
   // TODO(max): consolidate with SynchronizeCounters
   ::util::Status SynchronizeRegisters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::Duration timeout)
       SHARED_LOCKS_REQUIRED(data_lock_);
 
   // Internal version SynchronizeCounters without locks.
   // TODO(max): consolidate with SynchronizeRegisters
   ::util::Status DoSynchronizeCounters(
-      int device, std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      int device, std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 table_id, absl::Duration timeout)
       SHARED_LOCKS_REQUIRED(data_lock_);
 
@@ -482,13 +499,11 @@ class BfSdeWrapper : public BfSdeInterface {
 
   // TODO(max): make the following maps to handle multiple devices.
   // Pointer to the ID mapper. Not owned by this class.
-  std::unique_ptr<BfrtIdMapper> bfrt_id_mapper_ GUARDED_BY(data_lock_);
+  std::unique_ptr<TdirtIdMapper> tdirt_id_mapper_ GUARDED_BY(data_lock_);
 
   // Pointer to the current BfR info object. Not owned by this class.
-  const bfrt::BfRtInfo* bfrt_info_ GUARDED_BY(data_lock_);
+  const tdi::TdiInfo* tdi_info_ GUARDED_BY(data_lock_);
 
-  // Pointer to the bfrt device manager. Not owned by this class.
-  bfrt::BfRtDevMgr* bfrt_device_manager_ GUARDED_BY(data_lock_);
 };
 
 }  // namespace barefoot
diff --git a/stratum/hal/lib/barefoot/bf_switch.cc b/stratum/hal/lib/barefoot/bf_switch.cc
index 833decce..74ea0b25 100644
--- a/stratum/hal/lib/barefoot/bf_switch.cc
+++ b/stratum/hal/lib/barefoot/bf_switch.cc
@@ -27,12 +27,12 @@ namespace barefoot {
 using ::stratum::hal::pi::PINode;
 
 BfSwitch::BfSwitch(PhalInterface* phal_interface,
-                   BfChassisManager* bf_chassis_manager,
-                   BfSdeInterface* bf_sde_interface,
+                   TdiChassisManager* tdi_chassis_manager,
+                   TdiSdeInterface* tdi_sde_interface,
                    const std::map<int, PINode*>& unit_to_pi_node)
     : phal_interface_(ABSL_DIE_IF_NULL(phal_interface)),
-      bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)),
-      bf_chassis_manager_(ABSL_DIE_IF_NULL(bf_chassis_manager)),
+      tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)),
+      tdi_chassis_manager_(ABSL_DIE_IF_NULL(tdi_chassis_manager)),
       unit_to_pi_node_(unit_to_pi_node),
       node_id_to_pi_node_() {
   for (const auto& entry : unit_to_pi_node_) {
@@ -50,9 +50,9 @@ BfSwitch::~BfSwitch() {}
   RETURN_IF_ERROR(VerifyChassisConfig(config));
   absl::WriterMutexLock l(&chassis_lock);
   RETURN_IF_ERROR(phal_interface_->PushChassisConfig(config));
-  RETURN_IF_ERROR(bf_chassis_manager_->PushChassisConfig(config));
+  RETURN_IF_ERROR(tdi_chassis_manager_->PushChassisConfig(config));
   ASSIGN_OR_RETURN(const auto& node_id_to_unit,
-                   bf_chassis_manager_->GetNodeIdToUnitMap());
+                   tdi_chassis_manager_->GetNodeIdToUnitMap());
   node_id_to_pi_node_.clear();
   for (const auto& entry : node_id_to_unit) {
     uint64 node_id = entry.first;
@@ -74,13 +74,13 @@ BfSwitch::~BfSwitch() {}
   ::util::Status status = ::util::OkStatus();
   APPEND_STATUS_IF_ERROR(status, phal_interface_->VerifyChassisConfig(config));
   APPEND_STATUS_IF_ERROR(status,
-                         bf_chassis_manager_->VerifyChassisConfig(config));
+                         tdi_chassis_manager_->VerifyChassisConfig(config));
 
   // Get the current copy of the node_id_to_unit from chassis manager. If this
   // fails with ERR_NOT_INITIALIZED, do not verify anything at the node level.
   // Note that we do not expect any change in node_id_to_unit. Any change in
   // this map will be detected in bcm_chassis_manager_->VerifyChassisConfig.
-  auto ret = bf_chassis_manager_->GetNodeIdToUnitMap();
+  auto ret = tdi_chassis_manager_->GetNodeIdToUnitMap();
   if (!ret.ok()) {
     if (ret.status().error_code() != ERR_NOT_INITIALIZED) {
       APPEND_STATUS_IF_ERROR(status, ret.status());
@@ -133,19 +133,19 @@ namespace {
 
   ASSIGN_OR_RETURN(auto* pi_node, GetPINodeFromNodeId(node_id));
   RETURN_IF_ERROR(pi_node->PushForwardingPipelineConfig(config));
-  RETURN_IF_ERROR(bf_chassis_manager_->ReplayPortsConfig(node_id));
+  RETURN_IF_ERROR(tdi_chassis_manager_->ReplayPortsConfig(node_id));
 
   LOG(INFO) << "P4-based forwarding pipeline config pushed successfully to "
             << "node with ID " << node_id << ".";
 
   ASSIGN_OR_RETURN(const auto& node_id_to_unit,
-                   bf_chassis_manager_->GetNodeIdToUnitMap());
+                   tdi_chassis_manager_->GetNodeIdToUnitMap());
 
   CHECK_RETURN_IF_FALSE(gtl::ContainsKey(node_id_to_unit, node_id))
       << "Unable to find unit number for node " << node_id;
   int unit = gtl::FindOrDie(node_id_to_unit, node_id);
-  ASSIGN_OR_RETURN(auto cpu_port, bf_sde_interface_->GetPcieCpuPort(unit));
-  RETURN_IF_ERROR(bf_sde_interface_->SetTmCpuPort(unit, cpu_port));
+  ASSIGN_OR_RETURN(auto cpu_port, tdi_sde_interface_->GetPcieCpuPort(unit));
+  RETURN_IF_ERROR(tdi_sde_interface_->SetTmCpuPort(unit, cpu_port));
   return ::util::OkStatus();
 }
 
@@ -158,7 +158,7 @@ namespace {
 
   ASSIGN_OR_RETURN(auto* pi_node, GetPINodeFromNodeId(node_id));
   RETURN_IF_ERROR(pi_node->SaveForwardingPipelineConfig(config));
-  RETURN_IF_ERROR(bf_chassis_manager_->ReplayPortsConfig(node_id));
+  RETURN_IF_ERROR(tdi_chassis_manager_->ReplayPortsConfig(node_id));
 
   LOG(INFO) << "P4-based forwarding pipeline config saved successfully to "
             << "node with ID " << node_id << ".";
@@ -187,7 +187,7 @@ namespace {
 
 ::util::Status BfSwitch::Shutdown() {
   ::util::Status status = ::util::OkStatus();
-  APPEND_STATUS_IF_ERROR(status, bf_chassis_manager_->Shutdown());
+  APPEND_STATUS_IF_ERROR(status, tdi_chassis_manager_->Shutdown());
   return status;
 }
 
@@ -236,11 +236,11 @@ namespace {
 
 ::util::Status BfSwitch::RegisterEventNotifyWriter(
     std::shared_ptr<WriterInterface<GnmiEventPtr>> writer) {
-  return bf_chassis_manager_->RegisterEventNotifyWriter(writer);
+  return tdi_chassis_manager_->RegisterEventNotifyWriter(writer);
 }
 
 ::util::Status BfSwitch::UnregisterEventNotifyWriter() {
-  return bf_chassis_manager_->UnregisterEventNotifyWriter();
+  return tdi_chassis_manager_->UnregisterEventNotifyWriter();
 }
 
 ::util::Status BfSwitch::RetrieveValue(uint64 node_id,
@@ -265,7 +265,7 @@ namespace {
       case DataRequest::Request::kFrontPanelPortInfo:
       case DataRequest::Request::kLoopbackStatus:
       case DataRequest::Request::kSdnPortId: {
-        auto port_data = bf_chassis_manager_->GetPortData(req);
+        auto port_data = tdi_chassis_manager_->GetPortData(req);
         if (!port_data.ok()) {
           status.Update(port_data.status());
         } else {
@@ -312,11 +312,11 @@ namespace {
 }
 
 std::unique_ptr<BfSwitch> BfSwitch::CreateInstance(
-    PhalInterface* phal_interface, BfChassisManager* bf_chassis_manager,
-    BfSdeInterface* bf_sde_interface,
+    PhalInterface* phal_interface, TdiChassisManager* tdi_chassis_manager,
+    TdiSdeInterface* tdi_sde_interface,
     const std::map<int, PINode*>& unit_to_pi_node) {
-  return absl::WrapUnique(new BfSwitch(phal_interface, bf_chassis_manager,
-                                       bf_sde_interface, unit_to_pi_node));
+  return absl::WrapUnique(new BfSwitch(phal_interface, tdi_chassis_manager,
+                                       tdi_sde_interface, unit_to_pi_node));
 }
 
 ::util::StatusOr<PINode*> BfSwitch::GetPINodeFromUnit(int unit) const {
diff --git a/stratum/hal/lib/barefoot/bf_switch.h b/stratum/hal/lib/barefoot/bf_switch.h
index 76656c8b..748fb3b3 100644
--- a/stratum/hal/lib/barefoot/bf_switch.h
+++ b/stratum/hal/lib/barefoot/bf_switch.h
@@ -67,8 +67,8 @@ class BfSwitch : public SwitchInterface {
 
   // Factory function for creating the instance of the class.
   static std::unique_ptr<BfSwitch> CreateInstance(
-      PhalInterface* phal_interface, BfChassisManager* bf_chassis_manager,
-      BfSdeInterface* bf_sde_interface,
+      PhalInterface* phal_interface, TdiChassisManager* tdi_chassis_manager,
+      TdiSdeInterface* tdi_sde_interface,
       const std::map<int, pi::PINode*>& unit_to_pi_node);
 
   // BfSwitch is neither copyable nor movable.
@@ -80,8 +80,8 @@ class BfSwitch : public SwitchInterface {
  private:
   // Private constructor. Use CreateInstance() to create an instance of this
   // class.
-  BfSwitch(PhalInterface* phal_interface, BfChassisManager* bf_chassis_manager,
-           BfSdeInterface* bf_sde_interface,
+  BfSwitch(PhalInterface* phal_interface, TdiChassisManager* tdi_chassis_manager,
+           TdiSdeInterface* tdi_sde_interface,
            const std::map<int, pi::PINode*>& unit_to_pi_node);
 
   // Helper to get PINode pointer from unit number or return error indicating
@@ -97,12 +97,12 @@ class BfSwitch : public SwitchInterface {
   // instance of this class per chassis.
   PhalInterface* phal_interface_;  // not owned by this class.
 
-  // Pointer to a BfSdeInterface implementation that wraps SDE API calls.
-  BfSdeInterface* bf_sde_interface_;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps SDE API calls.
+  TdiSdeInterface* tdi_sde_interface_;  // not owned by this class.
 
   // Per chassis Managers. Note that there is only one instance of this class
   // per chassis.
-  BfChassisManager* bf_chassis_manager_;  // not owned by the class.
+  TdiChassisManager* tdi_chassis_manager_;  // not owned by the class.
 
   // Map from zero-based unit number corresponding to a node/ASIC to a pointer
   // to PINode which contain all the per-node managers for that node/ASIC. This
diff --git a/stratum/hal/lib/barefoot/bfrt_action_profile_manager.cc b/stratum/hal/lib/barefoot/bfrt_action_profile_manager.cc
index e26cc3a4..89dd89b3 100644
--- a/stratum/hal/lib/barefoot/bfrt_action_profile_manager.cc
+++ b/stratum/hal/lib/barefoot/bfrt_action_profile_manager.cc
@@ -13,21 +13,21 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-BfrtActionProfileManager::BfrtActionProfileManager(
-    BfSdeInterface* bf_sde_interface, int device)
-    : bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)),
+TdiActionProfileManager::TdiActionProfileManager(
+    TdiSdeInterface* tdi_sde_interface, int device)
+    : tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)),
       p4_info_manager_(nullptr),
       device_(device) {}
 
-std::unique_ptr<BfrtActionProfileManager>
-BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
+std::unique_ptr<TdiActionProfileManager>
+TdiActionProfileManager::CreateInstance(TdiSdeInterface* tdi_sde_interface,
                                          int device) {
   return absl::WrapUnique(
-      new BfrtActionProfileManager(bf_sde_interface, device));
+      new TdiActionProfileManager(tdi_sde_interface, device));
 }
 
-::util::Status BfrtActionProfileManager::PushForwardingPipelineConfig(
-    const BfrtDeviceConfig& config) {
+::util::Status TdiActionProfileManager::PushForwardingPipelineConfig(
+    const TdirtDeviceConfig& config) {
   absl::WriterMutexLock l(&lock_);
   std::unique_ptr<P4InfoManager> p4_info_manager =
       absl::make_unique<P4InfoManager>(config.programs(0).p4info());
@@ -37,12 +37,12 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   return ::util::OkStatus();
 }
 
-::util::Status BfrtActionProfileManager::WriteActionProfileEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::WriteActionProfileEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type, const ::p4::v1::ExternEntry& entry) {
   absl::WriterMutexLock l(&lock_);
   ASSIGN_OR_RETURN(uint32 bfrt_table_id,
-                   bf_sde_interface_->GetBfRtId(entry.extern_id()));
+                   tdi_sde_interface_->GetTdiRtId(entry.extern_id()));
   switch (entry.extern_type_id()) {
     case kTnaExternActionProfileId: {
       ::p4::v1::ActionProfileMember act_prof_member;
@@ -66,13 +66,13 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   }
 }
 
-::util::Status BfrtActionProfileManager::ReadActionProfileEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::ReadActionProfileEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::ExternEntry& entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   absl::ReaderMutexLock l(&lock_);
   ASSIGN_OR_RETURN(uint32 bfrt_table_id,
-                   bf_sde_interface_->GetBfRtId(entry.extern_id()));
+                   tdi_sde_interface_->GetTdiRtId(entry.extern_id()));
   ::p4::v1::ExternEntry result = entry;
   switch (entry.extern_type_id()) {
     case kTnaExternActionProfileId: {
@@ -101,62 +101,62 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   return ::util::OkStatus();
 }
 
-::util::Status BfrtActionProfileManager::WriteActionProfileMember(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::WriteActionProfileMember(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type,
     const ::p4::v1::ActionProfileMember& action_profile_member) {
   absl::WriterMutexLock l(&lock_);
   ASSIGN_OR_RETURN(
       uint32 bfrt_table_id,
-      bf_sde_interface_->GetBfRtId(action_profile_member.action_profile_id()));
+      tdi_sde_interface_->GetTdiRtId(action_profile_member.action_profile_id()));
   return DoWriteActionProfileMember(session, bfrt_table_id, type,
                                     action_profile_member);
 }
 
-::util::Status BfrtActionProfileManager::ReadActionProfileMember(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::ReadActionProfileMember(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::ActionProfileMember& action_profile_member,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   absl::ReaderMutexLock l(&lock_);
   ASSIGN_OR_RETURN(
       uint32 bfrt_table_id,
-      bf_sde_interface_->GetBfRtId(action_profile_member.action_profile_id()));
+      tdi_sde_interface_->GetTdiRtId(action_profile_member.action_profile_id()));
   return DoReadActionProfileMember(session, bfrt_table_id,
                                    action_profile_member, writer);
 }
 
-::util::Status BfrtActionProfileManager::WriteActionProfileGroup(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::WriteActionProfileGroup(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type,
     const ::p4::v1::ActionProfileGroup& action_profile_group) {
   absl::WriterMutexLock l(&lock_);
   ASSIGN_OR_RETURN(
       uint32 bfrt_act_prof_table_id,
-      bf_sde_interface_->GetBfRtId(action_profile_group.action_profile_id()));
+      tdi_sde_interface_->GetTdiRtId(action_profile_group.action_profile_id()));
   ASSIGN_OR_RETURN(
       uint32 bfrt_act_sel_table_id,
-      bf_sde_interface_->GetActionSelectorBfRtId(bfrt_act_prof_table_id));
+      tdi_sde_interface_->GetActionSelectorTdiRtId(bfrt_act_prof_table_id));
   return DoWriteActionProfileGroup(session, bfrt_act_sel_table_id, type,
                                    action_profile_group);
 }
 
-::util::Status BfrtActionProfileManager::ReadActionProfileGroup(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::ReadActionProfileGroup(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::ActionProfileGroup& action_profile_group,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   absl::ReaderMutexLock l(&lock_);
   ASSIGN_OR_RETURN(
       uint32 bfrt_act_prof_table_id,
-      bf_sde_interface_->GetBfRtId(action_profile_group.action_profile_id()));
+      tdi_sde_interface_->GetTdiRtId(action_profile_group.action_profile_id()));
   ASSIGN_OR_RETURN(
       uint32 bfrt_act_sel_table_id,
-      bf_sde_interface_->GetActionSelectorBfRtId(bfrt_act_prof_table_id));
+      tdi_sde_interface_->GetActionSelectorTdiRtId(bfrt_act_prof_table_id));
   return DoReadActionProfileGroup(session, bfrt_act_sel_table_id,
                                   action_profile_group, writer);
 }
 
-::util::Status BfrtActionProfileManager::DoWriteActionProfileMember(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::DoWriteActionProfileMember(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 bfrt_table_id, const ::p4::v1::Update::Type type,
     const ::p4::v1::ActionProfileMember& action_profile_member) {
   // Lock is already acquired by the caller
@@ -166,7 +166,7 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   // Action data
   ASSIGN_OR_RETURN(
       auto table_data,
-      bf_sde_interface_->CreateTableData(
+      tdi_sde_interface_->CreateTableData(
           bfrt_table_id, action_profile_member.action().action_id()));
   for (const auto& param : action_profile_member.action().params()) {
     RETURN_IF_ERROR(table_data->SetParam(param.param_id(), param.value()));
@@ -174,19 +174,19 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
 
   switch (type) {
     case ::p4::v1::Update::INSERT: {
-      RETURN_IF_ERROR(bf_sde_interface_->InsertActionProfileMember(
+      RETURN_IF_ERROR(tdi_sde_interface_->InsertActionProfileMember(
           device_, session, bfrt_table_id, action_profile_member.member_id(),
           table_data.get()));
       break;
     }
     case ::p4::v1::Update::MODIFY: {
-      RETURN_IF_ERROR(bf_sde_interface_->ModifyActionProfileMember(
+      RETURN_IF_ERROR(tdi_sde_interface_->ModifyActionProfileMember(
           device_, session, bfrt_table_id, action_profile_member.member_id(),
           table_data.get()));
       break;
     }
     case ::p4::v1::Update::DELETE: {
-      RETURN_IF_ERROR(bf_sde_interface_->DeleteActionProfileMember(
+      RETURN_IF_ERROR(tdi_sde_interface_->DeleteActionProfileMember(
           device_, session, bfrt_table_id, action_profile_member.member_id()));
       break;
     }
@@ -197,8 +197,8 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   return ::util::OkStatus();
 }
 
-::util::Status BfrtActionProfileManager::DoReadActionProfileMember(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::DoReadActionProfileMember(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 bfrt_table_id,
     const ::p4::v1::ActionProfileMember& action_profile_member,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
@@ -206,20 +206,20 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
       << "Reading all action profiles is not supported yet.";
 
   std::vector<int> member_ids;
-  std::vector<std::unique_ptr<BfSdeInterface::TableDataInterface>> table_datas;
-  RETURN_IF_ERROR(bf_sde_interface_->GetActionProfileMembers(
+  std::vector<std::unique_ptr<TdiSdeInterface::TableDataInterface>> table_datas;
+  RETURN_IF_ERROR(tdi_sde_interface_->GetActionProfileMembers(
       device_, session, bfrt_table_id, action_profile_member.member_id(),
       &member_ids, &table_datas));
 
   ::p4::v1::ReadResponse resp;
   for (size_t i = 0; i < member_ids.size(); ++i) {
     const int member_id = member_ids[i];
-    const std::unique_ptr<BfSdeInterface::TableDataInterface>& table_data =
+    const std::unique_ptr<TdiSdeInterface::TableDataInterface>& table_data =
         table_datas[i];
 
     ::p4::v1::ActionProfileMember result;
     ASSIGN_OR_RETURN(auto action_profile_id,
-                     bf_sde_interface_->GetP4InfoId(bfrt_table_id));
+                     tdi_sde_interface_->GetP4InfoId(bfrt_table_id));
     result.set_action_profile_id(action_profile_id);
     result.set_member_id(member_id);
 
@@ -249,8 +249,8 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   return ::util::OkStatus();
 }
 
-::util::Status BfrtActionProfileManager::DoWriteActionProfileGroup(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::DoWriteActionProfileGroup(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 bfrt_table_id, const ::p4::v1::Update::Type type,
     const ::p4::v1::ActionProfileGroup& action_profile_group) {
   CHECK_RETURN_IF_FALSE(type != ::p4::v1::Update::UNSPECIFIED)
@@ -265,19 +265,19 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
 
   switch (type) {
     case ::p4::v1::Update::INSERT: {
-      RETURN_IF_ERROR(bf_sde_interface_->InsertActionProfileGroup(
+      RETURN_IF_ERROR(tdi_sde_interface_->InsertActionProfileGroup(
           device_, session, bfrt_table_id, action_profile_group.group_id(),
           action_profile_group.max_size(), member_ids, member_status));
       break;
     }
     case ::p4::v1::Update::MODIFY: {
-      RETURN_IF_ERROR(bf_sde_interface_->ModifyActionProfileGroup(
+      RETURN_IF_ERROR(tdi_sde_interface_->ModifyActionProfileGroup(
           device_, session, bfrt_table_id, action_profile_group.group_id(),
           action_profile_group.max_size(), member_ids, member_status));
       break;
     }
     case ::p4::v1::Update::DELETE: {
-      RETURN_IF_ERROR(bf_sde_interface_->DeleteActionProfileGroup(
+      RETURN_IF_ERROR(tdi_sde_interface_->DeleteActionProfileGroup(
           device_, session, bfrt_table_id, action_profile_group.group_id()));
       break;
     }
@@ -288,8 +288,8 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   return ::util::OkStatus();
 }
 
-::util::Status BfrtActionProfileManager::DoReadActionProfileGroup(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiActionProfileManager::DoReadActionProfileGroup(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     uint32 bfrt_table_id,
     const ::p4::v1::ActionProfileGroup& action_profile_group,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
@@ -300,7 +300,7 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
   std::vector<int> max_group_sizes;
   std::vector<std::vector<uint32>> member_ids;
   std::vector<std::vector<bool>> member_statuses;
-  RETURN_IF_ERROR(bf_sde_interface_->GetActionProfileGroups(
+  RETURN_IF_ERROR(tdi_sde_interface_->GetActionProfileGroups(
       device_, session, bfrt_table_id, action_profile_group.group_id(),
       &group_ids, &max_group_sizes, &member_ids, &member_statuses));
 
@@ -313,9 +313,9 @@ BfrtActionProfileManager::CreateInstance(BfSdeInterface* bf_sde_interface,
     ::p4::v1::ActionProfileGroup result;
     // Action profile id
     ASSIGN_OR_RETURN(auto action_profile_id,
-                     bf_sde_interface_->GetActionProfileBfRtId(bfrt_table_id));
+                     tdi_sde_interface_->GetActionProfileTdiRtId(bfrt_table_id));
     ASSIGN_OR_RETURN(auto p4_action_profile_id,
-                     bf_sde_interface_->GetP4InfoId(action_profile_id));
+                     tdi_sde_interface_->GetP4InfoId(action_profile_id));
     result.set_action_profile_id(p4_action_profile_id);
     // Group id
     result.set_group_id(group_id);
diff --git a/stratum/hal/lib/barefoot/bfrt_action_profile_manager.h b/stratum/hal/lib/barefoot/bfrt_action_profile_manager.h
index c40326c6..e00651c6 100644
--- a/stratum/hal/lib/barefoot/bfrt_action_profile_manager.h
+++ b/stratum/hal/lib/barefoot/bfrt_action_profile_manager.h
@@ -23,77 +23,77 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class BfrtActionProfileManager {
+class TdiActionProfileManager {
  public:
   // Pushes the pipline info.
-  ::util::Status PushForwardingPipelineConfig(const BfrtDeviceConfig& config)
+  ::util::Status PushForwardingPipelineConfig(const TdirtDeviceConfig& config)
       LOCKS_EXCLUDED(lock_);
 
   // Writes an action profile member.
   ::util::Status WriteActionProfileEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::ExternEntry& action_profile_entry) LOCKS_EXCLUDED(lock_);
 
   // Writes an action profile member.
   ::util::Status WriteActionProfileMember(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::ActionProfileMember& action_profile_member)
       LOCKS_EXCLUDED(lock_);
 
   // Writes an action profile group.
   ::util::Status WriteActionProfileGroup(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::ActionProfileGroup& action_profile_group)
       LOCKS_EXCLUDED(lock_);
 
   // Reads the P4 ActionProfileEntry(s) matched by the given extern entry.
   ::util::Status ReadActionProfileEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::ExternEntry& action_profile_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer) LOCKS_EXCLUDED(lock_);
 
   // Reads the P4 ActionProfileMember(s) matched by the given entry.
   ::util::Status ReadActionProfileMember(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::ActionProfileMember& action_profile_member,
       WriterInterface<::p4::v1::ReadResponse>* writer) LOCKS_EXCLUDED(lock_);
 
   // Reads the P4 ActionProfileGroup(s) matched by the given entry.
   ::util::Status ReadActionProfileGroup(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::ActionProfileGroup& action_profile_group,
       WriterInterface<::p4::v1::ReadResponse>* writer) LOCKS_EXCLUDED(lock_);
 
   // Creates an action profile manager instance.
-  static std::unique_ptr<BfrtActionProfileManager> CreateInstance(
-      BfSdeInterface* bf_sde_interface, int device);
+  static std::unique_ptr<TdiActionProfileManager> CreateInstance(
+      TdiSdeInterface* tdi_sde_interface, int device);
 
  private:
   // Private constructor, we can create the instance by using `CreateInstance`
   // function only.
-  explicit BfrtActionProfileManager(BfSdeInterface* bf_sde_interface,
+  explicit TdiActionProfileManager(TdiSdeInterface* tdi_sde_interface,
                                     int device);
 
   // Internal version of WriteActionProfileMember which takes no locks.
   ::util::Status DoWriteActionProfileMember(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 bfrt_table_id, const ::p4::v1::Update::Type type,
       const ::p4::v1::ActionProfileMember& action_profile_member)
       EXCLUSIVE_LOCKS_REQUIRED(lock_);
 
   // Internal version of WriteActionProfileGroup which takes no locks.
   ::util::Status DoWriteActionProfileGroup(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 bfrt_table_id, const ::p4::v1::Update::Type type,
       const ::p4::v1::ActionProfileGroup& action_profile_group)
       EXCLUSIVE_LOCKS_REQUIRED(lock_);
 
   // Internal version of ReadActionProfileMember which takes no locks.
   ::util::Status DoReadActionProfileMember(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 bfrt_table_id,
       const ::p4::v1::ActionProfileMember& action_profile_member,
       WriterInterface<::p4::v1::ReadResponse>* writer)
@@ -101,7 +101,7 @@ class BfrtActionProfileManager {
 
   // Internal version of ReadActionProfileGroup which takes no locks.
   ::util::Status DoReadActionProfileGroup(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       uint32 bfrt_table_id,
       const ::p4::v1::ActionProfileGroup& action_profile_group,
       WriterInterface<::p4::v1::ReadResponse>* writer)
@@ -111,8 +111,8 @@ class BfrtActionProfileManager {
   // TODO(max): Check if removeable
   mutable absl::Mutex lock_;
 
-  // Pointer to a BfSdeInterface implementation that wraps all the SDE calls.
-  BfSdeInterface* bf_sde_interface_ = nullptr;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps all the SDE calls.
+  TdiSdeInterface* tdi_sde_interface_ = nullptr;  // not owned by this class.
 
   // Helper class to validate the P4Info and requests against it.
   // TODO(max): Maybe this manager should be created in the node and passed down
diff --git a/stratum/hal/lib/barefoot/bfrt_counter_manager.cc b/stratum/hal/lib/barefoot/bfrt_counter_manager.cc
index 544b4df5..e4917a92 100644
--- a/stratum/hal/lib/barefoot/bfrt_counter_manager.cc
+++ b/stratum/hal/lib/barefoot/bfrt_counter_manager.cc
@@ -10,29 +10,29 @@
 #include "gflags/gflags.h"
 #include "stratum/hal/lib/barefoot/bfrt_constants.h"
 
-DECLARE_uint32(bfrt_table_sync_timeout_ms);
+DECLARE_uint32(tdirt_table_sync_timeout_ms);
 
 namespace stratum {
 namespace hal {
 namespace barefoot {
 
-std::unique_ptr<BfrtCounterManager> BfrtCounterManager::CreateInstance(
-    BfSdeInterface* bf_sde_interface, int device) {
-  return absl::WrapUnique(new BfrtCounterManager(bf_sde_interface, device));
+std::unique_ptr<TdiCounterManager> TdiCounterManager::CreateInstance(
+    TdiSdeInterface* tdi_sde_interface, int device) {
+  return absl::WrapUnique(new TdiCounterManager(tdi_sde_interface, device));
 }
 
-BfrtCounterManager::BfrtCounterManager(BfSdeInterface* bf_sde_interface,
+TdiCounterManager::TdiCounterManager(TdiSdeInterface* tdi_sde_interface,
                                        int device)
-    : bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)), device_(device) {}
+    : tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)), device_(device) {}
 
-::util::Status BfrtCounterManager::PushForwardingPipelineConfig(
-    const BfrtDeviceConfig& config) {
+::util::Status TdiCounterManager::PushForwardingPipelineConfig(
+    const TdirtDeviceConfig& config) {
   absl::WriterMutexLock l(&lock_);
   return ::util::OkStatus();
 }
 
-::util::Status BfrtCounterManager::WriteIndirectCounterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiCounterManager::WriteIndirectCounterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type,
     const ::p4::v1::CounterEntry& counter_entry) {
   absl::WriterMutexLock l(&lock_);
@@ -48,7 +48,7 @@ BfrtCounterManager::BfrtCounterManager(BfSdeInterface* bf_sde_interface,
   // Find counter table.
   // TODO(max): revisit id translation location
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(counter_entry.counter_id()));
+                   tdi_sde_interface_->GetTdiRtId(counter_entry.counter_id()));
 
   absl::optional<uint64> byte_count;
   absl::optional<uint64> packet_count;
@@ -56,20 +56,18 @@ BfrtCounterManager::BfrtCounterManager(BfSdeInterface* bf_sde_interface,
     byte_count = counter_entry.data().byte_count();
     packet_count = counter_entry.data().packet_count();
   }
-  RETURN_IF_ERROR(bf_sde_interface_->WriteIndirectCounter(
+  RETURN_IF_ERROR(tdi_sde_interface_->WriteIndirectCounter(
       device_, session, table_id, counter_entry.index().index(), byte_count,
       packet_count));
 
   return ::util::OkStatus();
 }
 
-::util::Status BfrtCounterManager::ReadIndirectCounterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiCounterManager::ReadIndirectCounterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::CounterEntry& counter_entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   absl::ReaderMutexLock l(&lock_);
-  CHECK_RETURN_IF_FALSE(counter_entry.counter_id() != 0)
-      << "Querying an indirect counter without counter id is not supported.";
   CHECK_RETURN_IF_FALSE(counter_entry.index().index() >= 0)
       << "Counter index must be greater than or equal to zero.";
 
@@ -81,16 +79,19 @@ BfrtCounterManager::BfrtCounterManager(BfSdeInterface* bf_sde_interface,
 
   // Find counter table
   // TODO(max): revisit id translation location
-  ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(counter_entry.counter_id()));
+  uint32 table_id = 0;
+  if(counter_entry.counter_id()) {
+    ASSIGN_OR_RETURN(table_id,
+                    tdi_sde_interface_->GetTdiRtId(counter_entry.counter_id()));
+  }
 
   std::vector<uint32> counter_indices;
   std::vector<absl::optional<uint64>> byte_counts;
   std::vector<absl::optional<uint64>> packet_counts;
-  RETURN_IF_ERROR(bf_sde_interface_->ReadIndirectCounter(
+  RETURN_IF_ERROR(tdi_sde_interface_->ReadIndirectCounter(
       device_, session, table_id, optional_counter_index, &counter_indices,
       &byte_counts, &packet_counts,
-      absl::Milliseconds(FLAGS_bfrt_table_sync_timeout_ms)));
+      absl::Milliseconds(FLAGS_tdirt_table_sync_timeout_ms)));
 
   ::p4::v1::ReadResponse resp;
   for (size_t i = 0; i < counter_indices.size(); ++i) {
diff --git a/stratum/hal/lib/barefoot/bfrt_counter_manager.h b/stratum/hal/lib/barefoot/bfrt_counter_manager.h
index 784832c2..993039cf 100644
--- a/stratum/hal/lib/barefoot/bfrt_counter_manager.h
+++ b/stratum/hal/lib/barefoot/bfrt_counter_manager.h
@@ -21,38 +21,38 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class BfrtCounterManager {
+class TdiCounterManager {
  public:
   // Pushes the forwarding pipeline config
-  ::util::Status PushForwardingPipelineConfig(const BfrtDeviceConfig& config)
+  ::util::Status PushForwardingPipelineConfig(const TdirtDeviceConfig& config)
       LOCKS_EXCLUDED(lock_);
 
   // Writes an indrect counter entry.
   ::util::Status WriteIndirectCounterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::CounterEntry& counter_entry) LOCKS_EXCLUDED(lock_);
 
   // Reads an indirect counter entry.
   ::util::Status ReadIndirectCounterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::CounterEntry& counter_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer) LOCKS_EXCLUDED(lock_);
 
   // Creates a table manager instance.
-  static std::unique_ptr<BfrtCounterManager> CreateInstance(
-      BfSdeInterface* bf_sde_interface_, int device);
+  static std::unique_ptr<TdiCounterManager> CreateInstance(
+      TdiSdeInterface* tdi_sde_interface_, int device);
 
  private:
   // Private constructure, we can create the instance by using `CreateInstance`
   // function only.
-  explicit BfrtCounterManager(BfSdeInterface* bf_sde_interface_, int device);
+  explicit TdiCounterManager(TdiSdeInterface* tdi_sde_interface_, int device);
 
   // Reader-writer lock used to protect access to pipeline state.
   mutable absl::Mutex lock_;
 
-  // Pointer to a BfSdeInterface implementation that wraps all the SDE calls.
-  BfSdeInterface* bf_sde_interface_ = nullptr;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps all the SDE calls.
+  TdiSdeInterface* tdi_sde_interface_ = nullptr;  // not owned by this class.
 
   // Fixed zero-based Tofino device number corresponding to the node/ASIC
   // managed by this class instance. Assigned in the class constructor.
diff --git a/stratum/hal/lib/barefoot/bfrt_counter_manager_test.cc b/stratum/hal/lib/barefoot/bfrt_counter_manager_test.cc
index 76bc122a..2aadef11 100644
--- a/stratum/hal/lib/barefoot/bfrt_counter_manager_test.cc
+++ b/stratum/hal/lib/barefoot/bfrt_counter_manager_test.cc
@@ -24,29 +24,29 @@ using ::testing::Invoke;
 using ::testing::InvokeWithoutArgs;
 using ::testing::Return;
 
-class BfrtCounterManagerTest : public ::testing::Test {
+class TdiCounterManagerTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    bf_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
-    bfrt_counter_manager_ = BfrtCounterManager::CreateInstance(
-        bf_sde_wrapper_mock_.get(), kDevice1);
+    tdi_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
+    tdi_counter_manager_ = TdiCounterManager::CreateInstance(
+        tdi_sde_wrapper_mock_.get(), kDevice1);
   }
 
   static constexpr int kDevice1 = 0;
 
-  std::unique_ptr<BfSdeMock> bf_sde_wrapper_mock_;
-  std::unique_ptr<BfrtCounterManager> bfrt_counter_manager_;
+  std::unique_ptr<BfSdeMock> tdi_sde_wrapper_mock_;
+  std::unique_ptr<TdiCounterManager> tdi_counter_manager_;
 };
 
-constexpr int BfrtCounterManagerTest::kDevice1;
+constexpr int TdiCounterManagerTest::kDevice1;
 
-TEST_F(BfrtCounterManagerTest, ModifyIndirectCounterTest) {
+TEST_F(TdiCounterManagerTest, ModifyIndirectCounterTest) {
   constexpr int kCounterId = 55;
   constexpr int kBfRtCounterId = 66;
   constexpr int kIndex = 100;
   auto session_mock = std::make_shared<SessionMock>();
 
-  EXPECT_CALL(*bf_sde_wrapper_mock_, GetBfRtId(kCounterId))
+  EXPECT_CALL(*tdi_sde_wrapper_mock_, GetBfRtId(kCounterId))
       .WillOnce(Return(kBfRtCounterId));
 
   const std::string kIndirectCounterEntryText = R"PROTO(
@@ -62,7 +62,7 @@ TEST_F(BfrtCounterManagerTest, ModifyIndirectCounterTest) {
   ::p4::v1::CounterEntry entry;
   ASSERT_OK(ParseProtoFromString(kIndirectCounterEntryText, &entry));
 
-  EXPECT_OK(bfrt_counter_manager_->WriteIndirectCounterEntry(
+  EXPECT_OK(tdi_counter_manager_->WriteIndirectCounterEntry(
       session_mock, ::p4::v1::Update::MODIFY, entry));
 }
 
diff --git a/stratum/hal/lib/barefoot/bfrt_id_mapper.cc b/stratum/hal/lib/barefoot/bfrt_id_mapper.cc
index 34882466..896f23df 100644
--- a/stratum/hal/lib/barefoot/bfrt_id_mapper.cc
+++ b/stratum/hal/lib/barefoot/bfrt_id_mapper.cc
@@ -6,61 +6,61 @@
 #include <vector>
 
 #include "absl/strings/match.h"
-#include "bf_rt/bf_rt_table.hpp"
 #include "nlohmann/json.hpp"
 #include "stratum/glue/gtl/map_util.h"
 #include "stratum/hal/lib/barefoot/bfrt_constants.h"
 #include "stratum/hal/lib/barefoot/macros.h"
+#include "tdi_rt/tdi_rt_defs.h"
 
 namespace stratum {
 namespace hal {
 namespace barefoot {
 
-BfrtIdMapper::BfrtIdMapper()
-    : bfrt_to_p4info_id_(),
-      p4info_to_bfrt_id_(),
+TdirtIdMapper::TdirtIdMapper()
+    : tdirt_to_p4info_id_(),
+      p4info_to_tdirt_id_(),
       act_profile_to_selector_mapping_(),
       act_selector_to_profile_mapping_() {}
 
-std::unique_ptr<BfrtIdMapper> BfrtIdMapper::CreateInstance() {
-  return absl::WrapUnique(new BfrtIdMapper());
+std::unique_ptr<TdirtIdMapper> TdirtIdMapper::CreateInstance() {
+  return absl::WrapUnique(new TdirtIdMapper());
 }
 
-::util::Status BfrtIdMapper::PushForwardingPipelineConfig(
-    const BfrtDeviceConfig& config, const bfrt::BfRtInfo* bfrt_info) {
+::util::Status TdirtIdMapper::PushForwardingPipelineConfig(
+    const TdirtDeviceConfig& config, const tdi::TdiInfo* tdi_info) {
   absl::WriterMutexLock l(&lock_);
 
-  // Builds mapping between p4info and bfrt info
+  // Builds mapping between p4info and tdirt info
   // In most cases, such as table id, we don't really need to map
-  // from p4info ID to bfrt ID.
+  // from p4info ID to tdirt ID.
   // However for some cases, like externs which does not exists
   // in native P4 core headers, the frontend compiler will
-  // generate different IDs between p4info and bfrt info.
+  // generate different IDs between p4info and tdirt info.
   for (const auto& program : config.programs()) {
-    // Try to find P4 tables from BFRT info
+    // Try to find P4 tables from TDIRT info
     for (const auto& table : program.p4info().tables()) {
       RETURN_IF_ERROR(BuildMapping(table.preamble().id(),
-                                   table.preamble().name(), bfrt_info));
+                                   table.preamble().name(), tdi_info));
     }
 
     // Action profiles
     for (const auto& action_profile : program.p4info().action_profiles()) {
       RETURN_IF_ERROR(BuildMapping(action_profile.preamble().id(),
                                    action_profile.preamble().name(),
-                                   bfrt_info));
+                                   tdi_info));
     }
     // FIXME(Yi): We need to scan all context.json to build correct mapping for
     // ActionProfiles and ActionSelectors. We may remove this workaround in the
     // future.
     for (const auto& pipeline : program.pipelines()) {
-      RETURN_IF_ERROR(BuildActionProfileMapping(program.p4info(), bfrt_info,
+      RETURN_IF_ERROR(BuildActionProfileMapping(program.p4info(), tdi_info,
                                                 pipeline.context()));
     }
 
     // Externs
     for (const auto& p4extern : program.p4info().externs()) {
       // TODO(Yi): Now we only support ActionProfile and ActionSelector
-      // Things like DirectCounter are not listed as a table in bfrt.json
+      // Things like DirectCounter are not listed as a table in tdirt.json
       if (p4extern.extern_type_id() != kTnaExternActionProfileId &&
           p4extern.extern_type_id() != kTnaExternActionSelectorId) {
         continue;
@@ -68,83 +68,82 @@ std::unique_ptr<BfrtIdMapper> BfrtIdMapper::CreateInstance() {
       for (const auto& extern_instance : p4extern.instances()) {
         RETURN_IF_ERROR(BuildMapping(extern_instance.preamble().id(),
                                      extern_instance.preamble().name(),
-                                     bfrt_info));
+                                     tdi_info));
       }
     }
 
     // Indirect counters
     for (const auto& counter : program.p4info().counters()) {
       RETURN_IF_ERROR(BuildMapping(counter.preamble().id(),
-                                   counter.preamble().name(), bfrt_info));
+                                   counter.preamble().name(), tdi_info));
     }
 
     // Registers
     for (const auto& register_entry : program.p4info().registers()) {
       RETURN_IF_ERROR(BuildMapping(register_entry.preamble().id(),
                                    register_entry.preamble().name(),
-                                   bfrt_info));
+                                   tdi_info));
     }
 
     // Meters
     for (const auto& meter_entry : program.p4info().meters()) {
       RETURN_IF_ERROR(BuildMapping(meter_entry.preamble().id(),
-                                   meter_entry.preamble().name(), bfrt_info));
+                                   meter_entry.preamble().name(), tdi_info));
     }
   }
 
   return ::util::OkStatus();
 }
 
-::util::Status BfrtIdMapper::BuildMapping(uint32 p4info_id,
+::util::Status TdirtIdMapper::BuildMapping(uint32 p4info_id,
                                           std::string p4info_name,
-                                          const bfrt::BfRtInfo* bfrt_info) {
-  const bfrt::BfRtTable* table;
-  auto bf_status = bfrt_info->bfrtTableFromIdGet(p4info_id, &table);
+                                          const tdi::TdiInfo* tdi_info) {
+  const tdi::Table* table;
+  auto tdi_status_t = tdi_info->tableFromIdGet(p4info_id, &table);
 
-  if (bf_status == BF_SUCCESS) {
-    // Both p4info and bfrt json uses the same id for a specific
+  if (tdi_status_t == TDI_SUCCESS) {
+    // Both p4info and tdirt json uses the same id for a specific
     // table/action selector/profile
-    p4info_to_bfrt_id_[p4info_id] = p4info_id;
-    bfrt_to_p4info_id_[p4info_id] = p4info_id;
+    p4info_to_tdirt_id_[p4info_id] = p4info_id;
+    tdirt_to_p4info_id_[p4info_id] = p4info_id;
     return ::util::OkStatus();
   }
 
-  // Unable to find table by id, because bfrt uses a different id, we
+  // Unable to find table by id, because tdirt uses a different id, we
   // can try to search it by name.
-  bf_status = bfrt_info->bfrtTableFromNameGet(p4info_name, &table);
-  if (bf_status == BF_SUCCESS) {
+  tdi_status_t = tdi_info->tableFromNameGet(p4info_name, &table);
+  if (tdi_status_t == TDI_SUCCESS) {
     // Table can be found with the given name, but they uses different IDs
     // We need to store mapping so we can map them later.
-    bf_rt_id_t bfrt_table_id;
-    table->tableIdGet(&bfrt_table_id);
-    p4info_to_bfrt_id_[p4info_id] = bfrt_table_id;
-    bfrt_to_p4info_id_[bfrt_table_id] = p4info_id;
+    tdi_id_t table_id = table->tableInfoGet()->idGet();
+    p4info_to_tdirt_id_[p4info_id] = table_id;
+    tdirt_to_p4info_id_[table_id] = p4info_id;
     return ::util::OkStatus();
   }
 
-  // Special case: bfrt includes pipeline name as prefix(e.g., "pipe."), but
+  // Special case: tdirt includes pipeline name as prefix(e.g., "pipe."), but
   // p4info doesn't. We need to scan all tables to see if there is a table
   // called "[pipeline name].[P4 info table name]"
-  std::vector<const bfrt::BfRtTable*> bfrt_tables;
-  RETURN_IF_BFRT_ERROR(bfrt_info->bfrtInfoGetTables(&bfrt_tables));
-  for (const auto* bfrt_table : bfrt_tables) {
-    bf_rt_id_t bfrt_table_id;
-    std::string bfrt_table_name;
-    bfrt_table->tableIdGet(&bfrt_table_id);
-    bfrt_table->tableNameGet(&bfrt_table_name);
-    if (absl::StrContains(bfrt_table_name, p4info_name)) {
-      p4info_to_bfrt_id_[p4info_id] = bfrt_table_id;
-      bfrt_to_p4info_id_[bfrt_table_id] = p4info_id;
+  std::vector<const tdi::Table*> tdi_tables;
+  RETURN_IF_TDI_ERROR(tdi_info->tablesGet(&tdi_tables));
+  for (const auto* table : tdi_tables) {
+    tdi_id_t table_id;
+    std::string table_name;
+    table_id = table->tableInfoGet()->idGet();
+    table_name = table->tableInfoGet()->nameGet();
+    if (absl::StrContains(table_name, p4info_name)) {
+      p4info_to_tdirt_id_[p4info_id] = table_id;
+      tdirt_to_p4info_id_[table_id] = p4info_id;
       return ::util::OkStatus();
     }
   }
   return MAKE_ERROR(ERR_INTERNAL)
-         << "Unable to find bfrt ID for P4Info entity " << p4info_name
+         << "Unable to find tdirt ID for P4Info entity " << p4info_name
          << " with ID " << p4info_id << ".";
 }
 
-::util::Status BfrtIdMapper::BuildActionProfileMapping(
-    const p4::config::v1::P4Info& p4info, const bfrt::BfRtInfo* bfrt_info,
+::util::Status TdirtIdMapper::BuildActionProfileMapping(
+    const p4::config::v1::P4Info& p4info, const tdi::TdiInfo* tdi_info,
     const std::string& context_json_content) {
   absl::flat_hash_map<std::string, std::string> prof_to_sel;
   try {
@@ -187,26 +186,25 @@ std::unique_ptr<BfrtIdMapper> BfrtIdMapper::CreateInstance() {
     return MAKE_ERROR(ERR_INTERNAL) << e.what();
   }
 
-  // Searching all action profile and selector tables from bfrt.json
-  absl::flat_hash_map<std::string, bf_rt_id_t> act_prof_bfrt_ids;
-  absl::flat_hash_map<std::string, bf_rt_id_t> selector_bfrt_ids;
-  std::vector<const bfrt::BfRtTable*> bfrt_tables;
-  RETURN_IF_BFRT_ERROR(bfrt_info->bfrtInfoGetTables(&bfrt_tables));
-  for (const auto* bfrt_table : bfrt_tables) {
-    bfrt::BfRtTable::TableType table_type;
+  // Searching all action profile and selector tables from tdirt.json
+  absl::flat_hash_map<std::string, tdi_id_t> act_prof_tdirt_ids;
+  absl::flat_hash_map<std::string, tdi_id_t> selector_tdirt_ids;
+  std::vector<const tdi::Table*> tdirt_tables;
+  RETURN_IF_TDI_ERROR(tdi_info->tablesGet(&tdirt_tables));
+  for (const auto* table : tdirt_tables) {
     std::string table_name;
-    bf_rt_id_t table_id;
-    RETURN_IF_BFRT_ERROR(bfrt_table->tableTypeGet(&table_type));
-    RETURN_IF_BFRT_ERROR(bfrt_table->tableNameGet(&table_name));
-    RETURN_IF_BFRT_ERROR(bfrt_table->tableIdGet(&table_id));
+    tdi_id_t table_id;
+    auto table_type = static_cast<tdi_rt_table_type_e>(table->tableInfoGet()->tableTypeGet());
+    table_id = table->tableInfoGet()->idGet();
+    table_name = table->tableInfoGet()->nameGet();
 
-    if (table_type == bfrt::BfRtTable::TableType::ACTION_PROFILE) {
+    if (table_type == TDI_RT_TABLE_TYPE_ACTION_PROFILE) {
       CHECK_RETURN_IF_FALSE(
-          gtl::InsertIfNotPresent(&act_prof_bfrt_ids, table_name, table_id))
+          gtl::InsertIfNotPresent(&act_prof_tdirt_ids, table_name, table_id))
           << "Action profile with name " << table_name << " already exists.";
-    } else if (table_type == bfrt::BfRtTable::TableType::SELECTOR) {
+    } else if (table_type == TDI_RT_TABLE_TYPE_SELECTOR) {
       CHECK_RETURN_IF_FALSE(
-          gtl::InsertIfNotPresent(&selector_bfrt_ids, table_name, table_id))
+          gtl::InsertIfNotPresent(&selector_tdirt_ids, table_name, table_id))
           << "Action selector with name " << table_name << " already exists.";
     }
   }
@@ -217,9 +215,9 @@ std::unique_ptr<BfrtIdMapper> BfrtIdMapper::CreateInstance() {
   for (const auto& name_pair : prof_to_sel) {
     const auto& prof = name_pair.first;
     const auto& sel = name_pair.second;
-    bf_rt_id_t prof_id = 0;
-    bf_rt_id_t sel_id = 0;
-    for (const auto& act_prof_name_id_pair : act_prof_bfrt_ids) {
+    tdi_id_t prof_id = 0;
+    tdi_id_t sel_id = 0;
+    for (const auto& act_prof_name_id_pair : act_prof_tdirt_ids) {
       const auto& act_prof_name = act_prof_name_id_pair.first;
       const auto& act_prof_id = act_prof_name_id_pair.second;
       if (absl::StrContains(act_prof_name, prof)) {
@@ -227,7 +225,7 @@ std::unique_ptr<BfrtIdMapper> BfrtIdMapper::CreateInstance() {
         break;
       }
     }
-    for (const auto& sel_name_id_pair : selector_bfrt_ids) {
+    for (const auto& sel_name_id_pair : selector_tdirt_ids) {
       const auto& act_sel_name = sel_name_id_pair.first;
       const auto& act_sel_id = sel_name_id_pair.second;
       if (absl::StrContains(act_sel_name, sel)) {
@@ -246,22 +244,22 @@ std::unique_ptr<BfrtIdMapper> BfrtIdMapper::CreateInstance() {
   return ::util::OkStatus();
 }
 
-::util::StatusOr<uint32> BfrtIdMapper::GetBfRtId(uint32 p4info_id) const {
+::util::StatusOr<uint32> TdirtIdMapper::GetTdiRtId(uint32 p4info_id) const {
   absl::ReaderMutexLock l(&lock_);
-  CHECK_RETURN_IF_FALSE(gtl::ContainsKey(p4info_to_bfrt_id_, p4info_id))
-      << "Unable to find bfrt id from p4info id: " << p4info_id;
-  return gtl::FindOrDie(p4info_to_bfrt_id_, p4info_id);
+  CHECK_RETURN_IF_FALSE(gtl::ContainsKey(p4info_to_tdirt_id_, p4info_id))
+      << "Unable to find tdirt id from p4info id: " << p4info_id;
+  return gtl::FindOrDie(p4info_to_tdirt_id_, p4info_id);
 }
 
-::util::StatusOr<uint32> BfrtIdMapper::GetP4InfoId(bf_rt_id_t bfrt_id) const {
+::util::StatusOr<uint32> TdirtIdMapper::GetP4InfoId(tdi_id_t tdirt_id) const {
   absl::ReaderMutexLock l(&lock_);
-  CHECK_RETURN_IF_FALSE(gtl::ContainsKey(bfrt_to_p4info_id_, bfrt_id))
-      << "Unable to find p4info id from bfrt id: " << bfrt_id;
-  return gtl::FindOrDie(bfrt_to_p4info_id_, bfrt_id);
+  CHECK_RETURN_IF_FALSE(gtl::ContainsKey(tdirt_to_p4info_id_, tdirt_id))
+      << "Unable to find p4info id from tdirt id: " << tdirt_id;
+  return gtl::FindOrDie(tdirt_to_p4info_id_, tdirt_id);
 }
 
-::util::StatusOr<bf_rt_id_t> BfrtIdMapper::GetActionSelectorBfRtId(
-    bf_rt_id_t action_profile_id) const {
+::util::StatusOr<tdi_id_t> TdirtIdMapper::GetActionSelectorTdiRtId(
+    tdi_id_t action_profile_id) const {
   absl::ReaderMutexLock l(&lock_);
   CHECK_RETURN_IF_FALSE(
       gtl::ContainsKey(act_profile_to_selector_mapping_, action_profile_id))
@@ -270,8 +268,8 @@ std::unique_ptr<BfrtIdMapper> BfrtIdMapper::CreateInstance() {
   return gtl::FindOrDie(act_profile_to_selector_mapping_, action_profile_id);
 }
 
-::util::StatusOr<bf_rt_id_t> BfrtIdMapper::GetActionProfileBfRtId(
-    bf_rt_id_t action_selector_id) const {
+::util::StatusOr<tdi_id_t> TdirtIdMapper::GetActionProfileTdiRtId(
+    tdi_id_t action_selector_id) const {
   absl::ReaderMutexLock l(&lock_);
   CHECK_RETURN_IF_FALSE(
       gtl::ContainsKey(act_selector_to_profile_mapping_, action_selector_id))
diff --git a/stratum/hal/lib/barefoot/bfrt_id_mapper.h b/stratum/hal/lib/barefoot/bfrt_id_mapper.h
index e0d969c0..dfd78cb4 100644
--- a/stratum/hal/lib/barefoot/bfrt_id_mapper.h
+++ b/stratum/hal/lib/barefoot/bfrt_id_mapper.h
@@ -9,8 +9,8 @@
 
 #include "absl/container/flat_hash_map.h"
 #include "absl/synchronization/mutex.h"
-#include "bf_rt/bf_rt_info.hpp"
-#include "bf_rt/bf_rt_init.hpp"
+#include "tdi/common/tdi_info.hpp"
+#include "tdi/common/tdi_init.hpp"
 #include "p4/config/v1/p4info.pb.h"
 #include "stratum/glue/integral_types.h"
 #include "stratum/glue/status/status.h"
@@ -23,41 +23,41 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-// A helper class that convert IDs between P4Runtime and BfRt.
-class BfrtIdMapper {
+// A helper class that convert IDs between P4Runtime and TdiRt.
+class TdirtIdMapper {
  public:
   // Initialize pipeline information
-  // This function creates a mapping between P4Info and BfRt
-  ::util::Status PushForwardingPipelineConfig(const BfrtDeviceConfig& config,
-                                              const bfrt::BfRtInfo* bfrt_info)
+  // This function creates a mapping between P4Info and TdiRt
+  ::util::Status PushForwardingPipelineConfig(const TdirtDeviceConfig& config,
+                                              const tdi::TdiInfo* tdirt_info)
       LOCKS_EXCLUDED(lock_);
 
-  // Maps a P4Info ID to a BfRt ID
-  ::util::StatusOr<uint32> GetBfRtId(uint32 p4info_id) const
+  // Maps a P4Info ID to a TdiRt ID
+  ::util::StatusOr<uint32> GetTdiRtId(uint32 p4info_id) const
       LOCKS_EXCLUDED(lock_);
 
-  // Maps a BfRt ID to a P4Info ID
-  ::util::StatusOr<uint32> GetP4InfoId(bf_rt_id_t bfrt_id) const
+  // Maps a TdiRt ID to a P4Info ID
+  ::util::StatusOr<uint32> GetP4InfoId(tdi_id_t tdirt_id) const
       LOCKS_EXCLUDED(lock_);
 
   // Gets the action selector ID of an action profile.
-  ::util::StatusOr<bf_rt_id_t> GetActionSelectorBfRtId(
-      bf_rt_id_t action_profile_id) const LOCKS_EXCLUDED(lock_);
+  ::util::StatusOr<tdi_id_t> GetActionSelectorTdiRtId(
+      tdi_id_t action_profile_id) const LOCKS_EXCLUDED(lock_);
 
   // Gets the action profile ID of an action selector.
-  ::util::StatusOr<bf_rt_id_t> GetActionProfileBfRtId(
-      bf_rt_id_t action_selector_id) const LOCKS_EXCLUDED(lock_);
+  ::util::StatusOr<tdi_id_t> GetActionProfileTdiRtId(
+      tdi_id_t action_selector_id) const LOCKS_EXCLUDED(lock_);
 
   // Creates a table manager instance for a specific device.
-  static std::unique_ptr<BfrtIdMapper> CreateInstance();
+  static std::unique_ptr<TdirtIdMapper> CreateInstance();
 
  private:
   // Private constructor, we can create the instance by using `CreateInstance`
   // function only.
-  BfrtIdMapper();
+  TdirtIdMapper();
 
   ::util::Status BuildMapping(uint32 p4info_id, std::string p4info_name,
-                              const bfrt::BfRtInfo* bfrt_info)
+                              const tdi::TdiInfo* tdirt_info)
       SHARED_LOCKS_REQUIRED(lock_);
 
   // Scan context.json file and build mappings for ActionProfile and
@@ -65,22 +65,22 @@ class BfrtIdMapper {
   // FIXME(Yi): We may want to remove this workaround if we use the P4 externs
   // in the future.
   ::util::Status BuildActionProfileMapping(
-      const p4::config::v1::P4Info& p4info, const bfrt::BfRtInfo* bfrt_info,
+      const p4::config::v1::P4Info& p4info, const tdi::TdiInfo* tdirt_info,
       const std::string& context_json_content) SHARED_LOCKS_REQUIRED(lock_);
 
   // Reader-writer lock used to protect access to mapping.
   mutable absl::Mutex lock_;
 
-  // Maps from bfrt ID to P4Runtime ID and viceversa.
-  absl::flat_hash_map<bf_rt_id_t, uint32> bfrt_to_p4info_id_ GUARDED_BY(lock_);
-  absl::flat_hash_map<uint32, bf_rt_id_t> p4info_to_bfrt_id_ GUARDED_BY(lock_);
+  // Maps from tdirt ID to P4Runtime ID and viceversa.
+  absl::flat_hash_map<tdi_id_t, uint32> tdirt_to_p4info_id_ GUARDED_BY(lock_);
+  absl::flat_hash_map<uint32, tdi_id_t> p4info_to_tdirt_id_ GUARDED_BY(lock_);
 
-  // Map for getting an ActionSelector BfRt ID from an ActionProfile BfRt ID.
-  absl::flat_hash_map<bf_rt_id_t, bf_rt_id_t> act_profile_to_selector_mapping_
+  // Map for getting an ActionSelector TdiRt ID from an ActionProfile TdiRt ID.
+  absl::flat_hash_map<tdi_id_t, tdi_id_t> act_profile_to_selector_mapping_
       GUARDED_BY(lock_);
 
-  // Map for getting an ActionProfile BfRt ID from an ActionSelector BfRt ID.
-  absl::flat_hash_map<bf_rt_id_t, bf_rt_id_t> act_selector_to_profile_mapping_
+  // Map for getting an ActionProfile TdiRt ID from an ActionSelector TdiRt ID.
+  absl::flat_hash_map<tdi_id_t, tdi_id_t> act_selector_to_profile_mapping_
       GUARDED_BY(lock_);
 };
 
diff --git a/stratum/hal/lib/barefoot/bfrt_node.cc b/stratum/hal/lib/barefoot/bfrt_node.cc
index 1b811845..edce4725 100644
--- a/stratum/hal/lib/barefoot/bfrt_node.cc
+++ b/stratum/hal/lib/barefoot/bfrt_node.cc
@@ -24,82 +24,82 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-BfrtNode::BfrtNode(BfrtTableManager* bfrt_table_manager,
-                   BfrtActionProfileManager* bfrt_action_profile_manager,
-                   BfrtPacketioManager* bfrt_packetio_manager,
-                   BfrtPreManager* bfrt_pre_manager,
-                   BfrtCounterManager* bfrt_counter_manager,
-                   BfSdeInterface* bf_sde_interface, int device_id)
+TdiNode::TdiNode(TdiTableManager* tdi_table_manager,
+                   TdiActionProfileManager* tdi_action_profile_manager,
+                   TdiPacketioManager* tdi_packetio_manager,
+                   TdiPreManager* tdi_pre_manager,
+                   TdiCounterManager* tdi_counter_manager,
+                   TdiSdeInterface* tdi_sde_interface, int device_id)
     : pipeline_initialized_(false),
-      initialized_(false),
-      bfrt_config_(),
-      bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)),
-      bfrt_table_manager_(ABSL_DIE_IF_NULL(bfrt_table_manager)),
-      bfrt_action_profile_manager_(
-          ABSL_DIE_IF_NULL(bfrt_action_profile_manager)),
-      bfrt_packetio_manager_(bfrt_packetio_manager),
-      bfrt_pre_manager_(ABSL_DIE_IF_NULL(bfrt_pre_manager)),
-      bfrt_counter_manager_(ABSL_DIE_IF_NULL(bfrt_counter_manager)),
-      node_id_(0),
+      initialized_(true),
+      tdirt_config_(),
+      tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)),
+      tdi_table_manager_(ABSL_DIE_IF_NULL(tdi_table_manager)),
+      tdi_action_profile_manager_(
+          ABSL_DIE_IF_NULL(tdi_action_profile_manager)),
+      tdi_packetio_manager_(tdi_packetio_manager),
+      tdi_pre_manager_(ABSL_DIE_IF_NULL(tdi_pre_manager)),
+      tdi_counter_manager_(ABSL_DIE_IF_NULL(tdi_counter_manager)),
+      node_id_(1),
       device_id_(device_id) {}
 
-BfrtNode::BfrtNode()
+TdiNode::TdiNode()
     : pipeline_initialized_(false),
       initialized_(false),
-      bfrt_config_(),
-      bf_sde_interface_(nullptr),
-      bfrt_table_manager_(nullptr),
-      bfrt_action_profile_manager_(nullptr),
-      bfrt_packetio_manager_(nullptr),
-      bfrt_pre_manager_(nullptr),
-      bfrt_counter_manager_(nullptr),
+      tdirt_config_(),
+      tdi_sde_interface_(nullptr),
+      tdi_table_manager_(nullptr),
+      tdi_action_profile_manager_(nullptr),
+      tdi_packetio_manager_(nullptr),
+      tdi_pre_manager_(nullptr),
+      tdi_counter_manager_(nullptr),
       node_id_(0),
       device_id_(-1) {}
 
-BfrtNode::~BfrtNode() = default;
+TdiNode::~TdiNode() = default;
 
 // Factory function for creating the instance of the class.
-std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
-    BfrtTableManager* bfrt_table_manager,
-    BfrtActionProfileManager* bfrt_action_profile_manager,
-    BfrtPacketioManager* bfrt_packetio_manager,
-    BfrtPreManager* bfrt_pre_manager, BfrtCounterManager* bfrt_counter_manager,
-    BfSdeInterface* bf_sde_interface, int device_id) {
-  return absl::WrapUnique(new BfrtNode(
-      bfrt_table_manager, bfrt_action_profile_manager, bfrt_packetio_manager,
-      bfrt_pre_manager, bfrt_counter_manager, bf_sde_interface, device_id));
+std::unique_ptr<TdiNode> TdiNode::CreateInstance(
+    TdiTableManager* tdi_table_manager,
+    TdiActionProfileManager* tdi_action_profile_manager,
+    TdiPacketioManager* tdi_packetio_manager,
+    TdiPreManager* tdi_pre_manager, TdiCounterManager* tdi_counter_manager,
+    TdiSdeInterface* tdi_sde_interface, int device_id) {
+  return absl::WrapUnique(new TdiNode(
+      tdi_table_manager, tdi_action_profile_manager, tdi_packetio_manager,
+      tdi_pre_manager, tdi_counter_manager, tdi_sde_interface, device_id));
 }
 
-::util::Status BfrtNode::PushChassisConfig(const ChassisConfig& config,
+::util::Status TdiNode::PushChassisConfig(const ChassisConfig& config,
                                            uint64 node_id) {
   absl::WriterMutexLock l(&lock_);
   node_id_ = node_id;
-  // RETURN_IF_ERROR(bfrt_table_manager_->PushChassisConfig(config, node_id));
+  // RETURN_IF_ERROR(tdi_table_manager_->PushChassisConfig(config, node_id));
   // RETURN_IF_ERROR(
-  //     bfrt_action_profile_manager_->PushChassisConfig(config, node_id));
-  RETURN_IF_ERROR(bfrt_packetio_manager_->PushChassisConfig(config, node_id));
+  //     tdi_action_profile_manager_->PushChassisConfig(config, node_id));
+  RETURN_IF_ERROR(tdi_packetio_manager_->PushChassisConfig(config, node_id));
   initialized_ = true;
 
   return ::util::OkStatus();
 }
 
-::util::Status BfrtNode::VerifyChassisConfig(const ChassisConfig& config,
+::util::Status TdiNode::VerifyChassisConfig(const ChassisConfig& config,
                                              uint64 node_id) {
-  // RETURN_IF_ERROR(bfrt_table_manager_->VerifyChassisConfig(config, node_id));
+  // RETURN_IF_ERROR(tdi_table_manager_->VerifyChassisConfig(config, node_id));
   // RETURN_IF_ERROR(
-  //     bfrt_action_profile_manager_->VerifyChassisConfig(config, node_id));
-  RETURN_IF_ERROR(bfrt_packetio_manager_->VerifyChassisConfig(config, node_id));
+  //     tdi_action_profile_manager_->VerifyChassisConfig(config, node_id));
+  RETURN_IF_ERROR(tdi_packetio_manager_->VerifyChassisConfig(config, node_id));
   return ::util::OkStatus();
 }
 
-::util::Status BfrtNode::PushForwardingPipelineConfig(
+::util::Status TdiNode::PushForwardingPipelineConfig(
     const ::p4::v1::ForwardingPipelineConfig& config) {
   // SaveForwardingPipelineConfig + CommitForwardingPipelineConfig
   RETURN_IF_ERROR(SaveForwardingPipelineConfig(config));
   return CommitForwardingPipelineConfig();
 }
 
-::util::Status BfrtNode::SaveForwardingPipelineConfig(
+::util::Status TdiNode::SaveForwardingPipelineConfig(
     const ::p4::v1::ForwardingPipelineConfig& config) {
   absl::WriterMutexLock l(&lock_);
   if (!initialized_) {
@@ -110,9 +110,9 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
   RETURN_IF_ERROR(ExtractBfPipelineConfig(config, &bf_config));
   VLOG(2) << bf_config.DebugString();
 
-  // Create internal BfrtDeviceConfig.
-  BfrtDeviceConfig bfrt_config;
-  auto program = bfrt_config.add_programs();
+  // Create internal TdirtDeviceConfig.
+  TdirtDeviceConfig tdirt_config;
+  auto program = tdirt_config.add_programs();
   program->set_name(bf_config.p4_name());
   program->set_bfrt(bf_config.bfruntime_info());
   *program->mutable_p4info() = config.p4info();
@@ -123,59 +123,59 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
     pipeline->set_config(profile.binary());
     *pipeline->mutable_scope() = profile.pipe_scope();
   }
-  bfrt_config_ = bfrt_config;
-  VLOG(2) << bfrt_config_.DebugString();
+  tdirt_config_ = tdirt_config;
+  VLOG(2) << tdirt_config_.DebugString();
 
   return ::util::OkStatus();
 }
 
-::util::Status BfrtNode::CommitForwardingPipelineConfig() {
+::util::Status TdiNode::CommitForwardingPipelineConfig() {
   absl::WriterMutexLock l(&lock_);
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
   }
-  CHECK_RETURN_IF_FALSE(bfrt_config_.programs_size() > 0);
+  CHECK_RETURN_IF_FALSE(tdirt_config_.programs_size() > 0);
 
   // Calling AddDevice() overwrites any previous pipeline.
-  RETURN_IF_ERROR(bf_sde_interface_->AddDevice(device_id_, bfrt_config_));
+  RETURN_IF_ERROR(tdi_sde_interface_->AddDevice(device_id_, tdirt_config_));
 
   // Push pipeline config to the managers.
   RETURN_IF_ERROR(
-      bfrt_packetio_manager_->PushForwardingPipelineConfig(bfrt_config_));
+      tdi_packetio_manager_->PushForwardingPipelineConfig(tdirt_config_));
   RETURN_IF_ERROR(
-      bfrt_table_manager_->PushForwardingPipelineConfig(bfrt_config_));
+      tdi_table_manager_->PushForwardingPipelineConfig(tdirt_config_));
   RETURN_IF_ERROR(
-      bfrt_action_profile_manager_->PushForwardingPipelineConfig(bfrt_config_));
+      tdi_action_profile_manager_->PushForwardingPipelineConfig(tdirt_config_));
   RETURN_IF_ERROR(
-      bfrt_pre_manager_->PushForwardingPipelineConfig(bfrt_config_));
+      tdi_pre_manager_->PushForwardingPipelineConfig(tdirt_config_));
   RETURN_IF_ERROR(
-      bfrt_counter_manager_->PushForwardingPipelineConfig(bfrt_config_));
+      tdi_counter_manager_->PushForwardingPipelineConfig(tdirt_config_));
 
   pipeline_initialized_ = true;
   return ::util::OkStatus();
 }
 
-::util::Status BfrtNode::VerifyForwardingPipelineConfig(
+::util::Status TdiNode::VerifyForwardingPipelineConfig(
     const ::p4::v1::ForwardingPipelineConfig& config) const {
   CHECK_RETURN_IF_FALSE(config.has_p4info()) << "Missing P4 info";
   CHECK_RETURN_IF_FALSE(!config.p4_device_config().empty())
       << "Missing P4 device config";
   BfPipelineConfig bf_config;
   RETURN_IF_ERROR(ExtractBfPipelineConfig(config, &bf_config));
-  RETURN_IF_ERROR(bfrt_table_manager_->VerifyForwardingPipelineConfig(config));
+  RETURN_IF_ERROR(tdi_table_manager_->VerifyForwardingPipelineConfig(config));
   return ::util::OkStatus();
 }
 
-::util::Status BfrtNode::Shutdown() {
+::util::Status TdiNode::Shutdown() {
   absl::WriterMutexLock l(&lock_);
   auto status = ::util::OkStatus();
   // TODO(max): Check if we need to de-init the ASIC or SDE
   // TODO(max): Enable other Shutdown calls once implemented.
-  // APPEND_STATUS_IF_ERROR(status, bfrt_table_manager_->Shutdown());
-  // APPEND_STATUS_IF_ERROR(status, bfrt_action_profile_manager_->Shutdown());
-  APPEND_STATUS_IF_ERROR(status, bfrt_packetio_manager_->Shutdown());
-  // APPEND_STATUS_IF_ERROR(status, bfrt_pre_manager_->Shutdown());
-  // APPEND_STATUS_IF_ERROR(status, bfrt_counter_manager_->Shutdown());
+  // APPEND_STATUS_IF_ERROR(status, tdi_table_manager_->Shutdown());
+  // APPEND_STATUS_IF_ERROR(status, tdi_action_profile_manager_->Shutdown());
+  APPEND_STATUS_IF_ERROR(status, tdi_packetio_manager_->Shutdown());
+  // APPEND_STATUS_IF_ERROR(status, tdi_pre_manager_->Shutdown());
+  // APPEND_STATUS_IF_ERROR(status, tdi_counter_manager_->Shutdown());
 
   pipeline_initialized_ = false;
   initialized_ = false;  // Set to false even if there is an error
@@ -183,15 +183,15 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
   return status;
 }
 
-::util::Status BfrtNode::Freeze() { return ::util::OkStatus(); }
+::util::Status TdiNode::Freeze() { return ::util::OkStatus(); }
 
-::util::Status BfrtNode::Unfreeze() { return ::util::OkStatus(); }
+::util::Status TdiNode::Unfreeze() { return ::util::OkStatus(); }
 
-::util::Status BfrtNode::WriteForwardingEntries(
+::util::Status TdiNode::WriteForwardingEntries(
     const ::p4::v1::WriteRequest& req, std::vector<::util::Status>* results) {
   absl::WriterMutexLock l(&lock_);
   CHECK_RETURN_IF_FALSE(req.device_id() == node_id_)
-      << "Request device id must be same as id of this BfrtNode.";
+      << "Request device id must be same as id of this TdiNode.";
   CHECK_RETURN_IF_FALSE(req.atomicity() ==
                         ::p4::v1::WriteRequest::CONTINUE_ON_ERROR)
       << "Request atomicity "
@@ -202,13 +202,13 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
   }
 
   bool success = true;
-  ASSIGN_OR_RETURN(auto session, bf_sde_interface_->CreateSession());
+  ASSIGN_OR_RETURN(auto session, tdi_sde_interface_->CreateSession());
   RETURN_IF_ERROR(session->BeginBatch());
   for (const auto& update : req.updates()) {
     ::util::Status status = ::util::OkStatus();
     switch (update.entity().entity_case()) {
       case ::p4::v1::Entity::kTableEntry:
-        status = bfrt_table_manager_->WriteTableEntry(
+        status = tdi_table_manager_->WriteTableEntry(
             session, update.type(), update.entity().table_entry());
         break;
       case ::p4::v1::Entity::kExternEntry:
@@ -216,33 +216,33 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
                                   update.entity().extern_entry());
         break;
       case ::p4::v1::Entity::kActionProfileMember:
-        status = bfrt_action_profile_manager_->WriteActionProfileMember(
+        status = tdi_action_profile_manager_->WriteActionProfileMember(
             session, update.type(), update.entity().action_profile_member());
         break;
       case ::p4::v1::Entity::kActionProfileGroup:
-        status = bfrt_action_profile_manager_->WriteActionProfileGroup(
+        status = tdi_action_profile_manager_->WriteActionProfileGroup(
             session, update.type(), update.entity().action_profile_group());
         break;
       case ::p4::v1::Entity::kPacketReplicationEngineEntry:
-        status = bfrt_pre_manager_->WritePreEntry(
+        status = tdi_pre_manager_->WritePreEntry(
             session, update.type(),
             update.entity().packet_replication_engine_entry());
         break;
       case ::p4::v1::Entity::kDirectCounterEntry:
-        status = bfrt_table_manager_->WriteDirectCounterEntry(
+        status = tdi_table_manager_->WriteDirectCounterEntry(
             session, update.type(), update.entity().direct_counter_entry());
         break;
       case ::p4::v1::Entity::kCounterEntry:
-        status = bfrt_counter_manager_->WriteIndirectCounterEntry(
+        status = tdi_counter_manager_->WriteIndirectCounterEntry(
             session, update.type(), update.entity().counter_entry());
         break;
       case ::p4::v1::Entity::kRegisterEntry: {
-        status = bfrt_table_manager_->WriteRegisterEntry(
+        status = tdi_table_manager_->WriteRegisterEntry(
             session, update.type(), update.entity().register_entry());
         break;
       }
       case ::p4::v1::Entity::kMeterEntry: {
-        status = bfrt_table_manager_->WriteMeterEntry(
+        status = tdi_table_manager_->WriteMeterEntry(
             session, update.type(), update.entity().meter_entry());
         break;
       }
@@ -269,7 +269,7 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtNode::ReadForwardingEntries(
+::util::Status TdiNode::ReadForwardingEntries(
     const ::p4::v1::ReadRequest& req,
     WriterInterface<::p4::v1::ReadResponse>* writer,
     std::vector<::util::Status>* details) {
@@ -278,17 +278,17 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
 
   absl::ReaderMutexLock l(&lock_);
   CHECK_RETURN_IF_FALSE(req.device_id() == node_id_)
-      << "Request device id must be same as id of this BfrtNode.";
+      << "Request device id must be same as id of this TdiNode.";
   if (!initialized_ || !pipeline_initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
   }
   ::p4::v1::ReadResponse resp;
   bool success = true;
-  ASSIGN_OR_RETURN(auto session, bf_sde_interface_->CreateSession());
+  ASSIGN_OR_RETURN(auto session, tdi_sde_interface_->CreateSession());
   for (const auto& entity : req.entities()) {
     switch (entity.entity_case()) {
       case ::p4::v1::Entity::kTableEntry: {
-        auto status = bfrt_table_manager_->ReadTableEntry(
+        auto status = tdi_table_manager_->ReadTableEntry(
             session, entity.table_entry(), writer);
         success &= status.ok();
         details->push_back(status);
@@ -301,28 +301,28 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
         break;
       }
       case ::p4::v1::Entity::kActionProfileMember: {
-        auto status = bfrt_action_profile_manager_->ReadActionProfileMember(
+        auto status = tdi_action_profile_manager_->ReadActionProfileMember(
             session, entity.action_profile_member(), writer);
         success &= status.ok();
         details->push_back(status);
         break;
       }
       case ::p4::v1::Entity::kActionProfileGroup: {
-        auto status = bfrt_action_profile_manager_->ReadActionProfileGroup(
+        auto status = tdi_action_profile_manager_->ReadActionProfileGroup(
             session, entity.action_profile_group(), writer);
         success &= status.ok();
         details->push_back(status);
         break;
       }
       case ::p4::v1::Entity::kPacketReplicationEngineEntry: {
-        auto status = bfrt_pre_manager_->ReadPreEntry(
+        auto status = tdi_pre_manager_->ReadPreEntry(
             session, entity.packet_replication_engine_entry(), writer);
         success &= status.ok();
         details->push_back(status);
         break;
       }
       case ::p4::v1::Entity::kDirectCounterEntry: {
-        auto status = bfrt_table_manager_->ReadDirectCounterEntry(
+        auto status = tdi_table_manager_->ReadDirectCounterEntry(
             session, entity.direct_counter_entry());
         if (!status.ok()) {
           success = false;
@@ -334,21 +334,21 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
         break;
       }
       case ::p4::v1::Entity::kCounterEntry: {
-        auto status = bfrt_counter_manager_->ReadIndirectCounterEntry(
+        auto status = tdi_counter_manager_->ReadIndirectCounterEntry(
             session, entity.counter_entry(), writer);
         success &= status.ok();
         details->push_back(status);
         break;
       }
       case ::p4::v1::Entity::kRegisterEntry: {
-        auto status = bfrt_table_manager_->ReadRegisterEntry(
+        auto status = tdi_table_manager_->ReadRegisterEntry(
             session, entity.register_entry(), writer);
         success &= status.ok();
         details->push_back(status);
         break;
       }
       case ::p4::v1::Entity::kMeterEntry: {
-        auto status = bfrt_table_manager_->ReadMeterEntry(
+        auto status = tdi_table_manager_->ReadMeterEntry(
             session, entity.meter_entry(), writer);
         success &= status.ok();
         details->push_back(status);
@@ -375,7 +375,7 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtNode::RegisterStreamMessageResponseWriter(
+::util::Status TdiNode::RegisterStreamMessageResponseWriter(
     const std::shared_ptr<WriterInterface<::p4::v1::StreamMessageResponse>>&
         writer) {
   absl::WriterMutexLock l(&lock_);
@@ -387,19 +387,19 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
                                                ::p4::v1::PacketIn>>(
           writer, &::p4::v1::StreamMessageResponse::mutable_packet);
 
-  return bfrt_packetio_manager_->RegisterPacketReceiveWriter(packet_in_writer);
+  return tdi_packetio_manager_->RegisterPacketReceiveWriter(packet_in_writer);
 }
 
-::util::Status BfrtNode::UnregisterStreamMessageResponseWriter() {
+::util::Status TdiNode::UnregisterStreamMessageResponseWriter() {
   absl::WriterMutexLock l(&lock_);
   if (!initialized_) {
     return MAKE_ERROR(ERR_NOT_INITIALIZED) << "Not initialized!";
   }
 
-  return bfrt_packetio_manager_->UnregisterPacketReceiveWriter();
+  return tdi_packetio_manager_->UnregisterPacketReceiveWriter();
 }
 
-::util::Status BfrtNode::HandleStreamMessageRequest(
+::util::Status TdiNode::HandleStreamMessageRequest(
     const ::p4::v1::StreamMessageRequest& req) {
   absl::ReaderMutexLock l(&lock_);
   if (!initialized_) {
@@ -408,7 +408,7 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
 
   switch (req.update_case()) {
     case ::p4::v1::StreamMessageRequest::kPacket: {
-      return bfrt_packetio_manager_->TransmitPacket(req.packet());
+      return tdi_packetio_manager_->TransmitPacket(req.packet());
     }
     default:
       RETURN_ERROR(ERR_UNIMPLEMENTED) << "Unsupported StreamMessageRequest "
@@ -416,13 +416,13 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
   }
 }
 
-::util::Status BfrtNode::WriteExternEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiNode::WriteExternEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type, const ::p4::v1::ExternEntry& entry) {
   switch (entry.extern_type_id()) {
     case kTnaExternActionProfileId:
     case kTnaExternActionSelectorId:
-      return bfrt_action_profile_manager_->WriteActionProfileEntry(session,
+      return tdi_action_profile_manager_->WriteActionProfileEntry(session,
                                                                    type, entry);
     default:
       RETURN_ERROR() << "Unsupported extern entry: " << entry.ShortDebugString()
@@ -430,14 +430,14 @@ std::unique_ptr<BfrtNode> BfrtNode::CreateInstance(
   }
 }
 
-::util::Status BfrtNode::ReadExternEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiNode::ReadExternEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::ExternEntry& entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   switch (entry.extern_type_id()) {
     case kTnaExternActionProfileId:
     case kTnaExternActionSelectorId:
-      return bfrt_action_profile_manager_->ReadActionProfileEntry(
+      return tdi_action_profile_manager_->ReadActionProfileEntry(
           session, entry, writer);
     default:
       RETURN_ERROR(ERR_OPER_NOT_SUPPORTED)
diff --git a/stratum/hal/lib/barefoot/bfrt_node.h b/stratum/hal/lib/barefoot/bfrt_node.h
index 8c3f8757..0034f3d0 100644
--- a/stratum/hal/lib/barefoot/bfrt_node.h
+++ b/stratum/hal/lib/barefoot/bfrt_node.h
@@ -25,12 +25,12 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-// The BfrtNode class encapsulates all per P4-native node/chip/ASIC
+// The TdiNode class encapsulates all per P4-native node/chip/ASIC
 // functionalities, primarily the flow managers. Calls made to this class are
-// processed and passed through to the BfRt API.
-class BfrtNode {
+// processed and passed through to the TdiRt API.
+class TdiNode {
  public:
-  virtual ~BfrtNode();
+  virtual ~TdiNode();
 
   virtual ::util::Status PushChassisConfig(const ChassisConfig& config,
                                            uint64 node_id)
@@ -63,42 +63,43 @@ class BfrtNode {
   virtual ::util::Status HandleStreamMessageRequest(
       const ::p4::v1::StreamMessageRequest& req) LOCKS_EXCLUDED(lock_);
   // Factory function for creating the instance of the class.
-  static std::unique_ptr<BfrtNode> CreateInstance(
-      BfrtTableManager* bfrt_table_manager,
-      BfrtActionProfileManager* bfrt_action_profile_manager,
-      BfrtPacketioManager* bfrt_packetio_manager,
-      BfrtPreManager* bfrt_pre_manager,
-      BfrtCounterManager* bfrt_counter_manager,
-      BfSdeInterface* bf_sde_interface, int device_id);
-
-  // BfrtNode is neither copyable nor movable.
-  BfrtNode(const BfrtNode&) = delete;
-  BfrtNode& operator=(const BfrtNode&) = delete;
-  BfrtNode(BfrtNode&&) = delete;
-  BfrtNode& operator=(BfrtNode&&) = delete;
+  static std::unique_ptr<TdiNode> CreateInstance(
+      TdiTableManager* tdi_table_manager,
+      TdiActionProfileManager* tdi_action_profile_manager,
+      TdiPacketioManager* tdi_packetio_manager,
+      TdiPreManager* tdi_pre_manager,
+      TdiCounterManager* tdi_counter_manager,
+      TdiSdeInterface* tdi_sde_interface, int device_id);
+
+  // TdiNode is neither copyable nor movable.
+  TdiNode(const TdiNode&) = delete;
+  TdiNode& operator=(const TdiNode&) = delete;
+  TdiNode(TdiNode&&) = delete;
+  TdiNode& operator=(TdiNode&&) = delete;
+  uint64 node_id_ GUARDED_BY(lock_);
 
  protected:
   // Default constructor. To be called by the Mock class instance only.
-  BfrtNode();
+  TdiNode();
 
  private:
   // Private constructor. Use CreateInstance() to create an instance of this
   // class.
-  BfrtNode(BfrtTableManager* bfrt_table_manager,
-           BfrtActionProfileManager* bfrt_action_profile_manager,
-           BfrtPacketioManager* bfrt_packetio_manager,
-           BfrtPreManager* bfrt_pre_manager,
-           BfrtCounterManager* bfrt_counter_manager,
-           BfSdeInterface* bf_sde_interface, int device_id);
+  TdiNode(TdiTableManager* tdi_table_manager,
+           TdiActionProfileManager* tdi_action_profile_manager,
+           TdiPacketioManager* tdi_packetio_manager,
+           TdiPreManager* tdi_pre_manager,
+           TdiCounterManager* tdi_counter_manager,
+           TdiSdeInterface* tdi_sde_interface, int device_id);
 
   // Write extern entries like ActionProfile, DirectCounter, PortMetadata
   ::util::Status WriteExternEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type, const ::p4::v1::ExternEntry& entry);
 
   // Read extern entries like ActionProfile, DirectCounter, PortMetadata
   ::util::Status ReadExternEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::ExternEntry& entry,
       WriterInterface<::p4::v1::ReadResponse>* writer);
 
@@ -119,23 +120,22 @@ class BfrtNode {
   bool initialized_ GUARDED_BY(lock_);
 
   // Stores pipeline information for this node.
-  BfrtDeviceConfig bfrt_config_ GUARDED_BY(lock_);
+  TdirtDeviceConfig tdirt_config_ GUARDED_BY(lock_);
 
-  // Pointer to a BfSdeInterface implementation that wraps all the SDE calls.
+  // Pointer to a TdiSdeInterface implementation that wraps all the SDE calls.
   // Not owned by this class.
-  BfSdeInterface* bf_sde_interface_ = nullptr;
+  TdiSdeInterface* tdi_sde_interface_ = nullptr;
 
   // Managers. Not owned by this class.
-  BfrtTableManager* bfrt_table_manager_;
-  BfrtActionProfileManager* bfrt_action_profile_manager_;
-  BfrtPacketioManager* bfrt_packetio_manager_;
-  BfrtPreManager* bfrt_pre_manager_;
-  BfrtCounterManager* bfrt_counter_manager_;
+  TdiTableManager* tdi_table_manager_;
+  TdiActionProfileManager* tdi_action_profile_manager_;
+  TdiPacketioManager* tdi_packetio_manager_;
+  TdiPreManager* tdi_pre_manager_;
+  TdiCounterManager* tdi_counter_manager_;
 
   // Logical node ID corresponding to the node/ASIC managed by this class
   // instance. Assigned on PushChassisConfig() and might change during the
   // lifetime of the class.
-  uint64 node_id_ GUARDED_BY(lock_);
 
   // Fixed zero-based BFRT device_id number corresponding to the node/ASIC
   // managed by this class instance. Assigned in the class constructor.
diff --git a/stratum/hal/lib/barefoot/bfrt_node_mock.h b/stratum/hal/lib/barefoot/bfrt_node_mock.h
index 9f9f7903..c911e8a7 100644
--- a/stratum/hal/lib/barefoot/bfrt_node_mock.h
+++ b/stratum/hal/lib/barefoot/bfrt_node_mock.h
@@ -16,7 +16,7 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class BfrtNodeMock : public BfrtNode {
+class TdiNodeMock : public TdiNode {
  public:
   MOCK_METHOD2(PushChassisConfig,
                ::util::Status(const ChassisConfig& config, uint64 node_id));
diff --git a/stratum/hal/lib/barefoot/bfrt_packetio_manager.cc b/stratum/hal/lib/barefoot/bfrt_packetio_manager.cc
index b38a6861..a9fc9b8e 100644
--- a/stratum/hal/lib/barefoot/bfrt_packetio_manager.cc
+++ b/stratum/hal/lib/barefoot/bfrt_packetio_manager.cc
@@ -18,13 +18,13 @@
 #include "stratum/hal/lib/p4/utils.h"
 #include "stratum/lib/utils.h"
 
-DECLARE_bool(incompatible_enable_bfrt_legacy_bytestring_responses);
+DECLARE_bool(incompatible_enable_tdirt_legacy_bytestring_responses);
 
 namespace stratum {
 namespace hal {
 namespace barefoot {
 
-BfrtPacketioManager::BfrtPacketioManager(BfSdeInterface* bf_sde_interface,
+TdiPacketioManager::TdiPacketioManager(TdiSdeInterface* tdi_sde_interface,
                                          int device)
     : initialized_(false),
       rx_writer_(nullptr),
@@ -34,23 +34,23 @@ BfrtPacketioManager::BfrtPacketioManager(BfSdeInterface* bf_sde_interface,
       packetout_header_size_(),
       packet_receive_channel_(nullptr),
       sde_rx_thread_id_(0),
-      bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)),
+      tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)),
       device_(device) {}
 
-BfrtPacketioManager::~BfrtPacketioManager() {}
+TdiPacketioManager::~TdiPacketioManager() {}
 
-std::unique_ptr<BfrtPacketioManager> BfrtPacketioManager::CreateInstance(
-    BfSdeInterface* bf_sde_interface_, int device) {
-  return absl::WrapUnique(new BfrtPacketioManager(bf_sde_interface_, device));
+std::unique_ptr<TdiPacketioManager> TdiPacketioManager::CreateInstance(
+    TdiSdeInterface* tdi_sde_interface_, int device) {
+  return absl::WrapUnique(new TdiPacketioManager(tdi_sde_interface_, device));
 }
 
-::util::Status BfrtPacketioManager::PushChassisConfig(
+::util::Status TdiPacketioManager::PushChassisConfig(
     const ChassisConfig& config, uint64 node_id) {
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPacketioManager::PushForwardingPipelineConfig(
-    const BfrtDeviceConfig& config) {
+::util::Status TdiPacketioManager::PushForwardingPipelineConfig(
+    const TdirtDeviceConfig& config) {
   CHECK_RETURN_IF_FALSE(config.programs_size() == 1)
       << "Only one program is supported.";
   const auto& program = config.programs(0);
@@ -58,19 +58,19 @@ std::unique_ptr<BfrtPacketioManager> BfrtPacketioManager::CreateInstance(
     absl::WriterMutexLock l(&data_lock_);
     RETURN_IF_ERROR(BuildMetadataMapping(program.p4info()));
     // PushForwardingPipelineConfig resets the bf_pkt driver.
-    RETURN_IF_ERROR(bf_sde_interface_->StartPacketIo(device_));
+    RETURN_IF_ERROR(tdi_sde_interface_->StartPacketIo(device_));
     if (!initialized_) {
       packet_receive_channel_ = Channel<std::string>::Create(128);
       if (sde_rx_thread_id_ == 0) {
         int ret = pthread_create(&sde_rx_thread_id_, nullptr,
-                                 &BfrtPacketioManager::SdeRxThreadFunc, this);
+                                 &TdiPacketioManager::SdeRxThreadFunc, this);
         if (ret != 0) {
           RETURN_ERROR(ERR_INTERNAL)
               << "Failed to spawn RX thread for SDE wrapper for device with ID "
               << device_ << ". Err: " << ret << ".";
         }
       }
-      RETURN_IF_ERROR(bf_sde_interface_->RegisterPacketReceiveWriter(
+      RETURN_IF_ERROR(tdi_sde_interface_->RegisterPacketReceiveWriter(
           device_,
           ChannelWriter<std::string>::Create(packet_receive_channel_)));
     }
@@ -80,12 +80,12 @@ std::unique_ptr<BfrtPacketioManager> BfrtPacketioManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPacketioManager::VerifyChassisConfig(
+::util::Status TdiPacketioManager::VerifyChassisConfig(
     const ChassisConfig& config, uint64 node_id) {
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPacketioManager::Shutdown() {
+::util::Status TdiPacketioManager::Shutdown() {
   ::util::Status status;
   {
     absl::WriterMutexLock l(&rx_writer_lock_);
@@ -94,9 +94,9 @@ std::unique_ptr<BfrtPacketioManager> BfrtPacketioManager::CreateInstance(
   {
     absl::WriterMutexLock l(&data_lock_);
     if (initialized_) {
-      APPEND_STATUS_IF_ERROR(status, bf_sde_interface_->StopPacketIo(device_));
+      APPEND_STATUS_IF_ERROR(status, tdi_sde_interface_->StopPacketIo(device_));
       APPEND_STATUS_IF_ERROR(
-          status, bf_sde_interface_->UnregisterPacketReceiveWriter(device_));
+          status, tdi_sde_interface_->UnregisterPacketReceiveWriter(device_));
       if (!packet_receive_channel_ || !packet_receive_channel_->Close()) {
         ::util::Status error = MAKE_ERROR(ERR_INTERNAL)
                                << "Packet Rx channel is already closed.";
@@ -129,14 +129,14 @@ std::unique_ptr<BfrtPacketioManager> BfrtPacketioManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPacketioManager::RegisterPacketReceiveWriter(
+::util::Status TdiPacketioManager::RegisterPacketReceiveWriter(
     const std::shared_ptr<WriterInterface<::p4::v1::PacketIn>>& writer) {
   absl::WriterMutexLock l(&rx_writer_lock_);
   rx_writer_ = writer;
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPacketioManager::UnregisterPacketReceiveWriter() {
+::util::Status TdiPacketioManager::UnregisterPacketReceiveWriter() {
   absl::WriterMutexLock l(&rx_writer_lock_);
   rx_writer_ = nullptr;
   return ::util::OkStatus();
@@ -223,7 +223,7 @@ class BitBuffer {
 };
 }  // namespace
 
-::util::Status BfrtPacketioManager::DeparsePacketOut(
+::util::Status TdiPacketioManager::DeparsePacketOut(
     const ::p4::v1::PacketOut& packet, std::string* buffer) {
   absl::ReaderMutexLock l(&data_lock_);
   BitBuffer bit_buf;
@@ -250,7 +250,7 @@ class BitBuffer {
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPacketioManager::ParsePacketIn(const std::string& buffer,
+::util::Status TdiPacketioManager::ParsePacketIn(const std::string& buffer,
                                                   ::p4::v1::PacketIn* packet) {
   absl::ReaderMutexLock l(&data_lock_);
   CHECK_RETURN_IF_FALSE(buffer.size() >= packetin_header_size_)
@@ -263,7 +263,7 @@ class BitBuffer {
     auto metadata = packet->add_metadata();
     metadata->set_metadata_id(p.first);
     metadata->set_value(bit_buf.PopField(p.second));
-    if (!FLAGS_incompatible_enable_bfrt_legacy_bytestring_responses) {
+    if (!FLAGS_incompatible_enable_tdirt_legacy_bytestring_responses) {
       *metadata->mutable_value() =
           ByteStringToP4RuntimeByteString(metadata->value());
     }
@@ -277,7 +277,7 @@ class BitBuffer {
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPacketioManager::TransmitPacket(
+::util::Status TdiPacketioManager::TransmitPacket(
     const ::p4::v1::PacketOut& packet) {
   {
     absl::ReaderMutexLock l(&data_lock_);
@@ -286,13 +286,13 @@ class BitBuffer {
   std::string buf;
   RETURN_IF_ERROR(DeparsePacketOut(packet, &buf));
 
-  RETURN_IF_ERROR(bf_sde_interface_->TxPacket(device_, buf));
+  RETURN_IF_ERROR(tdi_sde_interface_->TxPacket(device_, buf));
 
   return ::util::OkStatus();
 }
 
 // TODO(max): drop Sde in name?
-::util::Status BfrtPacketioManager::HandleSdePacketRx() {
+::util::Status TdiPacketioManager::HandleSdePacketRx() {
   std::unique_ptr<ChannelReader<std::string>> reader;
   {
     absl::ReaderMutexLock l(&data_lock_);
@@ -326,7 +326,7 @@ class BitBuffer {
 // This function is based on P4TableMapper and implements a subset of its
 // functionality.
 // TODO(max): Check and reject if a mapping cannot be handled at runtime
-::util::Status BfrtPacketioManager::BuildMetadataMapping(
+::util::Status TdiPacketioManager::BuildMetadataMapping(
     const p4::config::v1::P4Info& p4_info) {
   std::vector<std::pair<uint32, int>> packetin_header;
   std::vector<std::pair<uint32, int>> packetout_header;
@@ -366,8 +366,8 @@ class BitBuffer {
   return ::util::OkStatus();
 }
 
-void* BfrtPacketioManager::SdeRxThreadFunc(void* arg) {
-  BfrtPacketioManager* mgr = reinterpret_cast<BfrtPacketioManager*>(arg);
+void* TdiPacketioManager::SdeRxThreadFunc(void* arg) {
+  TdiPacketioManager* mgr = reinterpret_cast<TdiPacketioManager*>(arg);
   ::util::Status status = mgr->HandleSdePacketRx();
   if (!status.ok()) {
     LOG(ERROR) << "Non-OK exit of RX thread for SDE interface.";
diff --git a/stratum/hal/lib/barefoot/bfrt_packetio_manager.h b/stratum/hal/lib/barefoot/bfrt_packetio_manager.h
index f970cbc4..b013fc16 100644
--- a/stratum/hal/lib/barefoot/bfrt_packetio_manager.h
+++ b/stratum/hal/lib/barefoot/bfrt_packetio_manager.h
@@ -25,9 +25,9 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class BfrtPacketioManager {
+class TdiPacketioManager {
  public:
-  virtual ~BfrtPacketioManager();
+  virtual ~TdiPacketioManager();
 
   // Pushes the parts of the given ChassisConfig proto that this class cares
   // about. If the class is not initialized (i.e. if config is pushed for the
@@ -45,7 +45,7 @@ class BfrtPacketioManager {
   // Pushes the forwarding pipeline to this class. If this is the first time, it
   // will also set up the necessary callbacks for packet IO.
   virtual ::util::Status PushForwardingPipelineConfig(
-      const BfrtDeviceConfig& config) LOCKS_EXCLUDED(data_lock_);
+      const TdirtDeviceConfig& config) LOCKS_EXCLUDED(data_lock_);
 
   // Performs coldboot shutdown. Note that there is no public Initialize().
   // Initialization is done as part of PushChassisConfig() if the class is not
@@ -66,21 +66,21 @@ class BfrtPacketioManager {
       LOCKS_EXCLUDED(data_lock_);
 
   // Factory function for creating the instance of the class.
-  static std::unique_ptr<BfrtPacketioManager> CreateInstance(
-      BfSdeInterface* bf_sde_interface, int device);
+  static std::unique_ptr<TdiPacketioManager> CreateInstance(
+      TdiSdeInterface* tdi_sde_interface, int device);
 
-  // BfrtPacketioManager is neither copyable nor movable.
-  BfrtPacketioManager(const BfrtPacketioManager&) = delete;
-  BfrtPacketioManager& operator=(const BfrtPacketioManager&) = delete;
+  // TdiPacketioManager is neither copyable nor movable.
+  TdiPacketioManager(const TdiPacketioManager&) = delete;
+  TdiPacketioManager& operator=(const TdiPacketioManager&) = delete;
 
  protected:
   // Default constructor. To be called by the Mock class instance only.
-  BfrtPacketioManager();
+  TdiPacketioManager();
 
  private:
   // Private constructor. Use CreateInstance() to create an instance of this
   // class.
-  explicit BfrtPacketioManager(BfSdeInterface* bf_sde_interface, int device);
+  explicit TdiPacketioManager(TdiSdeInterface* tdi_sde_interface, int device);
 
   // Builds the packet header structure for controller packets.
   ::util::Status BuildMetadataMapping(const p4::config::v1::P4Info& p4_info)
@@ -131,14 +131,14 @@ class BfrtPacketioManager {
   // The ID of the RX thread which handles receiving packets from the SDE.
   pthread_t sde_rx_thread_id_ GUARDED_BY(data_lock_);
 
-  // Pointer to a BfSdeInterface implementation that wraps all the SDE calls.
-  BfSdeInterface* bf_sde_interface_ = nullptr;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps all the SDE calls.
+  TdiSdeInterface* tdi_sde_interface_ = nullptr;  // not owned by this class.
 
   // Fixed zero-based Tofino device number corresponding to the node/ASIC
   // managed by this class instance. Assigned in the class constructor.
   const int device_;
 
-  friend class BfrtPacketioManagerTest;
+  friend class TdiPacketioManagerTest;
 };
 
 }  // namespace barefoot
diff --git a/stratum/hal/lib/barefoot/bfrt_packetio_manager_test.cc b/stratum/hal/lib/barefoot/bfrt_packetio_manager_test.cc
index 068e2176..5a9a2ef2 100644
--- a/stratum/hal/lib/barefoot/bfrt_packetio_manager_test.cc
+++ b/stratum/hal/lib/barefoot/bfrt_packetio_manager_test.cc
@@ -27,12 +27,12 @@ using ::testing::Invoke;
 using ::testing::InvokeWithoutArgs;
 using ::testing::Return;
 
-class BfrtPacketioManagerTest : public ::testing::Test {
+class TdiPacketioManagerTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    bf_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
-    bfrt_packetio_manager_ = BfrtPacketioManager::CreateInstance(
-        bf_sde_wrapper_mock_.get(), kDevice1);
+    tdi_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
+    tdi_packetio_manager_ = TdiPacketioManager::CreateInstance(
+        tdi_sde_wrapper_mock_.get(), kDevice1);
   }
 
   ::util::Status PushPipelineConfig(const std::string& p4info_str = kP4Info,
@@ -45,16 +45,16 @@ class BfrtPacketioManagerTest : public ::testing::Test {
       // What we expect when calling PushForwardingPipelineConfig with valid
       // config:
       // - StartPacketIo of SDE interface will be invoked
-      EXPECT_CALL(*bf_sde_wrapper_mock_, StartPacketIo(kDevice1))
+      EXPECT_CALL(*tdi_sde_wrapper_mock_, StartPacketIo(kDevice1))
           .WillOnce(Return(util::OkStatus()));
       // - RegisterPacketReceiveWriter of SDE interface will be invoked
-      EXPECT_CALL(*bf_sde_wrapper_mock_,
+      EXPECT_CALL(*tdi_sde_wrapper_mock_,
                   RegisterPacketReceiveWriter(kDevice1, _))
           .WillOnce(Invoke(
-              this, &BfrtPacketioManagerTest::RegisterPacketReceiveWriter));
+              this, &TdiPacketioManagerTest::RegisterPacketReceiveWriter));
     }
 
-    auto status = bfrt_packetio_manager_->PushForwardingPipelineConfig(config);
+    auto status = tdi_packetio_manager_->PushForwardingPipelineConfig(config);
     // FIXME(Yi Tseng): Wait few milliseconds to ensure the rx thread is ready.
     //                  Should check the internal state.
     absl::SleepFor(absl::Milliseconds(100));
@@ -64,17 +64,17 @@ class BfrtPacketioManagerTest : public ::testing::Test {
   ::util::Status Shutdown() {
     // Make sure everything like Rx threads will be cleaned up.
     {
-      absl::WriterMutexLock l(&bfrt_packetio_manager_->data_lock_);
-      if (bfrt_packetio_manager_->initialized_) {
-        EXPECT_CALL(*bf_sde_wrapper_mock_, StopPacketIo(kDevice1))
+      absl::WriterMutexLock l(&tdi_packetio_manager_->data_lock_);
+      if (tdi_packetio_manager_->initialized_) {
+        EXPECT_CALL(*tdi_sde_wrapper_mock_, StopPacketIo(kDevice1))
             .WillOnce(Return(util::OkStatus()));
-        EXPECT_CALL(*bf_sde_wrapper_mock_,
+        EXPECT_CALL(*tdi_sde_wrapper_mock_,
                     UnregisterPacketReceiveWriter(kDevice1))
             .WillOnce(Return(util::OkStatus()));
       }
     }
     packet_rx_writer.reset();
-    return bfrt_packetio_manager_->Shutdown();
+    return tdi_packetio_manager_->Shutdown();
   }
 
   // The mock method which help us to initialize a mock packet receive writer
@@ -137,26 +137,26 @@ class BfrtPacketioManagerTest : public ::testing::Test {
     }
   )PROTO";
 
-  std::unique_ptr<BfSdeMock> bf_sde_wrapper_mock_;
-  std::unique_ptr<BfrtPacketioManager> bfrt_packetio_manager_;
+  std::unique_ptr<BfSdeMock> tdi_sde_wrapper_mock_;
+  std::unique_ptr<TdiPacketioManager> tdi_packetio_manager_;
   std::unique_ptr<ChannelWriter<std::string>> packet_rx_writer;
 };
 
-constexpr int BfrtPacketioManagerTest::kDevice1;
-constexpr char BfrtPacketioManagerTest::kP4Info[];
+constexpr int TdiPacketioManagerTest::kDevice1;
+constexpr char TdiPacketioManagerTest::kP4Info[];
 
 // TODO(Yi Tseng): These two methods will always return OK status
 // We can add tests for these methods if we modify them.
-// TEST_F(BfrtPacketioManagerTest, PushChassisConfig) {}
-// TEST_F(BfrtPacketioManagerTest, VerifyChassisConfig) {}
+// TEST_F(TdiPacketioManagerTest, PushChassisConfig) {}
+// TEST_F(TdiPacketioManagerTest, VerifyChassisConfig) {}
 
 // Basic set up and shutdown test.
-TEST_F(BfrtPacketioManagerTest, PushForwardingPipelineConfigAndShutdown) {
+TEST_F(TdiPacketioManagerTest, PushForwardingPipelineConfigAndShutdown) {
   EXPECT_OK(PushPipelineConfig());
   EXPECT_OK(Shutdown());
 }
 
-TEST_F(BfrtPacketioManagerTest, PushInvalidPacketInConfigAndShutdown) {
+TEST_F(TdiPacketioManagerTest, PushInvalidPacketInConfigAndShutdown) {
   // The total length of packet-in metadata is not byte aligned
   const char invalid_packet_in[] = R"PROTO(
     controller_packet_metadata {
@@ -181,7 +181,7 @@ TEST_F(BfrtPacketioManagerTest, PushInvalidPacketInConfigAndShutdown) {
   EXPECT_OK(Shutdown());
 }
 
-TEST_F(BfrtPacketioManagerTest, PushInvalidPacketOutConfigAndShutdown) {
+TEST_F(TdiPacketioManagerTest, PushInvalidPacketOutConfigAndShutdown) {
   // The total length of packet-out metadata is not byte aligned
   const char invalid_packet_out[] = R"PROTO(
     controller_packet_metadata {
@@ -207,7 +207,7 @@ TEST_F(BfrtPacketioManagerTest, PushInvalidPacketOutConfigAndShutdown) {
   EXPECT_OK(Shutdown());
 }
 
-TEST_F(BfrtPacketioManagerTest,
+TEST_F(TdiPacketioManagerTest,
        PushUnknownControllerPacketMetadataConfigAndShutdown) {
   // The unknown
   const char p4info_with_known[] = R"PROTO(
@@ -237,7 +237,7 @@ TEST_F(BfrtPacketioManagerTest,
   EXPECT_OK(Shutdown());
 }
 
-TEST_F(BfrtPacketioManagerTest, TransmitPacketAfterPipelineConfigPush) {
+TEST_F(TdiPacketioManagerTest, TransmitPacketAfterPipelineConfigPush) {
   EXPECT_OK(PushPipelineConfig());
   p4::v1::PacketOut packet_out;
   const char packet_out_str[] = R"PROTO(
@@ -264,13 +264,13 @@ TEST_F(BfrtPacketioManagerTest, TransmitPacketAfterPipelineConfigPush) {
       "\0\x80\0\0\0\0\0\0\0\0\0\0\xBF\x1"
       "abcde",
       19);
-  EXPECT_CALL(*bf_sde_wrapper_mock_, TxPacket(kDevice1, expected_packet))
+  EXPECT_CALL(*tdi_sde_wrapper_mock_, TxPacket(kDevice1, expected_packet))
       .WillOnce(Return(util::OkStatus()));
-  EXPECT_OK(bfrt_packetio_manager_->TransmitPacket(packet_out));
+  EXPECT_OK(tdi_packetio_manager_->TransmitPacket(packet_out));
   EXPECT_OK(Shutdown());
 }
 
-TEST_F(BfrtPacketioManagerTest, TransmitInvalidPacketAfterPipelineConfigPush) {
+TEST_F(TdiPacketioManagerTest, TransmitInvalidPacketAfterPipelineConfigPush) {
   EXPECT_OK(PushPipelineConfig());
   p4::v1::PacketOut packet_out;
   // Missing the third metadata.
@@ -290,17 +290,17 @@ TEST_F(BfrtPacketioManagerTest, TransmitInvalidPacketAfterPipelineConfigPush) {
     }
   )PROTO";
   EXPECT_OK(ParseProtoFromString(packet_out_str, &packet_out));
-  auto status = bfrt_packetio_manager_->TransmitPacket(packet_out);
+  auto status = tdi_packetio_manager_->TransmitPacket(packet_out);
   EXPECT_FALSE(status.ok());
   EXPECT_THAT(status.error_message(),
               HasSubstr("Missing metadata with Id 4 in PacketOut"));
   EXPECT_OK(Shutdown());
 }
 
-TEST_F(BfrtPacketioManagerTest, TestPacketIn) {
+TEST_F(TdiPacketioManagerTest, TestPacketIn) {
   EXPECT_OK(PushPipelineConfig());
   auto writer = std::make_shared<WriterMock<::p4::v1::PacketIn>>();
-  EXPECT_OK(bfrt_packetio_manager_->RegisterPacketReceiveWriter(writer));
+  EXPECT_OK(tdi_packetio_manager_->RegisterPacketReceiveWriter(writer));
   const char expected_packet_in_str[] = R"PROTO(
     payload: "abcde"
     metadata {
@@ -338,7 +338,7 @@ TEST_F(BfrtPacketioManagerTest, TestPacketIn) {
   // packet-in writer.
   EXPECT_TRUE(
       write_notifier->WaitForNotificationWithTimeout(absl::Milliseconds(100)));
-  EXPECT_OK(bfrt_packetio_manager_->UnregisterPacketReceiveWriter());
+  EXPECT_OK(tdi_packetio_manager_->UnregisterPacketReceiveWriter());
   EXPECT_OK(Shutdown());
 }
 
diff --git a/stratum/hal/lib/barefoot/bfrt_pre_manager.cc b/stratum/hal/lib/barefoot/bfrt_pre_manager.cc
index 37b91873..4bbafeba 100644
--- a/stratum/hal/lib/barefoot/bfrt_pre_manager.cc
+++ b/stratum/hal/lib/barefoot/bfrt_pre_manager.cc
@@ -17,17 +17,17 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-BfrtPreManager::BfrtPreManager(BfSdeInterface* bf_sde_interface, int device)
-    : bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)), device_(device) {}
+TdiPreManager::TdiPreManager(TdiSdeInterface* tdi_sde_interface, int device)
+    : tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)), device_(device) {}
 
-::util::Status BfrtPreManager::PushForwardingPipelineConfig(
-    const BfrtDeviceConfig& config) {
+::util::Status TdiPreManager::PushForwardingPipelineConfig(
+    const TdirtDeviceConfig& config) {
   absl::WriterMutexLock l(&lock_);
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPreManager::WritePreEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiPreManager::WritePreEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type& type, const PreEntry& entry) {
   absl::WriterMutexLock l(&lock_);
   switch (entry.type_case()) {
@@ -42,8 +42,8 @@ BfrtPreManager::BfrtPreManager(BfSdeInterface* bf_sde_interface, int device)
   }
 }
 
-::util::Status BfrtPreManager::ReadPreEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiPreManager::ReadPreEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const PreEntry& entry, WriterInterface<::p4::v1::ReadResponse>* writer) {
   absl::ReaderMutexLock l(&lock_);
   switch (entry.type_case()) {
@@ -65,13 +65,13 @@ BfrtPreManager::BfrtPreManager(BfSdeInterface* bf_sde_interface, int device)
   return ::util::OkStatus();
 }
 
-std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
-    BfSdeInterface* bf_sde_interface, int device) {
-  return absl::WrapUnique(new BfrtPreManager(bf_sde_interface, device));
+std::unique_ptr<TdiPreManager> TdiPreManager::CreateInstance(
+    TdiSdeInterface* tdi_sde_interface, int device) {
+  return absl::WrapUnique(new TdiPreManager(tdi_sde_interface, device));
 }
 
-::util::StatusOr<std::vector<uint32>> BfrtPreManager::InsertMulticastNodes(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::StatusOr<std::vector<uint32>> TdiPreManager::InsertMulticastNodes(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::MulticastGroupEntry& entry) {
   const uint32 group_id = entry.multicast_group_id();
   CHECK_RETURN_IF_FALSE(group_id <= kMaxMulticastGroupId);
@@ -90,7 +90,7 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
     const std::vector<uint32>& egress_ports = replica.second;
     std::vector<uint32> mc_lag_ids;
     ASSIGN_OR_RETURN(uint32 mc_node_id,
-                     bf_sde_interface_->CreateMulticastNode(
+                     tdi_sde_interface_->CreateMulticastNode(
                          device_, session, instance, mc_lag_ids, egress_ports));
     new_nodes.push_back(mc_node_id);
   }
@@ -99,8 +99,8 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
 }
 
 // FIXME: We need to revert partial modifications in case of failures.
-::util::Status BfrtPreManager::WriteMulticastGroupEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiPreManager::WriteMulticastGroupEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type& type,
     const ::p4::v1::MulticastGroupEntry& entry) {
   VLOG(1) << ::p4::v1::Update_Type_Name(type) << " "
@@ -110,23 +110,23 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
     case ::p4::v1::Update::INSERT: {
       ASSIGN_OR_RETURN(std::vector<uint32> mc_node_ids,
                        InsertMulticastNodes(session, entry));
-      RETURN_IF_ERROR(bf_sde_interface_->InsertMulticastGroup(
+      RETURN_IF_ERROR(tdi_sde_interface_->InsertMulticastGroup(
           device_, session, entry.multicast_group_id(), mc_node_ids));
       break;
     }
     case ::p4::v1::Update::MODIFY: {
       ASSIGN_OR_RETURN(auto current_node_ids,
-                       bf_sde_interface_->GetNodesInMulticastGroup(
+                       tdi_sde_interface_->GetNodesInMulticastGroup(
                            device_, session, entry.multicast_group_id()));
       ASSIGN_OR_RETURN(std::vector<uint32> new_node_ids,
                        InsertMulticastNodes(session, entry));
       RETURN_IF_ERROR_WITH_APPEND(
-          bf_sde_interface_->ModifyMulticastGroup(
+          tdi_sde_interface_->ModifyMulticastGroup(
               device_, session, entry.multicast_group_id(), new_node_ids))
               .with_logging()
           << "Failed to write multicast group for request "
           << entry.ShortDebugString() << ".";
-      RETURN_IF_ERROR_WITH_APPEND(bf_sde_interface_->DeleteMulticastNodes(
+      RETURN_IF_ERROR_WITH_APPEND(tdi_sde_interface_->DeleteMulticastNodes(
                                       device_, session, current_node_ids))
               .with_logging()
           << "Failed to delete multicast nodes for request "
@@ -138,16 +138,16 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
           << "Replicas are ignored on MulticastGroupEntry delete requests: "
           << entry.ShortDebugString() << ".";
       ASSIGN_OR_RETURN(auto node_ids,
-                       bf_sde_interface_->GetNodesInMulticastGroup(
+                       tdi_sde_interface_->GetNodesInMulticastGroup(
                            device_, session, entry.multicast_group_id()));
       RETURN_IF_ERROR_WITH_APPEND(
-          bf_sde_interface_->DeleteMulticastGroup(device_, session,
+          tdi_sde_interface_->DeleteMulticastGroup(device_, session,
                                                   entry.multicast_group_id()))
               .with_logging()
           << "Failed to delete multicast group for request "
           << entry.ShortDebugString() << ".";
       RETURN_IF_ERROR_WITH_APPEND(
-          bf_sde_interface_->DeleteMulticastNodes(device_, session, node_ids))
+          tdi_sde_interface_->DeleteMulticastNodes(device_, session, node_ids))
               .with_logging()
           << "Failed to delete multicast nodes for request "
           << entry.ShortDebugString() << ".";
@@ -159,13 +159,13 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPreManager::ReadMulticastGroupEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiPreManager::ReadMulticastGroupEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::MulticastGroupEntry& entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   std::vector<uint32> group_ids;
   std::vector<std::vector<uint32>> mc_node_ids_per_group;
-  RETURN_IF_ERROR(bf_sde_interface_->GetMulticastGroups(
+  RETURN_IF_ERROR(tdi_sde_interface_->GetMulticastGroups(
       device_, session, entry.multicast_group_id(), &group_ids,
       &mc_node_ids_per_group));
 
@@ -183,7 +183,7 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
       int replication_id;
       std::vector<uint32> lag_ids;
       std::vector<uint32> ports;
-      RETURN_IF_ERROR(bf_sde_interface_->GetMulticastNode(
+      RETURN_IF_ERROR(tdi_sde_interface_->GetMulticastNode(
           device_, session, mc_node_id, &replication_id, &lag_ids, &ports));
       for (const auto& port : ports) {
         ::p4::v1::Replica replica;
@@ -217,8 +217,8 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPreManager::WriteCloneSessionEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiPreManager::WriteCloneSessionEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type& type,
     const ::p4::v1::CloneSessionEntry& entry) {
   CHECK_RETURN_IF_FALSE(entry.session_id() != 0 &&
@@ -244,7 +244,7 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
       CHECK_RETURN_IF_FALSE(replica.instance() == 0)
           << "Instances on Replicas are not supported: "
           << replica.ShortDebugString() << ".";
-      RETURN_IF_ERROR(bf_sde_interface_->InsertCloneSession(
+      RETURN_IF_ERROR(tdi_sde_interface_->InsertCloneSession(
           device_, session, entry.session_id(), replica.egress_port(),
           entry.class_of_service(), entry.packet_length_bytes()));
       break;
@@ -260,13 +260,13 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
       CHECK_RETURN_IF_FALSE(replica.instance() == 0)
           << "Instances on Replicas are not supported: "
           << replica.ShortDebugString() << ".";
-      RETURN_IF_ERROR(bf_sde_interface_->ModifyCloneSession(
+      RETURN_IF_ERROR(tdi_sde_interface_->ModifyCloneSession(
           device_, session, entry.session_id(), replica.egress_port(),
           entry.class_of_service(), entry.packet_length_bytes()));
       break;
     }
     case ::p4::v1::Update::DELETE: {
-      RETURN_IF_ERROR(bf_sde_interface_->DeleteCloneSession(
+      RETURN_IF_ERROR(tdi_sde_interface_->DeleteCloneSession(
           device_, session, entry.session_id()));
       break;
     }
@@ -279,15 +279,15 @@ std::unique_ptr<BfrtPreManager> BfrtPreManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtPreManager::ReadCloneSessionEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiPreManager::ReadCloneSessionEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::CloneSessionEntry& entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   std::vector<uint32> session_ids;
   std::vector<int> egress_ports;
   std::vector<int> coss;
   std::vector<int> max_pkt_lens;
-  RETURN_IF_ERROR(bf_sde_interface_->GetCloneSessions(
+  RETURN_IF_ERROR(tdi_sde_interface_->GetCloneSessions(
       device_, session, entry.session_id(), &session_ids, &egress_ports, &coss,
       &max_pkt_lens));
 
diff --git a/stratum/hal/lib/barefoot/bfrt_pre_manager.h b/stratum/hal/lib/barefoot/bfrt_pre_manager.h
index 28b15ab9..70ea6461 100644
--- a/stratum/hal/lib/barefoot/bfrt_pre_manager.h
+++ b/stratum/hal/lib/barefoot/bfrt_pre_manager.h
@@ -24,72 +24,72 @@ namespace barefoot {
 
 using PreEntry = ::p4::v1::PacketReplicationEngineEntry;
 
-class BfrtPreManager {
+class TdiPreManager {
  public:
   // Pushes a ForwardingPipelineConfig.
-  ::util::Status PushForwardingPipelineConfig(const BfrtDeviceConfig& config)
+  ::util::Status PushForwardingPipelineConfig(const TdirtDeviceConfig& config)
       LOCKS_EXCLUDED(lock_);
 
   // Writes a PRE entry.
   ::util::Status WritePreEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type& type, const PreEntry& entry)
       LOCKS_EXCLUDED(lock_);
 
   // Reads a PRE entry.
   ::util::Status ReadPreEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const PreEntry& entry, WriterInterface<::p4::v1::ReadResponse>* writer)
       LOCKS_EXCLUDED(lock_);
 
-  static std::unique_ptr<BfrtPreManager> CreateInstance(
-      BfSdeInterface* bf_sde_interface, int device);
+  static std::unique_ptr<TdiPreManager> CreateInstance(
+      TdiSdeInterface* tdi_sde_interface, int device);
 
  private:
   // Private constructor, we can create the instance by using `CreateInstance`
   // function only.
-  explicit BfrtPreManager(BfSdeInterface* bf_sde_interface, int device);
+  explicit TdiPreManager(TdiSdeInterface* tdi_sde_interface, int device);
 
   // Insert/Modify/Delete a multicast group entry.
   // This function creates one or more multicast nodes based on replicas in
   // the entry and associate them to a multicast group.
   ::util::Status WriteMulticastGroupEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type& type,
       const ::p4::v1::MulticastGroupEntry& entry)
       EXCLUSIVE_LOCKS_REQUIRED(lock_);
 
   // Insert/Modify/Delete a clone session entry.
   ::util::Status WriteCloneSessionEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type& type,
       const ::p4::v1::CloneSessionEntry& entry) EXCLUSIVE_LOCKS_REQUIRED(lock_);
 
   // Reads a multicast group entry.
   ::util::Status ReadMulticastGroupEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::MulticastGroupEntry& entry,
       WriterInterface<::p4::v1::ReadResponse>* writer)
       SHARED_LOCKS_REQUIRED(lock_);
 
   // Reads a clone session entry.
   ::util::Status ReadCloneSessionEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::CloneSessionEntry& entry,
       WriterInterface<::p4::v1::ReadResponse>* writer)
       SHARED_LOCKS_REQUIRED(lock_);
 
   // Insert new multicast nodes of a given multicast group.
   ::util::StatusOr<std::vector<uint32>> InsertMulticastNodes(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::MulticastGroupEntry& entry)
       EXCLUSIVE_LOCKS_REQUIRED(lock_);
 
   // Reader-writer lock used to protect access to pipeline state.
   mutable absl::Mutex lock_;
 
-  // Pointer to a BfSdeInterface implementation that wraps all the SDE calls.
-  BfSdeInterface* bf_sde_interface_ = nullptr;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps all the SDE calls.
+  TdiSdeInterface* tdi_sde_interface_ = nullptr;  // not owned by this class.
 
   // Fixed zero-based Tofino device number corresponding to the node/ASIC
   // managed by this class instance. Assigned in the class constructor.
diff --git a/stratum/hal/lib/barefoot/bfrt_pre_manager_test.cc b/stratum/hal/lib/barefoot/bfrt_pre_manager_test.cc
index 004a2ac8..12fd523e 100644
--- a/stratum/hal/lib/barefoot/bfrt_pre_manager_test.cc
+++ b/stratum/hal/lib/barefoot/bfrt_pre_manager_test.cc
@@ -23,34 +23,34 @@ using ::testing::Invoke;
 using ::testing::InvokeWithoutArgs;
 using ::testing::Return;
 
-class BfrtPreManagerTest : public ::testing::Test {
+class TdiPreManagerTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    bf_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
-    bfrt_pre_manager_ =
-        BfrtPreManager::CreateInstance(bf_sde_wrapper_mock_.get(), kDevice1);
+    tdi_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
+    tdi_pre_manager_ =
+        TdiPreManager::CreateInstance(tdi_sde_wrapper_mock_.get(), kDevice1);
   }
 
   static constexpr int kDevice1 = 0;
 
-  std::unique_ptr<BfSdeMock> bf_sde_wrapper_mock_;
-  std::unique_ptr<BfrtPreManager> bfrt_pre_manager_;
+  std::unique_ptr<BfSdeMock> tdi_sde_wrapper_mock_;
+  std::unique_ptr<TdiPreManager> tdi_pre_manager_;
 };
 
-constexpr int BfrtPreManagerTest::kDevice1;
+constexpr int TdiPreManagerTest::kDevice1;
 
-TEST_F(BfrtPreManagerTest, DeleteMulticastGroupTest) {
+TEST_F(TdiPreManagerTest, DeleteMulticastGroupTest) {
   constexpr int kGroupId = 55;
   const std::vector<uint32> nodes = {1, 2, 3};
   auto session_mock = std::make_shared<SessionMock>();
 
-  EXPECT_CALL(*bf_sde_wrapper_mock_,
+  EXPECT_CALL(*tdi_sde_wrapper_mock_,
               GetNodesInMulticastGroup(kDevice1, _, kGroupId))
       .WillOnce(Return(nodes));
-  EXPECT_CALL(*bf_sde_wrapper_mock_,
+  EXPECT_CALL(*tdi_sde_wrapper_mock_,
               DeleteMulticastGroup(kDevice1, _, kGroupId))
       .WillOnce(Return(::util::OkStatus()));
-  EXPECT_CALL(*bf_sde_wrapper_mock_, DeleteMulticastNodes(kDevice1, _, nodes))
+  EXPECT_CALL(*tdi_sde_wrapper_mock_, DeleteMulticastNodes(kDevice1, _, nodes))
       .WillOnce(Return(::util::OkStatus()));
 
   // TODO(max): remove replicas, ignored on delete.
@@ -74,7 +74,7 @@ TEST_F(BfrtPreManagerTest, DeleteMulticastGroupTest) {
   ::p4::v1::PacketReplicationEngineEntry entry;
   ASSERT_OK(ParseProtoFromString(kMulticastGroupEntryText, &entry));
 
-  EXPECT_OK(bfrt_pre_manager_->WritePreEntry(session_mock,
+  EXPECT_OK(tdi_pre_manager_->WritePreEntry(session_mock,
                                              ::p4::v1::Update::DELETE, entry));
 }
 
diff --git a/stratum/hal/lib/barefoot/bfrt_switch.cc b/stratum/hal/lib/barefoot/bfrt_switch.cc
index f553054d..1ea18990 100644
--- a/stratum/hal/lib/barefoot/bfrt_switch.cc
+++ b/stratum/hal/lib/barefoot/bfrt_switch.cc
@@ -13,7 +13,7 @@
 #include "stratum/glue/integral_types.h"
 #include "stratum/glue/logging.h"
 #include "stratum/glue/status/status_macros.h"
-#include "stratum/hal/lib/barefoot/bf_chassis_manager.h"
+#include "bfIntf/bf_chassis_manager.h"
 #include "stratum/hal/lib/barefoot/bfrt_node.h"
 #include "stratum/hal/lib/barefoot/utils.h"
 #include "stratum/lib/constants.h"
@@ -23,38 +23,41 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-BfrtSwitch::BfrtSwitch(PhalInterface* phal_interface,
-                       BfChassisManager* bf_chassis_manager,
-                       BfSdeInterface* bf_sde_interface,
-                       const std::map<int, BfrtNode*>& device_id_to_bfrt_node)
+TdirtSwitch::TdirtSwitch(PhalInterface* phal_interface,
+                       TdiChassisManager* tdi_chassis_manager,
+                       TdiSdeInterface* tdi_sde_interface,
+                       const std::map<int, TdiNode*>& device_id_to_tdi_node)
     : phal_interface_(ABSL_DIE_IF_NULL(phal_interface)),
-      bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)),
-      bf_chassis_manager_(ABSL_DIE_IF_NULL(bf_chassis_manager)),
-      device_id_to_bfrt_node_(device_id_to_bfrt_node),
-      node_id_to_bfrt_node_() {
-  for (const auto& entry : device_id_to_bfrt_node_) {
+      tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)),
+      tdi_chassis_manager_(ABSL_DIE_IF_NULL(tdi_chassis_manager)),
+      device_id_to_tdi_node_(device_id_to_tdi_node),
+      node_id_to_tdi_node_() {
+  for (const auto& entry : device_id_to_tdi_node_) {
     CHECK_GE(entry.first, 0)
         << "Invalid device_id number " << entry.first << ".";
+/*
     CHECK_NE(entry.second, nullptr)
-        << "Detected null BfrtNode for device_id " << entry.first << ".";
+        << "Detected null TdiNode for device_id " << entry.first << ".";
+*/
+
   }
 }
 
-BfrtSwitch::~BfrtSwitch() {}
+TdirtSwitch::~TdirtSwitch() {}
 
-::util::Status BfrtSwitch::PushChassisConfig(const ChassisConfig& config) {
+::util::Status TdirtSwitch::PushChassisConfig(const ChassisConfig& config) {
   absl::WriterMutexLock l(&chassis_lock);
   RETURN_IF_ERROR(phal_interface_->PushChassisConfig(config));
-  RETURN_IF_ERROR(bf_chassis_manager_->PushChassisConfig(config));
+  RETURN_IF_ERROR(tdi_chassis_manager_->PushChassisConfig(config));
   ASSIGN_OR_RETURN(const auto& node_id_to_device_id,
-                   bf_chassis_manager_->GetNodeIdToUnitMap());
-  node_id_to_bfrt_node_.clear();
+                   tdi_chassis_manager_->GetNodeIdToUnitMap());
+  node_id_to_tdi_node_.clear();
   for (const auto& entry : node_id_to_device_id) {
     uint64 node_id = entry.first;
     int device_id = entry.second;
-    ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromDeviceId(device_id));
-    RETURN_IF_ERROR(bfrt_node->PushChassisConfig(config, node_id));
-    node_id_to_bfrt_node_[node_id] = bfrt_node;
+    ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromDeviceId(device_id));
+    RETURN_IF_ERROR(tdi_node->PushChassisConfig(config, node_id));
+    node_id_to_tdi_node_[node_id] = tdi_node;
   }
 
   LOG(INFO) << "Chassis config pushed successfully.";
@@ -62,38 +65,38 @@ BfrtSwitch::~BfrtSwitch() {}
   return ::util::OkStatus();
 }
 
-::util::Status BfrtSwitch::VerifyChassisConfig(const ChassisConfig& config) {
+::util::Status TdirtSwitch::VerifyChassisConfig(const ChassisConfig& config) {
   (void)config;
   return ::util::OkStatus();
 }
 
-::util::Status BfrtSwitch::PushForwardingPipelineConfig(
+::util::Status TdirtSwitch::PushForwardingPipelineConfig(
     uint64 node_id, const ::p4::v1::ForwardingPipelineConfig& config) {
   absl::WriterMutexLock l(&chassis_lock);
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(node_id));
-  RETURN_IF_ERROR(bfrt_node->PushForwardingPipelineConfig(config));
-  RETURN_IF_ERROR(bf_chassis_manager_->ReplayPortsConfig(node_id));
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(node_id));
+  RETURN_IF_ERROR(tdi_node->PushForwardingPipelineConfig(config));
+  RETURN_IF_ERROR(tdi_chassis_manager_->ReplayPortsConfig(node_id));
 
   LOG(INFO) << "P4-based forwarding pipeline config pushed successfully to "
             << "node with ID " << node_id << ".";
 
   ASSIGN_OR_RETURN(const auto& node_id_to_device_id,
-                   bf_chassis_manager_->GetNodeIdToUnitMap());
+                   tdi_chassis_manager_->GetNodeIdToUnitMap());
 
   CHECK_RETURN_IF_FALSE(gtl::ContainsKey(node_id_to_device_id, node_id))
       << "Unable to find device_id number for node " << node_id;
   int device_id = gtl::FindOrDie(node_id_to_device_id, node_id);
-  ASSIGN_OR_RETURN(auto cpu_port, bf_sde_interface_->GetPcieCpuPort(device_id));
-  RETURN_IF_ERROR(bf_sde_interface_->SetTmCpuPort(device_id, cpu_port));
+  ASSIGN_OR_RETURN(auto cpu_port, tdi_sde_interface_->GetPcieCpuPort(device_id));
+  RETURN_IF_ERROR(tdi_sde_interface_->SetTmCpuPort(device_id, cpu_port));
   return ::util::OkStatus();
 }
 
-::util::Status BfrtSwitch::SaveForwardingPipelineConfig(
+::util::Status TdirtSwitch::SaveForwardingPipelineConfig(
     uint64 node_id, const ::p4::v1::ForwardingPipelineConfig& config) {
   absl::WriterMutexLock l(&chassis_lock);
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(node_id));
-  RETURN_IF_ERROR(bfrt_node->SaveForwardingPipelineConfig(config));
-  RETURN_IF_ERROR(bf_chassis_manager_->ReplayPortsConfig(node_id));
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(node_id));
+  RETURN_IF_ERROR(tdi_node->SaveForwardingPipelineConfig(config));
+  RETURN_IF_ERROR(tdi_chassis_manager_->ReplayPortsConfig(node_id));
 
   LOG(INFO) << "P4-based forwarding pipeline config saved successfully to "
             << "node with ID " << node_id << ".";
@@ -101,10 +104,10 @@ BfrtSwitch::~BfrtSwitch() {}
   return ::util::OkStatus();
 }
 
-::util::Status BfrtSwitch::CommitForwardingPipelineConfig(uint64 node_id) {
+::util::Status TdirtSwitch::CommitForwardingPipelineConfig(uint64 node_id) {
   absl::WriterMutexLock l(&chassis_lock);
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(node_id));
-  RETURN_IF_ERROR(bfrt_node->CommitForwardingPipelineConfig());
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(node_id));
+  RETURN_IF_ERROR(tdi_node->CommitForwardingPipelineConfig());
 
   LOG(INFO) << "P4-based forwarding pipeline config committed successfully to "
             << "node with ID " << node_id << ".";
@@ -112,31 +115,31 @@ BfrtSwitch::~BfrtSwitch() {}
   return ::util::OkStatus();
 }
 
-::util::Status BfrtSwitch::VerifyForwardingPipelineConfig(
+::util::Status TdirtSwitch::VerifyForwardingPipelineConfig(
     uint64 node_id, const ::p4::v1::ForwardingPipelineConfig& config) {
   absl::WriterMutexLock l(&chassis_lock);
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(node_id));
-  return bfrt_node->VerifyForwardingPipelineConfig(config);
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(node_id));
+  return tdi_node->VerifyForwardingPipelineConfig(config);
 }
 
-::util::Status BfrtSwitch::Shutdown() {
+::util::Status TdirtSwitch::Shutdown() {
   ::util::Status status = ::util::OkStatus();
-  for (const auto& entry : device_id_to_bfrt_node_) {
-    BfrtNode* node = entry.second;
+  for (const auto& entry : device_id_to_tdi_node_) {
+    TdiNode* node = entry.second;
     APPEND_STATUS_IF_ERROR(status, node->Shutdown());
   }
-  APPEND_STATUS_IF_ERROR(status, bf_chassis_manager_->Shutdown());
+  APPEND_STATUS_IF_ERROR(status, tdi_chassis_manager_->Shutdown());
   APPEND_STATUS_IF_ERROR(status, phal_interface_->Shutdown());
-  // APPEND_STATUS_IF_ERROR(status, bf_sde_interface_->Shutdown());
+  // APPEND_STATUS_IF_ERROR(status, tdi_sde_interface_->Shutdown());
 
   return status;
 }
 
-::util::Status BfrtSwitch::Freeze() { return ::util::OkStatus(); }
+::util::Status TdirtSwitch::Freeze() { return ::util::OkStatus(); }
 
-::util::Status BfrtSwitch::Unfreeze() { return ::util::OkStatus(); }
+::util::Status TdirtSwitch::Unfreeze() { return ::util::OkStatus(); }
 
-::util::Status BfrtSwitch::WriteForwardingEntries(
+::util::Status TdirtSwitch::WriteForwardingEntries(
     const ::p4::v1::WriteRequest& req, std::vector<::util::Status>* results) {
   if (!req.updates_size()) return ::util::OkStatus();  // nothing to do.
   CHECK_RETURN_IF_FALSE(req.device_id()) << "No device_id in WriteRequest.";
@@ -144,11 +147,11 @@ BfrtSwitch::~BfrtSwitch() {}
       << "Need to provide non-null results pointer for non-empty updates.";
 
   absl::ReaderMutexLock l(&chassis_lock);
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(req.device_id()));
-  return bfrt_node->WriteForwardingEntries(req, results);
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(req.device_id()));
+  return tdi_node->WriteForwardingEntries(req, results);
 }
 
-::util::Status BfrtSwitch::ReadForwardingEntries(
+::util::Status TdirtSwitch::ReadForwardingEntries(
     const ::p4::v1::ReadRequest& req,
     WriterInterface<::p4::v1::ReadResponse>* writer,
     std::vector<::util::Status>* details) {
@@ -157,39 +160,39 @@ BfrtSwitch::~BfrtSwitch() {}
   CHECK_RETURN_IF_FALSE(details) << "Details pointer must be non-null.";
 
   absl::ReaderMutexLock l(&chassis_lock);
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(req.device_id()));
-  return bfrt_node->ReadForwardingEntries(req, writer, details);
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(req.device_id()));
+  return tdi_node->ReadForwardingEntries(req, writer, details);
 }
 
-::util::Status BfrtSwitch::RegisterStreamMessageResponseWriter(
+::util::Status TdirtSwitch::RegisterStreamMessageResponseWriter(
     uint64 node_id,
     std::shared_ptr<WriterInterface<::p4::v1::StreamMessageResponse>> writer) {
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(node_id));
-  return bfrt_node->RegisterStreamMessageResponseWriter(writer);
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(node_id));
+  return tdi_node->RegisterStreamMessageResponseWriter(writer);
 }
 
-::util::Status BfrtSwitch::UnregisterStreamMessageResponseWriter(
+::util::Status TdirtSwitch::UnregisterStreamMessageResponseWriter(
     uint64 node_id) {
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(node_id));
-  return bfrt_node->UnregisterStreamMessageResponseWriter();
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(node_id));
+  return tdi_node->UnregisterStreamMessageResponseWriter();
 }
 
-::util::Status BfrtSwitch::HandleStreamMessageRequest(
+::util::Status TdirtSwitch::HandleStreamMessageRequest(
     uint64 node_id, const ::p4::v1::StreamMessageRequest& request) {
-  ASSIGN_OR_RETURN(auto* bfrt_node, GetBfrtNodeFromNodeId(node_id));
-  return bfrt_node->HandleStreamMessageRequest(request);
+  ASSIGN_OR_RETURN(auto* tdi_node, GetTdiNodeFromNodeId(node_id));
+  return tdi_node->HandleStreamMessageRequest(request);
 }
 
-::util::Status BfrtSwitch::RegisterEventNotifyWriter(
+::util::Status TdirtSwitch::RegisterEventNotifyWriter(
     std::shared_ptr<WriterInterface<GnmiEventPtr>> writer) {
-  return bf_chassis_manager_->RegisterEventNotifyWriter(writer);
+  return tdi_chassis_manager_->RegisterEventNotifyWriter(writer);
 }
 
-::util::Status BfrtSwitch::UnregisterEventNotifyWriter() {
-  return bf_chassis_manager_->UnregisterEventNotifyWriter();
+::util::Status TdirtSwitch::UnregisterEventNotifyWriter() {
+  return tdi_chassis_manager_->UnregisterEventNotifyWriter();
 }
 
-::util::Status BfrtSwitch::RetrieveValue(uint64 node_id,
+::util::Status TdirtSwitch::RetrieveValue(uint64 node_id,
                                          const DataRequest& request,
                                          WriterInterface<DataResponse>* writer,
                                          std::vector<::util::Status>* details) {
@@ -211,7 +214,7 @@ BfrtSwitch::~BfrtSwitch() {}
       case DataRequest::Request::kFrontPanelPortInfo:
       case DataRequest::Request::kLoopbackStatus:
       case DataRequest::Request::kSdnPortId: {
-        auto port_data = bf_chassis_manager_->GetPortData(req);
+        auto port_data = tdi_chassis_manager_->GetPortData(req);
         if (!port_data.ok()) {
           status.Update(port_data.status());
         } else {
@@ -221,14 +224,14 @@ BfrtSwitch::~BfrtSwitch() {}
       }
       case DataRequest::Request::kNodeInfo: {
         auto device_id =
-            bf_chassis_manager_->GetUnitFromNodeId(req.node_info().node_id());
+            tdi_chassis_manager_->GetUnitFromNodeId(req.node_info().node_id());
         if (!device_id.ok()) {
           status.Update(device_id.status());
         } else {
           auto* node_info = resp.mutable_node_info();
           node_info->set_vendor_name("Barefoot");
           node_info->set_chip_name(
-              bf_sde_interface_->GetBfChipType(device_id.ValueOrDie()));
+              tdi_sde_interface_->GetBfChipType(device_id.ValueOrDie()));
         }
         break;
       }
@@ -249,47 +252,47 @@ BfrtSwitch::~BfrtSwitch() {}
   return ::util::OkStatus();
 }
 
-::util::Status BfrtSwitch::SetValue(uint64 node_id, const SetRequest& request,
+::util::Status TdirtSwitch::SetValue(uint64 node_id, const SetRequest& request,
                                     std::vector<::util::Status>* details) {
-  LOG(INFO) << "BfrtSwitch::SetValue is not implemented yet, but changes will "
+  LOG(INFO) << "TdirtSwitch::SetValue is not implemented yet, but changes will "
             << "be performed when ChassisConfig is pushed again. "
             << request.ShortDebugString() << ".";
 
   return ::util::OkStatus();
 }
 
-::util::StatusOr<std::vector<std::string>> BfrtSwitch::VerifyState() {
+::util::StatusOr<std::vector<std::string>> TdirtSwitch::VerifyState() {
   return std::vector<std::string>();
 }
 
-std::unique_ptr<BfrtSwitch> BfrtSwitch::CreateInstance(
-    PhalInterface* phal_interface, BfChassisManager* bf_chassis_manager,
-    BfSdeInterface* bf_sde_interface,
-    const std::map<int, BfrtNode*>& device_id_to_bfrt_node) {
-  return absl::WrapUnique(new BfrtSwitch(phal_interface, bf_chassis_manager,
-                                         bf_sde_interface,
-                                         device_id_to_bfrt_node));
+std::unique_ptr<TdirtSwitch> TdirtSwitch::CreateInstance(
+    PhalInterface* phal_interface, TdiChassisManager* tdi_chassis_manager,
+    TdiSdeInterface* tdi_sde_interface,
+    const std::map<int, TdiNode*>& device_id_to_tdi_node) {
+  return absl::WrapUnique(new TdirtSwitch(phal_interface, tdi_chassis_manager,
+                                         tdi_sde_interface,
+                                         device_id_to_tdi_node));
 }
 
-::util::StatusOr<BfrtNode*> BfrtSwitch::GetBfrtNodeFromDeviceId(
+::util::StatusOr<TdiNode*> TdirtSwitch::GetTdiNodeFromDeviceId(
     int device_id) const {
-  BfrtNode* bfrt_node = gtl::FindPtrOrNull(device_id_to_bfrt_node_, device_id);
-  if (bfrt_node == nullptr) {
+  TdiNode* tdi_node = gtl::FindPtrOrNull(device_id_to_tdi_node_, device_id);
+  if (tdi_node == nullptr) {
     return MAKE_ERROR(ERR_INVALID_PARAM)
            << "Unit " << device_id << " is unknown.";
   }
-  return bfrt_node;
+  return tdi_node;
 }
 
-::util::StatusOr<BfrtNode*> BfrtSwitch::GetBfrtNodeFromNodeId(
+::util::StatusOr<TdiNode*> TdirtSwitch::GetTdiNodeFromNodeId(
     uint64 node_id) const {
-  BfrtNode* bfrt_node = gtl::FindPtrOrNull(node_id_to_bfrt_node_, node_id);
-  if (bfrt_node == nullptr) {
+  TdiNode* tdi_node = gtl::FindPtrOrNull(node_id_to_tdi_node_, node_id);
+  if (tdi_node == nullptr) {
     return MAKE_ERROR(ERR_INVALID_PARAM)
            << "Node with ID " << node_id
            << " is unknown or no config has been pushed to it yet.";
   }
-  return bfrt_node;
+  return tdi_node;
 }
 
 }  // namespace barefoot
diff --git a/stratum/hal/lib/barefoot/bfrt_switch.h b/stratum/hal/lib/barefoot/bfrt_switch.h
index a1bc08b8..b8d377c4 100644
--- a/stratum/hal/lib/barefoot/bfrt_switch.h
+++ b/stratum/hal/lib/barefoot/bfrt_switch.h
@@ -10,7 +10,7 @@
 #include <vector>
 
 #include "absl/synchronization/mutex.h"
-#include "stratum/hal/lib/barefoot/bf_chassis_manager.h"
+#include "bfIntf/bf_chassis_manager.h"
 #include "stratum/hal/lib/barefoot/bf_sde_interface.h"
 #include "stratum/hal/lib/barefoot/bfrt_node.h"
 #include "stratum/hal/lib/common/phal_interface.h"
@@ -20,9 +20,9 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class BfrtSwitch : public SwitchInterface {
+class TdirtSwitch : public SwitchInterface {
  public:
-  ~BfrtSwitch() override;
+  ~TdirtSwitch() override;
 
   // SwitchInterface public methods.
   ::util::Status PushChassisConfig(const ChassisConfig& config) override
@@ -75,58 +75,58 @@ class BfrtSwitch : public SwitchInterface {
   ::util::StatusOr<std::vector<std::string>> VerifyState() override;
 
   // Factory function for creating the instance of the class.
-  static std::unique_ptr<BfrtSwitch> CreateInstance(
-      PhalInterface* phal_interface, BfChassisManager* bf_chassis_manager,
-      BfSdeInterface* bf_sde_interface,
-      const std::map<int, BfrtNode*>& device_id_to_bfrt_node);
+  static std::unique_ptr<TdirtSwitch> CreateInstance(
+      PhalInterface* phal_interface, TdiChassisManager* tdi_chassis_manager,
+      TdiSdeInterface* tdi_sde_interface,
+      const std::map<int, TdiNode*>& device_id_to_tdi_node);
 
-  // BfrtSwitch is neither copyable nor movable.
-  BfrtSwitch(const BfrtSwitch&) = delete;
-  BfrtSwitch& operator=(const BfrtSwitch&) = delete;
-  BfrtSwitch(BfrtSwitch&&) = delete;
-  BfrtSwitch& operator=(BfrtSwitch&&) = delete;
+  // TdirtSwitch is neither copyable nor movable.
+  TdirtSwitch(const TdirtSwitch&) = delete;
+  TdirtSwitch& operator=(const TdirtSwitch&) = delete;
+  TdirtSwitch(TdirtSwitch&&) = delete;
+  TdirtSwitch& operator=(TdirtSwitch&&) = delete;
 
  private:
   // Private constructor. Use CreateInstance() to create an instance of this
   // class.
-  BfrtSwitch(PhalInterface* phal_interface,
-             BfChassisManager* bf_chassis_manager,
-             BfSdeInterface* bf_sde_interface,
-             const std::map<int, BfrtNode*>& device_id_to_bfrt_node);
+  TdirtSwitch(PhalInterface* phal_interface,
+             TdiChassisManager* tdi_chassis_manager,
+             TdiSdeInterface* tdi_sde_interface,
+             const std::map<int, TdiNode*>& device_id_to_tdi_node);
 
-  // Helper to get BfrtNode pointer from device_id number or return error
+  // Helper to get TdiNode pointer from device_id number or return error
   // indicating invalid device_id.
-  ::util::StatusOr<BfrtNode*> GetBfrtNodeFromDeviceId(int device_id) const;
+  ::util::StatusOr<TdiNode*> GetTdiNodeFromDeviceId(int device_id) const;
 
-  // Helper to get BfrtNode pointer from node id or return error indicating
+  // Helper to get TdiNode pointer from node id or return error indicating
   // invalid/unknown/uninitialized node.
-  ::util::StatusOr<BfrtNode*> GetBfrtNodeFromNodeId(uint64 node_id) const;
+  ::util::StatusOr<TdiNode*> GetTdiNodeFromNodeId(uint64 node_id) const;
 
   // Pointer to a PhalInterface implementation. The pointer has been also
   // passed to a few managers for accessing HW. Note that there is only one
   // instance of this class per chassis.
   PhalInterface* phal_interface_;  // not owned by this class.
 
-  // Pointer to a BfSdeInterface implementation that wraps PD API calls.
-  BfSdeInterface* bf_sde_interface_;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps PD API calls.
+  TdiSdeInterface* tdi_sde_interface_;  // not owned by this class.
 
   // Per chassis Managers. Note that there is only one instance of this class
   // per chassis.
-  BfChassisManager* bf_chassis_manager_;  // not owned by the class.
+  TdiChassisManager* tdi_chassis_manager_;  // not owned by the class.
 
   // Map from zero-based device_id number corresponding to a node/ASIC to a
-  // pointer to BfrtNode which contain all the per-node managers for that
+  // pointer to TdiNode which contain all the per-node managers for that
   // node/ASIC. This map is initialized in the constructor and will not change
   // during the lifetime of the class.
   // TODO(max): Does this need to be protected by chassis_lock?
-  const std::map<int, BfrtNode*> device_id_to_bfrt_node_;  // pointers not owned
+  const std::map<int, TdiNode*> device_id_to_tdi_node_;  // pointers not owned
 
-  // Map from the node ids to to a pointer to BfrtNode which contain all the
+  // Map from the node ids to to a pointer to TdiNode which contain all the
   // per-node managers for that node/ASIC. Created everytime a config is pushed.
   // At any point of time this map will contain a keys the ids of the nodes
   // which had a successful config push.
   // TODO(max): Does this need to be protected by chassis_lock?
-  std::map<uint64, BfrtNode*> node_id_to_bfrt_node_;  //  pointers not owned
+  std::map<uint64, TdiNode*> node_id_to_tdi_node_;  //  pointers not owned
 };
 
 }  // namespace barefoot
diff --git a/stratum/hal/lib/barefoot/bfrt_table_manager.cc b/stratum/hal/lib/barefoot/bfrt_table_manager.cc
index 34bd7fa1..eb8101af 100644
--- a/stratum/hal/lib/barefoot/bfrt_table_manager.cc
+++ b/stratum/hal/lib/barefoot/bfrt_table_manager.cc
@@ -20,7 +20,7 @@
 #include "stratum/lib/utils.h"
 
 DEFINE_uint32(
-    bfrt_table_sync_timeout_ms,
+    tdirt_table_sync_timeout_ms,
     stratum::hal::barefoot::kDefaultSyncTimeout / absl::Milliseconds(1),
     "The timeout for table sync operation like counters and registers.");
 DEFINE_bool(incompatible_enable_register_reset_annotations, false,
@@ -30,21 +30,21 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-BfrtTableManager::BfrtTableManager(OperationMode mode,
-                                   BfSdeInterface* bf_sde_interface, int device)
+TdiTableManager::TdiTableManager(OperationMode mode,
+                                   TdiSdeInterface* tdi_sde_interface, int device)
     : mode_(mode),
       register_timer_descriptors_(),
-      bf_sde_interface_(ABSL_DIE_IF_NULL(bf_sde_interface)),
+      tdi_sde_interface_(ABSL_DIE_IF_NULL(tdi_sde_interface)),
       p4_info_manager_(nullptr),
       device_(device) {}
 
-std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
-    OperationMode mode, BfSdeInterface* bf_sde_interface, int device) {
-  return absl::WrapUnique(new BfrtTableManager(mode, bf_sde_interface, device));
+std::unique_ptr<TdiTableManager> TdiTableManager::CreateInstance(
+    OperationMode mode, TdiSdeInterface* tdi_sde_interface, int device) {
+  return absl::WrapUnique(new TdiTableManager(mode, tdi_sde_interface, device));
 }
 
-::util::Status BfrtTableManager::PushForwardingPipelineConfig(
-    const BfrtDeviceConfig& config) {
+::util::Status TdiTableManager::PushForwardingPipelineConfig(
+    const TdirtDeviceConfig& config) {
   absl::WriterMutexLock l(&lock_);
   CHECK_RETURN_IF_FALSE(config.programs_size() == 1)
       << "Only one P4 program is supported.";
@@ -60,13 +60,13 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::VerifyForwardingPipelineConfig(
+::util::Status TdiTableManager::VerifyForwardingPipelineConfig(
     const ::p4::v1::ForwardingPipelineConfig& config) const {
   // TODO(unknown): Implement if needed.
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::SetupRegisterReset(
+::util::Status TdiTableManager::SetupRegisterReset(
     const ::p4::config::v1::P4Info& p4_info) {
   if (!FLAGS_incompatible_enable_register_reset_annotations) {
     return ::util::OkStatus();
@@ -110,7 +110,7 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
       0, intervals_ms[0],
       [this, p4_info]() -> ::util::Status {
         auto t1 = absl::Now();
-        ASSIGN_OR_RETURN(auto session, bf_sde_interface_->CreateSession());
+        ASSIGN_OR_RETURN(auto session, tdi_sde_interface_->CreateSession());
         RETURN_IF_ERROR(session->BeginBatch());
         ::util::Status status = ::util::OkStatus();
         for (const auto& reg : p4_info.registers()) {
@@ -148,9 +148,9 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::BuildTableKey(
+::util::Status TdiTableManager::BuildTableKey(
     const ::p4::v1::TableEntry& table_entry,
-    BfSdeInterface::TableKeyInterface* table_key) {
+    TdiSdeInterface::TableKeyInterface* table_key) {
   CHECK_RETURN_IF_FALSE(table_key);
   bool needs_priority = false;
   ASSIGN_OR_RETURN(auto table,
@@ -258,9 +258,9 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::BuildTableActionData(
+::util::Status TdiTableManager::BuildTableActionData(
     const ::p4::v1::Action& action,
-    BfSdeInterface::TableDataInterface* table_data) {
+    TdiSdeInterface::TableDataInterface* table_data) {
   RETURN_IF_ERROR(table_data->Reset(action.action_id()));
   for (const auto& param : action.params()) {
     RETURN_IF_ERROR(table_data->SetParam(param.param_id(), param.value()));
@@ -268,9 +268,9 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::BuildTableData(
+::util::Status TdiTableManager::BuildTableData(
     const ::p4::v1::TableEntry& table_entry,
-    BfSdeInterface::TableDataInterface* table_data) {
+    TdiSdeInterface::TableDataInterface* table_data) {
   switch (table_entry.action().type_case()) {
     case ::p4::v1::TableAction::kAction:
       RETURN_IF_ERROR(
@@ -299,8 +299,8 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::WriteTableEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::WriteTableEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type,
     const ::p4::v1::TableEntry& table_entry) {
   CHECK_RETURN_IF_FALSE(type != ::p4::v1::Update::UNSPECIFIED)
@@ -310,7 +310,7 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   ASSIGN_OR_RETURN(auto table,
                    p4_info_manager_->FindTableByID(table_entry.table_id()));
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(table_entry.table_id()));
+                   tdi_sde_interface_->GetTdiRtId(table_entry.table_id()));
 
   if (!table_entry.is_default_action()) {
     if (table.is_const_table()) {
@@ -319,11 +319,11 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
           << " because it has const entries.";
     }
     ASSIGN_OR_RETURN(auto table_key,
-                     bf_sde_interface_->CreateTableKey(table_id));
+                     tdi_sde_interface_->CreateTableKey(table_id));
     RETURN_IF_ERROR(BuildTableKey(table_entry, table_key.get()));
 
     ASSIGN_OR_RETURN(auto table_data,
-                     bf_sde_interface_->CreateTableData(
+                     tdi_sde_interface_->CreateTableData(
                          table_id, table_entry.action().action().action_id()));
     if (type == ::p4::v1::Update::INSERT || type == ::p4::v1::Update::MODIFY) {
       RETURN_IF_ERROR(BuildTableData(table_entry, table_data.get()));
@@ -331,15 +331,15 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
 
     switch (type) {
       case ::p4::v1::Update::INSERT:
-        RETURN_IF_ERROR(bf_sde_interface_->InsertTableEntry(
+        RETURN_IF_ERROR(tdi_sde_interface_->InsertTableEntry(
             device_, session, table_id, table_key.get(), table_data.get()));
         break;
       case ::p4::v1::Update::MODIFY:
-        RETURN_IF_ERROR(bf_sde_interface_->ModifyTableEntry(
+        RETURN_IF_ERROR(tdi_sde_interface_->ModifyTableEntry(
             device_, session, table_id, table_key.get(), table_data.get()));
         break;
       case ::p4::v1::Update::DELETE:
-        RETURN_IF_ERROR(bf_sde_interface_->DeleteTableEntry(
+        RETURN_IF_ERROR(tdi_sde_interface_->DeleteTableEntry(
             device_, session, table_id, table_key.get()));
         break;
       default:
@@ -358,13 +358,13 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
     if (table_entry.has_action()) {
       ASSIGN_OR_RETURN(
           auto table_data,
-          bf_sde_interface_->CreateTableData(
+          tdi_sde_interface_->CreateTableData(
               table_id, table_entry.action().action().action_id()));
       RETURN_IF_ERROR(BuildTableData(table_entry, table_data.get()));
-      RETURN_IF_ERROR(bf_sde_interface_->SetDefaultTableEntry(
+      RETURN_IF_ERROR(tdi_sde_interface_->SetDefaultTableEntry(
           device_, session, table_id, table_data.get()));
     } else {
-      RETURN_IF_ERROR(bf_sde_interface_->ResetDefaultTableEntry(
+      RETURN_IF_ERROR(tdi_sde_interface_->ResetDefaultTableEntry(
           device_, session, table_id));
     }
   }
@@ -374,10 +374,10 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
 
 // TODO(max): the need for the original request might go away when the table
 // data is correctly initialized with only the fields we care about.
-::util::StatusOr<::p4::v1::TableEntry> BfrtTableManager::BuildP4TableEntry(
+::util::StatusOr<::p4::v1::TableEntry> TdiTableManager::BuildP4TableEntry(
     const ::p4::v1::TableEntry& request,
-    const BfSdeInterface::TableKeyInterface* table_key,
-    const BfSdeInterface::TableDataInterface* table_data) {
+    const TdiSdeInterface::TableKeyInterface* table_key,
+    const TdiSdeInterface::TableDataInterface* table_data) {
   ::p4::v1::TableEntry result;
 
   ASSIGN_OR_RETURN(auto table,
@@ -497,18 +497,18 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return result;
 }
 
-::util::Status BfrtTableManager::ReadSingleTableEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::ReadSingleTableEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::TableEntry& table_entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(table_entry.table_id()));
-  ASSIGN_OR_RETURN(auto table_key, bf_sde_interface_->CreateTableKey(table_id));
+                   tdi_sde_interface_->GetTdiRtId(table_entry.table_id()));
+  ASSIGN_OR_RETURN(auto table_key, tdi_sde_interface_->CreateTableKey(table_id));
   ASSIGN_OR_RETURN(auto table_data,
-                   bf_sde_interface_->CreateTableData(
+                   tdi_sde_interface_->CreateTableData(
                        table_id, table_entry.action().action().action_id()));
   RETURN_IF_ERROR(BuildTableKey(table_entry, table_key.get()));
-  RETURN_IF_ERROR(bf_sde_interface_->GetTableEntry(
+  RETURN_IF_ERROR(tdi_sde_interface_->GetTableEntry(
       device_, session, table_id, table_key.get(), table_data.get()));
   ASSIGN_OR_RETURN(
       ::p4::v1::TableEntry result,
@@ -523,8 +523,8 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::ReadDefaultTableEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::ReadDefaultTableEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::TableEntry& table_entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   CHECK_RETURN_IF_FALSE(table_entry.table_id())
@@ -532,12 +532,12 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
       << table_entry.ShortDebugString() << ".";
 
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(table_entry.table_id()));
-  ASSIGN_OR_RETURN(auto table_key, bf_sde_interface_->CreateTableKey(table_id));
+                   tdi_sde_interface_->GetTdiRtId(table_entry.table_id()));
+  ASSIGN_OR_RETURN(auto table_key, tdi_sde_interface_->CreateTableKey(table_id));
   ASSIGN_OR_RETURN(auto table_data,
-                   bf_sde_interface_->CreateTableData(
+                   tdi_sde_interface_->CreateTableData(
                        table_id, table_entry.action().action().action_id()));
-  RETURN_IF_ERROR(bf_sde_interface_->GetDefaultTableEntry(
+  RETURN_IF_ERROR(tdi_sde_interface_->GetDefaultTableEntry(
       device_, session, table_id, table_data.get()));
   // FIXME: BuildP4TableEntry is not suitable for default entries.
   ASSIGN_OR_RETURN(
@@ -556,8 +556,8 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::ReadAllTableEntries(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::ReadAllTableEntries(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::TableEntry& table_entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   CHECK_RETURN_IF_FALSE(table_entry.match_size() == 0)
@@ -572,16 +572,16 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
       << "Default action filters on wildcard reads are not supported.";
 
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(table_entry.table_id()));
-  std::vector<std::unique_ptr<BfSdeInterface::TableKeyInterface>> keys;
-  std::vector<std::unique_ptr<BfSdeInterface::TableDataInterface>> datas;
-  RETURN_IF_ERROR(bf_sde_interface_->GetAllTableEntries(
+                   tdi_sde_interface_->GetTdiRtId(table_entry.table_id()));
+  std::vector<std::unique_ptr<TdiSdeInterface::TableKeyInterface>> keys;
+  std::vector<std::unique_ptr<TdiSdeInterface::TableDataInterface>> datas;
+  RETURN_IF_ERROR(tdi_sde_interface_->GetAllTableEntries(
       device_, session, table_id, &keys, &datas));
   ::p4::v1::ReadResponse resp;
   for (size_t i = 0; i < keys.size(); ++i) {
-    const std::unique_ptr<BfSdeInterface::TableKeyInterface>& table_key =
+    const std::unique_ptr<TdiSdeInterface::TableKeyInterface>& table_key =
         keys[i];
-    const std::unique_ptr<BfSdeInterface::TableDataInterface>& table_data =
+    const std::unique_ptr<TdiSdeInterface::TableDataInterface>& table_data =
         datas[i];
     ASSIGN_OR_RETURN(
         auto result,
@@ -597,8 +597,8 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::ReadTableEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::ReadTableEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::TableEntry& table_entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   CHECK_RETURN_IF_FALSE(writer) << "Null writer.";
@@ -630,9 +630,9 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
     // TODO(max): can wildcard reads request counter_data?
     if (table_entry.has_counter_data()) {
       for (const auto& wanted_table_entry : wanted_tables) {
-        RETURN_IF_ERROR(bf_sde_interface_->SynchronizeCounters(
+        RETURN_IF_ERROR(tdi_sde_interface_->SynchronizeCounters(
             device_, session, wanted_table_entry.table_id(),
-            absl::Milliseconds(FLAGS_bfrt_table_sync_timeout_ms)));
+            absl::Milliseconds(FLAGS_tdirt_table_sync_timeout_ms)));
       }
     }
     for (const auto& wanted_table_entry : wanted_tables) {
@@ -649,9 +649,9 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   } else {
     // 4.
     if (table_entry.has_counter_data()) {
-      RETURN_IF_ERROR(bf_sde_interface_->SynchronizeCounters(
+      RETURN_IF_ERROR(tdi_sde_interface_->SynchronizeCounters(
           device_, session, table_entry.table_id(),
-          absl::Milliseconds(FLAGS_bfrt_table_sync_timeout_ms)));
+          absl::Milliseconds(FLAGS_tdirt_table_sync_timeout_ms)));
     }
     return ReadSingleTableEntry(session, table_entry, writer);
   }
@@ -660,8 +660,8 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
 }
 
 // Modify the counter data of a table entry.
-::util::Status BfrtTableManager::WriteDirectCounterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::WriteDirectCounterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type,
     const ::p4::v1::DirectCounterEntry& direct_counter_entry) {
   CHECK_RETURN_IF_FALSE(type == ::p4::v1::Update::MODIFY)
@@ -674,10 +674,10 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
       << "Found action on DirectCounterEntry "
       << direct_counter_entry.ShortDebugString();
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(table_entry.table_id()));
-  ASSIGN_OR_RETURN(auto table_key, bf_sde_interface_->CreateTableKey(table_id));
+                   tdi_sde_interface_->GetTdiRtId(table_entry.table_id()));
+  ASSIGN_OR_RETURN(auto table_key, tdi_sde_interface_->CreateTableKey(table_id));
   ASSIGN_OR_RETURN(auto table_data,
-                   bf_sde_interface_->CreateTableData(
+                   tdi_sde_interface_->CreateTableData(
                        table_id, table_entry.action().action().action_id()));
 
   absl::ReaderMutexLock l(&lock_);
@@ -687,7 +687,7 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
   // request does not provide the action ID and data, but we have to provide the
   // current values in the later modify call to the SDE, else we would modify
   // the table entry.
-  RETURN_IF_ERROR(bf_sde_interface_->GetTableEntry(
+  RETURN_IF_ERROR(tdi_sde_interface_->GetTableEntry(
       device_, session, table_id, table_key.get(), table_data.get()));
 
   // P4RT spec requires that the referenced table entry must exist. Therefore we
@@ -701,7 +701,7 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
       table_data->SetCounterData(direct_counter_entry.data().byte_count(),
                                  direct_counter_entry.data().packet_count()));
 
-  RETURN_IF_ERROR(bf_sde_interface_->ModifyTableEntry(
+  RETURN_IF_ERROR(tdi_sde_interface_->ModifyTableEntry(
       device_, session, table_id, table_key.get(), table_data.get()));
 
   return ::util::OkStatus();
@@ -709,8 +709,8 @@ std::unique_ptr<BfrtTableManager> BfrtTableManager::CreateInstance(
 
 // Read the counter data of a table entry.
 ::util::StatusOr<::p4::v1::DirectCounterEntry>
-BfrtTableManager::ReadDirectCounterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+TdiTableManager::ReadDirectCounterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::DirectCounterEntry& direct_counter_entry) {
   const auto& table_entry = direct_counter_entry.table_entry();
   CHECK_RETURN_IF_FALSE(table_entry.action().action().action_id() == 0)
@@ -718,10 +718,10 @@ BfrtTableManager::ReadDirectCounterEntry(
       << direct_counter_entry.ShortDebugString();
 
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(table_entry.table_id()));
-  ASSIGN_OR_RETURN(auto table_key, bf_sde_interface_->CreateTableKey(table_id));
+                   tdi_sde_interface_->GetTdiRtId(table_entry.table_id()));
+  ASSIGN_OR_RETURN(auto table_key, tdi_sde_interface_->CreateTableKey(table_id));
   ASSIGN_OR_RETURN(auto table_data,
-                   bf_sde_interface_->CreateTableData(
+                   tdi_sde_interface_->CreateTableData(
                        table_id, table_entry.action().action().action_id()));
 
   {
@@ -730,11 +730,11 @@ BfrtTableManager::ReadDirectCounterEntry(
   }
 
   // Sync table counters.
-  RETURN_IF_ERROR(bf_sde_interface_->SynchronizeCounters(
+  RETURN_IF_ERROR(tdi_sde_interface_->SynchronizeCounters(
       device_, session, table_id,
-      absl::Milliseconds(FLAGS_bfrt_table_sync_timeout_ms)));
+      absl::Milliseconds(FLAGS_tdirt_table_sync_timeout_ms)));
 
-  RETURN_IF_ERROR(bf_sde_interface_->GetTableEntry(
+  RETURN_IF_ERROR(tdi_sde_interface_->GetTableEntry(
       device_, session, table_id, table_key.get(), table_data.get()));
 
   // TODO(max): build response entry from returned data
@@ -749,8 +749,8 @@ BfrtTableManager::ReadDirectCounterEntry(
   return result;
 }
 
-::util::Status BfrtTableManager::ReadRegisterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::ReadRegisterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::RegisterEntry& register_entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   {
@@ -764,13 +764,13 @@ BfrtTableManager::ReadDirectCounterEntry(
     optional_register_index = register_entry.index().index();
   }
 
-  // TODO(max): we don't translate p4rt id to bfrt here?
+  // TODO(max): we don't translate p4rt id to tdirt here?
   std::vector<uint32> register_indices;
   std::vector<uint64> register_datas;
-  RETURN_IF_ERROR(bf_sde_interface_->ReadRegisters(
+  RETURN_IF_ERROR(tdi_sde_interface_->ReadRegisters(
       device_, session, register_entry.register_id(), optional_register_index,
       &register_indices, &register_datas,
-      absl::Milliseconds(FLAGS_bfrt_table_sync_timeout_ms)));
+      absl::Milliseconds(FLAGS_tdirt_table_sync_timeout_ms)));
 
   ::p4::v1::ReadResponse resp;
   for (size_t i = 0; i < register_indices.size(); ++i) {
@@ -800,8 +800,8 @@ BfrtTableManager::ReadDirectCounterEntry(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::WriteRegisterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::WriteRegisterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type,
     const ::p4::v1::RegisterEntry& register_entry) {
   CHECK_RETURN_IF_FALSE(type == ::p4::v1::Update::MODIFY)
@@ -815,27 +815,27 @@ BfrtTableManager::ReadDirectCounterEntry(
       << "Only bitstring registers data types are supported.";
 
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(register_entry.register_id()));
+                   tdi_sde_interface_->GetTdiRtId(register_entry.register_id()));
 
   absl::optional<uint32> register_index;
   if (register_entry.has_index()) {
     register_index = register_entry.index().index();
   }
-  RETURN_IF_ERROR(bf_sde_interface_->WriteRegister(
+  RETURN_IF_ERROR(tdi_sde_interface_->WriteRegister(
       device_, session, table_id, register_index,
       register_entry.data().bitstring()));
 
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::ReadMeterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::ReadMeterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::MeterEntry& meter_entry,
     WriterInterface<::p4::v1::ReadResponse>* writer) {
   CHECK_RETURN_IF_FALSE(meter_entry.meter_id() != 0)
       << "Wildcard MeterEntry reads are not supported.";
   ASSIGN_OR_RETURN(uint32 table_id,
-                   bf_sde_interface_->GetBfRtId(meter_entry.meter_id()));
+                   tdi_sde_interface_->GetTdiRtId(meter_entry.meter_id()));
   bool meter_units_in_bits;  // or packets
   {
     absl::ReaderMutexLock l(&lock_);
@@ -865,7 +865,7 @@ BfrtTableManager::ReadDirectCounterEntry(
   std::vector<uint64> pirs;
   std::vector<uint64> pbursts;
   std::vector<bool> in_pps;
-  RETURN_IF_ERROR(bf_sde_interface_->ReadIndirectMeters(
+  RETURN_IF_ERROR(tdi_sde_interface_->ReadIndirectMeters(
       device_, session, table_id, optional_meter_index, &meter_indices, &cirs,
       &cbursts, &pirs, &pbursts, &in_pps));
 
@@ -890,8 +890,8 @@ BfrtTableManager::ReadDirectCounterEntry(
   return ::util::OkStatus();
 }
 
-::util::Status BfrtTableManager::WriteMeterEntry(
-    std::shared_ptr<BfSdeInterface::SessionInterface> session,
+::util::Status TdiTableManager::WriteMeterEntry(
+    std::shared_ptr<TdiSdeInterface::SessionInterface> session,
     const ::p4::v1::Update::Type type,
     const ::p4::v1::MeterEntry& meter_entry) {
   CHECK_RETURN_IF_FALSE(type == ::p4::v1::Update::MODIFY)
@@ -920,13 +920,13 @@ BfrtTableManager::ReadDirectCounterEntry(
   }
 
   ASSIGN_OR_RETURN(uint32 meter_id,
-                   bf_sde_interface_->GetBfRtId(meter_entry.meter_id()));
+                   tdi_sde_interface_->GetTdiRtId(meter_entry.meter_id()));
 
   absl::optional<uint32> meter_index;
   if (meter_entry.has_index()) {
     meter_index = meter_entry.index().index();
   }
-  RETURN_IF_ERROR(bf_sde_interface_->WriteIndirectMeter(
+  RETURN_IF_ERROR(tdi_sde_interface_->WriteIndirectMeter(
       device_, session, meter_id, meter_index, meter_units_in_packets,
       meter_entry.config().cir(), meter_entry.config().cburst(),
       meter_entry.config().pir(), meter_entry.config().pburst()));
diff --git a/stratum/hal/lib/barefoot/bfrt_table_manager.h b/stratum/hal/lib/barefoot/bfrt_table_manager.h
index 06f38acc..b731b750 100644
--- a/stratum/hal/lib/barefoot/bfrt_table_manager.h
+++ b/stratum/hal/lib/barefoot/bfrt_table_manager.h
@@ -24,10 +24,10 @@ namespace stratum {
 namespace hal {
 namespace barefoot {
 
-class BfrtTableManager {
+class TdiTableManager {
  public:
   // Pushes the pipline info.
-  ::util::Status PushForwardingPipelineConfig(const BfrtDeviceConfig& config)
+  ::util::Status PushForwardingPipelineConfig(const TdirtDeviceConfig& config)
       LOCKS_EXCLUDED(lock_);
 
   // Verifies a P4-based forwarding pipeline configuration intended for this
@@ -38,90 +38,90 @@ class BfrtTableManager {
 
   // Writes a table entry.
   ::util::Status WriteTableEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::TableEntry& table_entry) LOCKS_EXCLUDED(lock_);
 
   // Reads the P4 TableEntry(s) matched by the given table entry.
   ::util::Status ReadTableEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::TableEntry& table_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer) LOCKS_EXCLUDED(lock_);
 
   // Modify the counter data of a table entry.
   ::util::Status WriteDirectCounterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::DirectCounterEntry& direct_counter_entry)
       LOCKS_EXCLUDED(lock_);
 
   // Modify the data of a register entry.
   ::util::Status WriteRegisterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::RegisterEntry& register_entry) LOCKS_EXCLUDED(lock_);
 
   // Modify the data of a meter entry.
   ::util::Status WriteMeterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::Update::Type type,
       const ::p4::v1::MeterEntry& meter_entry) LOCKS_EXCLUDED(lock_);
 
   // Read the counter data of a table entry.
   ::util::StatusOr<::p4::v1::DirectCounterEntry> ReadDirectCounterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::DirectCounterEntry& direct_counter_entry)
       LOCKS_EXCLUDED(lock_);
 
   // Read the data of a register entry.
   ::util::Status ReadRegisterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::RegisterEntry& register_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer) LOCKS_EXCLUDED(lock_);
 
   // Read the data of a meter entry.
   ::util::Status ReadMeterEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::MeterEntry& meter_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer) LOCKS_EXCLUDED(lock_);
 
   // Creates a table manager instance.
-  static std::unique_ptr<BfrtTableManager> CreateInstance(
-      OperationMode mode, BfSdeInterface* bf_sde_interface, int device);
+  static std::unique_ptr<TdiTableManager> CreateInstance(
+      OperationMode mode, TdiSdeInterface* tdi_sde_interface, int device);
 
  private:
   // Private constructor, we can create the instance by using `CreateInstance`
   // function only.
-  explicit BfrtTableManager(OperationMode mode,
-                            BfSdeInterface* bf_sde_interface, int device);
+  explicit TdiTableManager(OperationMode mode,
+                            TdiSdeInterface* tdi_sde_interface, int device);
 
   ::util::Status BuildTableKey(const ::p4::v1::TableEntry& table_entry,
-                               BfSdeInterface::TableKeyInterface* table_key)
+                               TdiSdeInterface::TableKeyInterface* table_key)
       SHARED_LOCKS_REQUIRED(lock_);
 
   ::util::Status BuildTableActionData(
       const ::p4::v1::Action& action,
-      BfSdeInterface::TableDataInterface* table_data);
+      TdiSdeInterface::TableDataInterface* table_data);
 
   // Builds a SDE table data from the given P4 table entry. The table data
   // object is reset, even in case of failure.
   ::util::Status BuildTableData(const ::p4::v1::TableEntry& table_entry,
-                                BfSdeInterface::TableDataInterface* table_data);
+                                TdiSdeInterface::TableDataInterface* table_data);
 
   ::util::Status ReadSingleTableEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::TableEntry& table_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer)
       SHARED_LOCKS_REQUIRED(lock_);
 
   ::util::Status ReadDefaultTableEntry(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::TableEntry& table_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer)
       SHARED_LOCKS_REQUIRED(lock_);
 
   ::util::Status ReadAllTableEntries(
-      std::shared_ptr<BfSdeInterface::SessionInterface> session,
+      std::shared_ptr<TdiSdeInterface::SessionInterface> session,
       const ::p4::v1::TableEntry& table_entry,
       WriterInterface<::p4::v1::ReadResponse>* writer)
       SHARED_LOCKS_REQUIRED(lock_);
@@ -130,8 +130,8 @@ class BfrtTableManager {
   // table data.
   ::util::StatusOr<::p4::v1::TableEntry> BuildP4TableEntry(
       const ::p4::v1::TableEntry& request,
-      const BfSdeInterface::TableKeyInterface* table_key,
-      const BfSdeInterface::TableDataInterface* table_data)
+      const TdiSdeInterface::TableKeyInterface* table_key,
+      const TdiSdeInterface::TableDataInterface* table_data)
       SHARED_LOCKS_REQUIRED(lock_);
 
   ::util::Status SetupRegisterReset(const ::p4::config::v1::P4Info& p4_info)
@@ -153,8 +153,8 @@ class BfrtTableManager {
   std::vector<TimerDaemon::DescriptorPtr> register_timer_descriptors_
       GUARDED_BY(lock_);
 
-  // Pointer to a BfSdeInterface implementation that wraps all the SDE calls.
-  BfSdeInterface* bf_sde_interface_ = nullptr;  // not owned by this class.
+  // Pointer to a TdiSdeInterface implementation that wraps all the SDE calls.
+  TdiSdeInterface* tdi_sde_interface_ = nullptr;  // not owned by this class.
 
   // Helper class to validate the P4Info and requests against it.
   // TODO(max): Maybe this manager should be created in the node and passed down
@@ -165,7 +165,7 @@ class BfrtTableManager {
   // managed by this class instance. Assigned in the class constructor.
   const int device_;
 
-  friend class BfrtTableManagerTest;
+  friend class TdiTableManagerTest;
 };
 
 }  // namespace barefoot
diff --git a/stratum/hal/lib/barefoot/bfrt_table_manager_test.cc b/stratum/hal/lib/barefoot/bfrt_table_manager_test.cc
index 8f62a2f7..701625a1 100644
--- a/stratum/hal/lib/barefoot/bfrt_table_manager_test.cc
+++ b/stratum/hal/lib/barefoot/bfrt_table_manager_test.cc
@@ -16,7 +16,7 @@
 #include "stratum/lib/utils.h"
 
 // FIXME
-DEFINE_string(bfrt_sde_config_dir, "/var/run/stratum/bfrt_config",
+DEFINE_string(tdirt_sde_config_dir, "/var/run/stratum/tdirt_config",
               "The dir used by the SDE to load the device configuration.");
 
 namespace stratum {
@@ -34,12 +34,12 @@ using ::testing::Optional;
 using ::testing::Return;
 using ::testing::SetArgPointee;
 
-class BfrtTableManagerTest : public ::testing::Test {
+class TdiTableManagerTest : public ::testing::Test {
  protected:
   void SetUp() override {
-    bf_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
-    bfrt_table_manager_ = BfrtTableManager::CreateInstance(
-        OPERATION_MODE_STANDALONE, bf_sde_wrapper_mock_.get(), kDevice1);
+    tdi_sde_wrapper_mock_ = absl::make_unique<BfSdeMock>();
+    tdi_table_manager_ = TdiTableManager::CreateInstance(
+        OPERATION_MODE_STANDALONE, tdi_sde_wrapper_mock_.get(), kDevice1);
   }
 
   ::util::Status PushTestConfig() {
@@ -122,21 +122,21 @@ class BfrtTableManagerTest : public ::testing::Test {
     )PROTO";
     BfrtDeviceConfig config;
     RETURN_IF_ERROR(ParseProtoFromString(kSamplePipelineText, &config));
-    return bfrt_table_manager_->PushForwardingPipelineConfig(config);
+    return tdi_table_manager_->PushForwardingPipelineConfig(config);
   }
 
   static constexpr int kDevice1 = 0;
 
-  std::unique_ptr<BfSdeMock> bf_sde_wrapper_mock_;
-  std::unique_ptr<BfrtTableManager> bfrt_table_manager_;
+  std::unique_ptr<BfSdeMock> tdi_sde_wrapper_mock_;
+  std::unique_ptr<TdiTableManager> tdi_table_manager_;
 };
 
-constexpr int BfrtTableManagerTest::kDevice1;
+constexpr int TdiTableManagerTest::kDevice1;
 
-TEST_F(BfrtTableManagerTest, WriteDirectCounterEntryTest) {
+TEST_F(TdiTableManagerTest, WriteDirectCounterEntryTest) {
   ASSERT_OK(PushTestConfig());
   constexpr int kP4TableId = 33583783;
-  constexpr int kBfRtTableId = 20;
+  constexpr int kTdiRtTableId = 20;
   constexpr int kBfrtPriority = 16777205;  // Inverted
   auto table_key_mock = absl::make_unique<TableKeyMock>();
   auto table_data_mock = absl::make_unique<TableDataMock>();
@@ -146,20 +146,20 @@ TEST_F(BfrtTableManagerTest, WriteDirectCounterEntryTest) {
       .WillOnce(Return(::util::OkStatus()));
   EXPECT_CALL(*table_data_mock, SetCounterData(200, 100))
       .WillOnce(Return(::util::OkStatus()));
-  EXPECT_CALL(*bf_sde_wrapper_mock_, GetBfRtId(kP4TableId))
-      .WillOnce(Return(kBfRtTableId));
+  EXPECT_CALL(*tdi_sde_wrapper_mock_, GetTdiRtId(kP4TableId))
+      .WillOnce(Return(kTdiRtTableId));
   // TODO(max): figure out how to expect the session mock here.
-  EXPECT_CALL(*bf_sde_wrapper_mock_,
-              ModifyTableEntry(kDevice1, _, kBfRtTableId, table_key_mock.get(),
+  EXPECT_CALL(*tdi_sde_wrapper_mock_,
+              ModifyTableEntry(kDevice1, _, kTdiRtTableId, table_key_mock.get(),
                                table_data_mock.get()))
       .WillOnce(Return(::util::OkStatus()));
-  EXPECT_CALL(*bf_sde_wrapper_mock_, CreateTableKey(kBfRtTableId))
+  EXPECT_CALL(*tdi_sde_wrapper_mock_, CreateTableKey(kTdiRtTableId))
       .WillOnce(Return(ByMove(
-          ::util::StatusOr<std::unique_ptr<BfSdeInterface::TableKeyInterface>>(
+          ::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableKeyInterface>>(
               std::move(table_key_mock)))));
-  EXPECT_CALL(*bf_sde_wrapper_mock_, CreateTableData(kBfRtTableId, _))
+  EXPECT_CALL(*tdi_sde_wrapper_mock_, CreateTableData(kTdiRtTableId, _))
       .WillOnce(Return(ByMove(
-          ::util::StatusOr<std::unique_ptr<BfSdeInterface::TableDataInterface>>(
+          ::util::StatusOr<std::unique_ptr<TdiSdeInterface::TableDataInterface>>(
               std::move(table_data_mock)))));
 
   const std::string kDirectCounterEntryText = R"PROTO(
@@ -184,22 +184,22 @@ TEST_F(BfrtTableManagerTest, WriteDirectCounterEntryTest) {
   ::p4::v1::DirectCounterEntry entry;
   ASSERT_OK(ParseProtoFromString(kDirectCounterEntryText, &entry));
 
-  EXPECT_OK(bfrt_table_manager_->WriteDirectCounterEntry(
+  EXPECT_OK(tdi_table_manager_->WriteDirectCounterEntry(
       session_mock, ::p4::v1::Update::MODIFY, entry));
 }
 
-TEST_F(BfrtTableManagerTest, WriteIndirectMeterEntryTest) {
+TEST_F(TdiTableManagerTest, WriteIndirectMeterEntryTest) {
   ASSERT_OK(PushTestConfig());
   constexpr int kP4MeterId = 55555;
-  constexpr int kBfRtTableId = 11111;
+  constexpr int kTdiRtTableId = 11111;
   constexpr int kMeterIndex = 12345;
   auto session_mock = std::make_shared<SessionMock>();
 
-  EXPECT_CALL(*bf_sde_wrapper_mock_, GetBfRtId(kP4MeterId))
-      .WillOnce(Return(kBfRtTableId));
+  EXPECT_CALL(*tdi_sde_wrapper_mock_, GetTdiRtId(kP4MeterId))
+      .WillOnce(Return(kTdiRtTableId));
   // TODO(max): figure out how to expect the session mock here.
-  EXPECT_CALL(*bf_sde_wrapper_mock_,
-              WriteIndirectMeter(kDevice1, _, kBfRtTableId,
+  EXPECT_CALL(*tdi_sde_wrapper_mock_,
+              WriteIndirectMeter(kDevice1, _, kTdiRtTableId,
                                  Optional(kMeterIndex), false, 1, 100, 2, 200))
       .WillOnce(Return(::util::OkStatus()));
 
@@ -218,11 +218,11 @@ TEST_F(BfrtTableManagerTest, WriteIndirectMeterEntryTest) {
   ::p4::v1::MeterEntry entry;
   ASSERT_OK(ParseProtoFromString(kMeterEntryText, &entry));
 
-  EXPECT_OK(bfrt_table_manager_->WriteMeterEntry(
+  EXPECT_OK(tdi_table_manager_->WriteMeterEntry(
       session_mock, ::p4::v1::Update::MODIFY, entry));
 }
 
-TEST_F(BfrtTableManagerTest, RejectMeterEntryModifyWithoutMeterId) {
+TEST_F(TdiTableManagerTest, RejectMeterEntryModifyWithoutMeterId) {
   ASSERT_OK(PushTestConfig());
   auto session_mock = std::make_shared<SessionMock>();
 
@@ -241,14 +241,14 @@ TEST_F(BfrtTableManagerTest, RejectMeterEntryModifyWithoutMeterId) {
   ::p4::v1::MeterEntry entry;
   ASSERT_OK(ParseProtoFromString(kMeterEntryText, &entry));
 
-  ::util::Status ret = bfrt_table_manager_->WriteMeterEntry(
+  ::util::Status ret = tdi_table_manager_->WriteMeterEntry(
       session_mock, ::p4::v1::Update::MODIFY, entry);
   ASSERT_FALSE(ret.ok());
   EXPECT_EQ(ERR_INVALID_PARAM, ret.error_code());
   EXPECT_THAT(ret.error_message(), HasSubstr("Missing meter id"));
 }
 
-TEST_F(BfrtTableManagerTest, RejectMeterEntryInsertDelete) {
+TEST_F(TdiTableManagerTest, RejectMeterEntryInsertDelete) {
   ASSERT_OK(PushTestConfig());
   auto session_mock = std::make_shared<SessionMock>();
 
@@ -267,28 +267,28 @@ TEST_F(BfrtTableManagerTest, RejectMeterEntryInsertDelete) {
   ::p4::v1::MeterEntry entry;
   ASSERT_OK(ParseProtoFromString(kMeterEntryText, &entry));
 
-  ::util::Status ret = bfrt_table_manager_->WriteMeterEntry(
+  ::util::Status ret = tdi_table_manager_->WriteMeterEntry(
       session_mock, ::p4::v1::Update::INSERT, entry);
   ASSERT_FALSE(ret.ok());
   EXPECT_EQ(ERR_INVALID_PARAM, ret.error_code());
 
-  ret = bfrt_table_manager_->WriteMeterEntry(session_mock,
+  ret = tdi_table_manager_->WriteMeterEntry(session_mock,
                                              ::p4::v1::Update::DELETE, entry);
   ASSERT_FALSE(ret.ok());
   EXPECT_EQ(ERR_INVALID_PARAM, ret.error_code());
 }
 
-TEST_F(BfrtTableManagerTest, ReadSingleIndirectMeterEntryTest) {
+TEST_F(TdiTableManagerTest, ReadSingleIndirectMeterEntryTest) {
   ASSERT_OK(PushTestConfig());
   auto session_mock = std::make_shared<SessionMock>();
   constexpr int kP4MeterId = 55555;
-  constexpr int kBfRtTableId = 11111;
+  constexpr int kTdiRtTableId = 11111;
   constexpr int kMeterIndex = 12345;
   WriterMock<::p4::v1::ReadResponse> writer_mock;
 
   {
-    EXPECT_CALL(*bf_sde_wrapper_mock_, GetBfRtId(kP4MeterId))
-        .WillOnce(Return(kBfRtTableId));
+    EXPECT_CALL(*tdi_sde_wrapper_mock_, GetTdiRtId(kP4MeterId))
+        .WillOnce(Return(kTdiRtTableId));
 
     std::vector<uint32> meter_indices = {kMeterIndex};
     std::vector<uint64> cirs = {1};
@@ -296,8 +296,8 @@ TEST_F(BfrtTableManagerTest, ReadSingleIndirectMeterEntryTest) {
     std::vector<uint64> pirs = {2};
     std::vector<uint64> pbursts = {200};
     std::vector<bool> in_pps = {true};
-    EXPECT_CALL(*bf_sde_wrapper_mock_,
-                ReadIndirectMeters(kDevice1, _, kBfRtTableId,
+    EXPECT_CALL(*tdi_sde_wrapper_mock_,
+                ReadIndirectMeters(kDevice1, _, kTdiRtTableId,
                                    Optional(kMeterIndex), _, _, _, _, _, _))
         .WillOnce(DoAll(SetArgPointee<4>(meter_indices), SetArgPointee<5>(cirs),
                         SetArgPointee<6>(cbursts), SetArgPointee<7>(pirs),
@@ -334,10 +334,10 @@ TEST_F(BfrtTableManagerTest, ReadSingleIndirectMeterEntryTest) {
   ASSERT_OK(ParseProtoFromString(kMeterEntryText, &entry));
 
   EXPECT_OK(
-      bfrt_table_manager_->ReadMeterEntry(session_mock, entry, &writer_mock));
+      tdi_table_manager_->ReadMeterEntry(session_mock, entry, &writer_mock));
 }
 
-TEST_F(BfrtTableManagerTest, RejectMeterEntryReadWithoutId) {
+TEST_F(TdiTableManagerTest, RejectMeterEntryReadWithoutId) {
   ASSERT_OK(PushTestConfig());
   auto session_mock = std::make_shared<SessionMock>();
   WriterMock<::p4::v1::ReadResponse> writer_mock;
@@ -358,7 +358,7 @@ TEST_F(BfrtTableManagerTest, RejectMeterEntryReadWithoutId) {
   ASSERT_OK(ParseProtoFromString(kMeterEntryText, &entry));
 
   ::util::Status ret =
-      bfrt_table_manager_->ReadMeterEntry(session_mock, entry, &writer_mock);
+      tdi_table_manager_->ReadMeterEntry(session_mock, entry, &writer_mock);
   ASSERT_FALSE(ret.ok());
   EXPECT_EQ(ERR_INVALID_PARAM, ret.error_code());
 }
diff --git a/stratum/hal/lib/barefoot/macros.h b/stratum/hal/lib/barefoot/macros.h
index f629cdc9..45c35c93 100644
--- a/stratum/hal/lib/barefoot/macros.h
+++ b/stratum/hal/lib/barefoot/macros.h
@@ -72,7 +72,7 @@ class BooleanBfStatus {
 
 // A macro for simplify checking and logging the return value of a SDE function
 // call.
-#define RETURN_IF_BFRT_ERROR(expr)                            \
+#define RETURN_IF_TDI_ERROR(expr)                            \
   if (const BooleanBfStatus __ret = BooleanBfStatus(expr)) {  \
   } else /* NOLINT */                                         \
     return MAKE_ERROR(__ret.error_code())                     \
diff --git a/stratum/hal/lib/barefoot/utils_test.cc b/stratum/hal/lib/barefoot/utils_test.cc
index 76929cfc..291c00cf 100644
--- a/stratum/hal/lib/barefoot/utils_test.cc
+++ b/stratum/hal/lib/barefoot/utils_test.cc
@@ -192,41 +192,41 @@ TEST(IsDontCareMatchTest, RejectAllOptionalMatch) {
 
 TEST(ConvertPriorityTest, ToAndFromP4Runtime) {
   const int32 kP4rtPriority = 1;
-  auto bfrt_priority = ConvertPriorityFromP4rtToBfrt(kP4rtPriority);
-  EXPECT_OK(bfrt_priority);
-  EXPECT_EQ(bfrt_priority.ValueOrDie(), 0xfffffe);
-  auto p4rt_priority_from_bfrt =
-      ConvertPriorityFromBfrtToP4rt(bfrt_priority.ValueOrDie());
-  EXPECT_OK(p4rt_priority_from_bfrt);
-  EXPECT_EQ(kP4rtPriority, p4rt_priority_from_bfrt.ValueOrDie());
+  auto tdirt_priority = ConvertPriorityFromP4rtToTdirt(kP4rtPriority);
+  EXPECT_OK(tdirt_priority);
+  EXPECT_EQ(tdirt_priority.ValueOrDie(), 0xfffffe);
+  auto p4rt_priority_from_tdirt =
+      ConvertPriorityFromTdirtToP4rt(tdirt_priority.ValueOrDie());
+  EXPECT_OK(p4rt_priority_from_tdirt);
+  EXPECT_EQ(kP4rtPriority, p4rt_priority_from_tdirt.ValueOrDie());
 }
 
-TEST(ConvertPriorityTest, ToAndFromBfrt) {
-  const uint64 kBfrtPriority = 1;
-  auto p4rt_priority = ConvertPriorityFromBfrtToP4rt(kBfrtPriority);
+TEST(ConvertPriorityTest, ToAndFromTdirt) {
+  const uint64 kTdirtPriority = 1;
+  auto p4rt_priority = ConvertPriorityFromTdirtToP4rt(kTdirtPriority);
   EXPECT_OK(p4rt_priority);
   EXPECT_EQ(p4rt_priority.ValueOrDie(), 0xfffffe);
-  auto bfrt_priority_from_p4rt =
-      ConvertPriorityFromBfrtToP4rt(p4rt_priority.ValueOrDie());
-  EXPECT_OK(bfrt_priority_from_p4rt);
-  EXPECT_EQ(kBfrtPriority, bfrt_priority_from_p4rt.ValueOrDie());
+  auto tdirt_priority_from_p4rt =
+      ConvertPriorityFromTdirtToP4rt(p4rt_priority.ValueOrDie());
+  EXPECT_OK(tdirt_priority_from_p4rt);
+  EXPECT_EQ(kTdirtPriority, tdirt_priority_from_p4rt.ValueOrDie());
 }
 
 TEST(ConvertPriorityTest, InvalidP4rtPriority) {
   {
-    auto result = ConvertPriorityFromP4rtToBfrt(0x1000000);
+    auto result = ConvertPriorityFromP4rtToTdirt(0x1000000);
     EXPECT_THAT(result.status().error_code(),
                 stratum::ErrorCode::ERR_INVALID_PARAM);
   }
   {
-    auto result = ConvertPriorityFromP4rtToBfrt(-1);
+    auto result = ConvertPriorityFromP4rtToTdirt(-1);
     EXPECT_THAT(result.status().error_code(),
                 stratum::ErrorCode::ERR_INVALID_PARAM);
   }
 }
 
-TEST(ConvertPriorityTest, InvalidBfrtPriority) {
-  auto result = ConvertPriorityFromBfrtToP4rt(0x1000000);
+TEST(ConvertPriorityTest, InvalidTdirtPriority) {
+  auto result = ConvertPriorityFromTdirtToP4rt(0x1000000);
   EXPECT_THAT(result.status().error_code(),
               stratum::ErrorCode::ERR_INVALID_PARAM);
 }
diff --git a/stratum/hal/lib/common/common.proto b/stratum/hal/lib/common/common.proto
index f7a72d70..32d36020 100644
--- a/stratum/hal/lib/common/common.proto
+++ b/stratum/hal/lib/common/common.proto
@@ -63,6 +63,20 @@ enum TrafficClass {
   LLQ2 = 30;  // Low-latency congestion-control queue (go/llq)
 };
 
+// Mode of hotplug request
+enum SWBackendQemuHotplugStatus {
+  NO_HOTPLUG = 0;
+  HOTPLUG_ADD = 1;
+  HOTPLUG_DEL = 2;
+}
+
+// Packet Direction type
+enum SWBackendPktDirType {
+  DIRECTION_HOST = 0;
+  DIRECTION_NETWORK = 1;
+  DIRECTION_NONE = 2;
+};
+
 //------------------------------------------------------------------------------
 // Definition of chassis, nodes, singleton ports, trunk ports, etc in the
 // internal chassis config (defined later in this file) pushed to the managers.
@@ -243,6 +257,55 @@ enum FecMode {
   FEC_MODE_AUTO = 3;
 }
 
+// SW backend port Types
+enum SWBackendPortType {
+  PORT_TYPE_NONE = 0;
+  PORT_TYPE_VHOST = 1;
+  PORT_TYPE_TAP = 2;
+  PORT_TYPE_LINK = 3;
+  PORT_TYPE_SOURCE = 4;
+  PORT_TYPE_SINK = 5;
+}
+
+// SW backend device type:
+enum SWBackendDeviceType {
+  DEVICE_TYPE_NONE = 0;
+  DEVICE_TYPE_VIRTIO_NET = 1;
+  DEVICE_TYPE_VIRTIO_BLK = 2;
+}
+
+// SW backend Hotplug params
+enum SWBackendHotplugParams {
+  PARAM_NONE = 0;
+  PARAM_SOCK_IP = 1;
+  PARAM_SOCK_PORT = 2;
+  PARAM_HOTPLUG = 3;
+  PARAM_VM_MAC = 4;
+  PARAM_NETDEV_ID = 5;
+  PARAM_CHARDEV_ID = 6;
+  PARAM_NATIVE_SOCK_PATH = 7;
+  PARAM_DEVICE_ID = 8;
+}
+
+// Hotplug cnfig parameters for qemu based VM
+message HotplugConfig {
+  // Socket ip for qemu monitor socket
+  string qemu_socket_ip = 1;
+  // Socket port for qemu monitor socket
+  uint32 qemu_socket_port = 2;
+  // Qemu Hotplug status
+  SWBackendQemuHotplugStatus qemu_hotplug = 3;
+  // The configured mac address for this port.
+  uint64 qemu_vm_mac_address = 4;
+  // VM netdev id for hotplug
+  string qemu_vm_netdev_id = 5;
+  // VM chardev id for hotplug
+  string qemu_vm_chardev_id = 6;
+  // Native socket path ( applicable for containers)
+  string native_socket_path = 7;
+  // VM device id for hotplug
+  string qemu_vm_device_id = 8;
+}
 // Config-related parameters for the ports (singleton and trunk ports).
 message PortConfigParams {
   // Per port hash config. Most of the hash configuration is given per node.
@@ -276,6 +339,30 @@ message PortConfigParams {
   MacAddress mac_address = 7;
   // The configured loopback state for this port.
   LoopbackState loopback_mode = 8;
+  // Type of this port.
+  SWBackendPortType type = 9;
+  // Flag to trigger SW backed pipeline.
+  bool build_pipeline = 10;
+  // VM associated in the OpenConfig.
+  string host_name = 11;
+  // Queues to be configured
+  int32 queues  = 12;
+  // Socket path to be used
+  string socket = 13;
+  // Backend device type
+  SWBackendDeviceType device_type = 14;
+  // Pipeline name to be used
+  string pipeline = 15;
+  // Mempool name to be used
+  string mempool = 16;
+  // Flag to trigger Auto creation of back-end control TAP ports and rules.
+  string control = 17;
+  // PCI BDF value to be used for the LINK port
+  string pci = 18;
+  // Per Qemu VM hotplug config
+  HotplugConfig hotplug_config = 19;
+  // Packet direction
+  SWBackendPktDirType packet_dir = 20;
 }
 
 // Chassis uniquely identifies a switch with a single management interface,
@@ -1115,6 +1202,61 @@ message LoopbackStatus {
   LoopbackState state = 1;  // required
 }
 
+// Specifies backend port type to be used
+message SWBackendPortStatus {
+  SWBackendPortType type = 1; // required
+}
+
+// Specifies backend device type to be used
+message SWBackendDeviceStatus {
+  SWBackendDeviceType device_type = 1; // required
+}
+
+// Specifies host to be used by the device
+message HostConfigName {
+  string host_name = 1; // required
+}
+
+// Specifies number of queues needed for backend
+message QueuesConfigured {
+  int32 queue_count = 1; // required
+}
+
+// Specifies socket path to be used for port creation
+message SocketPathConfigured {
+  string sock_path = 1; // required
+}
+
+// Specifies pipeline name to be used for port association
+message PipelineNameConfigured {
+  string pipeline_name = 1; // required
+}
+
+// Specifies mempool name to be used for port association
+message MempoolNameConfigured {
+  string mempool_name = 1; // required
+}
+
+// Specifies packet direction to be used for port association
+message SWBackendPktDirStatus {
+  SWBackendPktDirType packet_dir = 1; // required
+}
+
+// Specifies if Auto creation of back-end control TAP ports is needed.
+message ControlPortConfigured {
+  string control_port = 1; // required
+}
+
+// Specifies PCI BDF value to be used for the LINK port.
+message PciBdfConfigured {
+  string pci_bdf = 1; // required
+}
+
+// Specifies the MTU value to be used
+message MtuValue {
+  int32 mtu_value = 1; // required
+}
+
 // Wrapper around admin state of a HW component.
 message AdminStatus {
   AdminState state = 1;  // required
@@ -1220,6 +1362,12 @@ message SdnPortId {
   uint32 port_id = 1;
 }
 
+// Wrapper around Target datapath index required for pipeline configuration
+message TargetDatapathId {
+  uint32 tdi_portin_id = 1; // Port ID for Pipeline in Input Direction
+  uint32 tdi_portout_id = 2; // Port ID for Pipeline in Output Direction
+}
+
 // DataRequest is a message used internally to request data about a component
 // or a set of components through SwitchInterface. It is specifically used in
 // ConfigMonitoringService, as part of gNMI Get/Subscribe RPC implementation.
@@ -1270,6 +1418,7 @@ message DataRequest {
       Port loopback_status = 20;
       Node node_info = 21;
       Port sdn_port_id = 22;
+      Port target_dp_id = 23;
     }
   }
   repeated Request requests = 1;
@@ -1302,6 +1451,19 @@ message DataResponse {
     LoopbackStatus loopback_status = 20;
     NodeInfo node_info = 21;
     SdnPortId sdn_port_id = 22;
+    SWBackendPortStatus port_type = 23;
+    HostConfigName host_config = 24;
+    QueuesConfigured queue_count = 25;
+    SocketPathConfigured sock_path = 26;
+    SWBackendDeviceStatus device_type = 27;
+    PipelineNameConfigured pipeline_name = 28;
+    MempoolNameConfigured mempool_name = 29;
+    ControlPortConfigured control_port = 30;
+    PciBdfConfigured pci_bdf = 31;
+    MtuValue mtu_value = 32;
+    HotplugConfig hotplug_config = 33;
+    TargetDatapathId target_dp_id = 34;
+    SWBackendPktDirStatus packet_dir = 35;
   }
 }
 
@@ -1331,6 +1493,30 @@ message SetRequest {
         ForwardingViability forwarding_viability = 10;
         // The intended loopback state of the port.
         LoopbackStatus loopback_status = 11;
+        // The new port type to be used.
+        SWBackendPortStatus port_type = 12;
+        // The new device to be used.
+        SWBackendDeviceStatus device_type = 13;
+        // The hostname to be used by backend.
+        HostConfigName host_config = 14;
+        // The no of queues to be used by backend.
+        QueuesConfigured queue_count = 15;
+        // The socket path to be used by backend.
+        SocketPathConfigured sock_path = 16;
+        // The Pipeline name to be used for port association.
+        PipelineNameConfigured pipeline_name = 17;
+        // The Mempool name to be used for port association.
+        MempoolNameConfigured mempool_name = 18;
+        // The control port to be used for creation of back-end TAP ports/rules
+        ControlPortConfigured control_port = 19;
+        // PCI BDF value to be used for the LINK port
+        PciBdfConfigured pci_bdf = 20;
+        // MTU value to be used for the Port
+        MtuValue mtu_value = 21;
+        // Per Qemu VM hotplug config
+        HotplugConfig hotplug_config = 22;
+        // The packet direction to be used for port association.
+        SWBackendPktDirStatus packet_dir = 23;
       }
     }
     // Data required to set info for a specific node.
diff --git a/stratum/hal/lib/common/gnmi_events.h b/stratum/hal/lib/common/gnmi_events.h
index 9ef4b7d2..ff9cf9c0 100644
--- a/stratum/hal/lib/common/gnmi_events.h
+++ b/stratum/hal/lib/common/gnmi_events.h
@@ -13,7 +13,7 @@
 
 #include "absl/container/flat_hash_map.h"
 #include "absl/synchronization/mutex.h"
-#include "gnmi/gnmi.grpc.pb.h"
+#include "p4/gnmi/gnmi.grpc.pb.h"
 #include "stratum/glue/gtl/map_util.h"
 #include "stratum/glue/integral_types.h"
 #include "stratum/glue/status/status.h"
